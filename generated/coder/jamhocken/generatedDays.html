<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2021: jamhocken</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2021/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2021/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2021.netlify.app/","doctoolchain.org/aoc-2021/");
          }
      </script>
<!-- /aoc-2021/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2021//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2021//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2021//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2021//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2021//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2021</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:aoc-2021.netlify.com">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_jamhocken">jamhocken</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_01_python">Day 01: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned">What I learned</a></li>
<li><a href="#_approach">Approach</a></li>
<li><a href="#_run_script">Run script</a></li>
</ul>
</li>
<li><a href="#_day_02_python">Day 02: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_2">What I learned</a></li>
<li><a href="#_approach_2">Approach</a></li>
<li><a href="#_run_script_2">Run script</a></li>
</ul>
</li>
<li><a href="#_day_03_python">Day 03: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_3">What I learned</a></li>
<li><a href="#_approach_3">Approach</a></li>
<li><a href="#_run_script_3">Run script</a></li>
</ul>
</li>
<li><a href="#_day_04_python">Day 04: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_4">What I learned</a></li>
<li><a href="#_approach_4">Approach</a></li>
<li><a href="#_run_script_4">Run script</a></li>
</ul>
</li>
<li><a href="#_day_05_python">Day 05: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_5">What I learned</a></li>
<li><a href="#_approach_5">Approach</a></li>
<li><a href="#_run_script_5">Run script</a></li>
</ul>
</li>
<li><a href="#_day_06_python">Day 06: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_6">What I learned</a></li>
<li><a href="#_approach_6">Approach</a></li>
<li><a href="#_run_script_6">Run script</a></li>
</ul>
</li>
<li><a href="#_day_07_python">Day 07: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_7">What I learned</a></li>
<li><a href="#_approach_7">Approach</a></li>
<li><a href="#_run_script_7">Run script</a></li>
</ul>
</li>
<li><a href="#_day_08_python">Day 08: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_8">What I learned</a></li>
<li><a href="#_approach_8">Approach</a></li>
<li><a href="#_run_script_8">Run script</a></li>
</ul>
</li>
<li><a href="#_day_09_python">Day 09: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_9">What I learned</a></li>
<li><a href="#_approach_9">Approach</a></li>
<li><a href="#_run_script_9">Run script</a></li>
</ul>
</li>
<li><a href="#_day_10_python">Day 10: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_10">What I learned</a></li>
<li><a href="#_approach_10">Approach</a></li>
<li><a href="#_run_script_10">Run script</a></li>
</ul>
</li>
<li><a href="#_day_11_python">Day 11: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_11">What I learned</a></li>
<li><a href="#_approach_11">Approach</a></li>
<li><a href="#_run_script_11">Run script</a></li>
</ul>
</li>
<li><a href="#_day_12_python">Day 12: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_12">What I learned</a></li>
<li><a href="#_approach_12">Approach</a></li>
<li><a href="#_run_script_12">Run script</a></li>
</ul>
</li>
<li><a href="#_day_13_python">Day 13: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_13">What I learned</a></li>
<li><a href="#_approach_13">Approach</a></li>
<li><a href="#_run_script_13">Run script</a></li>
</ul>
</li>
<li><a href="#_day_14_python">Day 14: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_14">What I learned</a></li>
<li><a href="#_approach_14">Approach</a></li>
<li><a href="#_run_script_14">Run script</a></li>
</ul>
</li>
<li><a href="#_day_15_python">Day 15: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_15">What I learned</a></li>
<li><a href="#_approach_15">Approach</a></li>
<li><a href="#_run_script_15">Run script</a></li>
</ul>
</li>
<li><a href="#_day_16_python">Day 16: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_16">What I learned</a></li>
<li><a href="#_approach_16">Approach</a></li>
<li><a href="#_run_script_16">Run script</a></li>
</ul>
</li>
<li><a href="#_day_17_python">Day 17: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_17">What I learned</a></li>
<li><a href="#_approach_17">Approach</a></li>
<li><a href="#_run_script_17">Run script</a></li>
</ul>
</li>
<li><a href="#_day_18_python">Day 18: python</a>
<ul class="sectlevel3">
<li><a href="#_what_i_learned_18">What I learned</a></li>
<li><a href="#_approach_18">Approach</a></li>
<li><a href="#_run_script_18">Run script</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_jamhocken"><a class="anchor" href="#_jamhocken"></a><a class="link" href="#_jamhocken">jamhocken</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/75045692?v=4" alt="75045692?v=4"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>jamhocken</strong><br>
<span class="icon"><i class="fa fa-github"></i></span>: <a href="https://github.com/jamhocken">jamhocken</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>Nothing here yet. Update your profile at <a href="https://github.com/docToolchain/aoc-2021/blob/master/profiles/jamhocken.adoc">/profiles/jamhocken.adoc</a></p>
</div>
<a id="day01" />
</div>
<div class="sect2">
<h3 id="_day_01_python"><a class="anchor" href="#_day_01_python"></a><a class="link" href="#_day_01_python">Day 01: python</a></h3>
<div class="paragraph">
<p>Day 1 of year 2021
<a href="https://adventofcode.com/2021/day/1" class="bare">https://adventofcode.com/2021/day/1</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned"><a class="anchor" href="#_what_i_learned"></a><a class="link" href="#_what_i_learned">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I forgot that Python also can do string comparisons. Now, I remember.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach"><a class="anchor" href="#_approach"></a><a class="link" href="#_approach">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For star 1, I just go through the whole list comparing the values pair-wise.</p>
</li>
<li>
<p>For star 2, I created a list with the 3 value window. And then compared that list pair-wise.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script"><a class="anchor" href="#_run_script"></a><a class="link" href="#_run_script">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [int(line.strip()) for line in file_contents]

    return lines_stripped

def main():
    with open("input.txt",'r') as depths_file:
        file_lines = depths_file.readlines()

    depths = process_input(file_lines)

    count = 0

    for i in range(len(depths)-1):
        if depths[i+1]&gt;depths[i]:
            count += 1

    print(count)

    window = []
    for i in range(len(depths)-2):
        window.append(depths[i]+depths[i+1]+depths[i+2])

    count = 0
    for i in range(len(window)-1):
        if window[i+1]&gt;window[i]:
            count += 1

    print(count)

main()</code></pre>
</div>
</div>
<a id="day02" />
</div>
</div>
<div class="sect2">
<h3 id="_day_02_python"><a class="anchor" href="#_day_02_python"></a><a class="link" href="#_day_02_python">Day 02: python</a></h3>
<div class="paragraph">
<p>Day 2 of year 2021
<a href="https://adventofcode.com/2021/day/2" class="bare">https://adventofcode.com/2021/day/2</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_2"><a class="anchor" href="#_what_i_learned_2"></a><a class="link" href="#_what_i_learned_2">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Straightforward. :-)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_2"><a class="anchor" href="#_approach_2"></a><a class="link" href="#_approach_2">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and put the command as a string and the value as an int in a list of tuples.</p>
</li>
<li>
<p>For both stars, you go through the list and do what the instructions say to do.</p>
</li>
<li>
<p>Star 2 is then not any more complicated than star 1, just different instructions.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_2"><a class="anchor" href="#_run_script_2"></a><a class="link" href="#_run_script_2">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    lines_split = []
    for lines in lines_stripped:
        line = lines.split()
        lines_split.append((line[0], int(line[1])))

    return lines_split

def main():
    with open("input.txt",'r') as course_file:
        course_lines = course_file.readlines()

    course = process_input(course_lines)

    horizontal = 0
    depth = 0

    for directions in course:
        if directions[0] == 'forward':
            horizontal += directions[1]
        elif directions[0] == 'up':
            depth -= directions[1]
        else:
            depth += directions[1]

    print(horizontal, depth, depth*horizontal)

    horizontal = 0
    aim = 0
    depth = 0

    for directions in course:
        if directions[0] == 'forward':
            horizontal += directions[1]
            depth += aim*directions[1]
        elif directions[0] == 'up':
            aim -= directions[1]
        else:
            aim += directions[1]

    print(horizontal, depth, depth*horizontal)

main()</code></pre>
</div>
</div>
<a id="day03" />
</div>
</div>
<div class="sect2">
<h3 id="_day_03_python"><a class="anchor" href="#_day_03_python"></a><a class="link" href="#_day_03_python">Day 03: python</a></h3>
<div class="paragraph">
<p>Day 3 of year 2021
<a href="https://adventofcode.com/2021/day/3" class="bare">https://adventofcode.com/2021/day/3</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_3"><a class="anchor" href="#_what_i_learned_3"></a><a class="link" href="#_what_i_learned_3">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Somehow I don&#8217;t understand slices with lists in Python, but at least I do understand it for matrices with Numpy.</p>
</li>
<li>
<p>The whole thing isn&#8217;t very elegant, I&#8217;m afraid.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_3"><a class="anchor" href="#_approach_3"></a><a class="link" href="#_approach_3">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and put all of the codes into a list of lists.</p>
</li>
<li>
<p>For star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I take that list of lists and turned it into a Numpy matrix. I then sum each digit over all
codes and compare that sum to half of the number of codes to find the majority digit for Gamma.</p>
</li>
<li>
<p>I then used some modula arithmetic to find the inverse Epsilon.</p>
</li>
<li>
<p>Converted to strings, joined it and converted to integers.</p>
</li>
</ol>
</div>
</li>
<li>
<p>For star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I go through each digit and cull out the codes that don&#8217;t belong to the majority / minority.</p>
</li>
<li>
<p>I recalculate the majority / minority evey run through the loop with a Numpy matrix again.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_3"><a class="anchor" href="#_run_script_3"></a><a class="link" href="#_run_script_3">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">import numpy as np

def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    bin_digits = [[int(j) for j in list(code)] for code in lines_stripped]

    return bin_digits

def main():
    with open("input.txt",'r') as diagnostic_file:
        diagnostic_lines = diagnostic_file.readlines()

    diagnostics = process_input(diagnostic_lines)

    diag_matrix = np.matrix(diagnostics)
    matrix_size = diag_matrix.shape
    no_codes = matrix_size[0]
    sum_diag = diag_matrix.sum(0)
    sum_diag = sum_diag.tolist()[0]

    gamma = int(''.join([str(int(j // (no_codes/2))) for j in sum_diag]),2)
    epsilon = int(''.join([str(int(j // (no_codes/2)+1)%2) for j in sum_diag]),2)

    print(gamma, epsilon, gamma*epsilon)

    if gamma&lt;2**(matrix_size[1]-1):
        majority_oxy = 0
        majority_co2 = 1
    else:
        majority_oxy = 1
        majority_co2 = 0

    candidates_oxy = diagnostics.copy()
    candidates_co2 = diagnostics.copy()
    i = 0

    while len(candidates_oxy)!=1 or len(candidates_co2)!=1:
        oxy_temp = candidates_oxy.copy()
        co2_temp = candidates_co2.copy()
        if len(candidates_oxy) != 1:
            for code in oxy_temp:
                if code[i]!=majority_oxy:
                    candidates_oxy.remove(code)
        if len(candidates_co2) != 1:
            for code in co2_temp:
                if code[i]!=majority_co2:
                    candidates_co2.remove(code)
        if i != matrix_size[1]-1:
            i += 1
            oxy_matrix = np.matrix(candidates_oxy)
            sum_oxy = oxy_matrix.sum(0)
            sum_oxy = sum_oxy.tolist()[0]

            co2_matrix = np.matrix(candidates_co2)
            sum_co2 = co2_matrix.sum(0)
            sum_co2 = sum_co2.tolist()[0]

            if sum_oxy[i] &gt;= len(candidates_oxy)/2:
                majority_oxy = 1
            else:
                majority_oxy = 0
            if sum_co2[i] &lt; len(candidates_co2)/2:
                majority_co2 = 1
            else:
                majority_co2 = 0

    c_oxy = int(''.join([str(i) for i in candidates_oxy[0]]),2)
    c_co2 = int(''.join([str(i) for i in candidates_co2[0]]),2)

    print(c_oxy, c_co2, c_oxy*c_co2)

main()</code></pre>
</div>
</div>
<a id="day04" />
</div>
</div>
<div class="sect2">
<h3 id="_day_04_python"><a class="anchor" href="#_day_04_python"></a><a class="link" href="#_day_04_python">Day 04: python</a></h3>
<div class="paragraph">
<p>Day 4 of year 2021
<a href="https://adventofcode.com/2021/day/4" class="bare">https://adventofcode.com/2021/day/4</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_4"><a class="anchor" href="#_what_i_learned_4"></a><a class="link" href="#_what_i_learned_4">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I tried out some new functions in Numpy</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_4"><a class="anchor" href="#_approach_4"></a><a class="link" href="#_approach_4">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Create a list of the numbers called</p>
</li>
<li>
<p>Create a list of all of the bingo cards as well as a "marker" card for each of the bingo cards</p>
</li>
<li>
<p>The marker cards are initialized to have the value 1 everywhere.</p>
</li>
</ol>
</div>
</li>
<li>
<p>For star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I go through the numbers called and for each bingo card that has that number,
I put a zero on the appropriate spot on the marker card.</p>
</li>
<li>
<p>I then check if any of the columns or rows of that marker card are now filled with zeros.</p>
</li>
<li>
<p>If it is the first card to get bingo, I set the "bingo" flag and print out the value for Star 1.</p>
</li>
</ol>
</div>
</li>
<li>
<p>For star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I only had to slightly modify the code.</p>
</li>
<li>
<p>I added a set of all of the cards that haven&#8217;t won yet. If a card wins, I remove it from the set.</p>
</li>
<li>
<p>I iterate through until the last card has won. And then exit the loop and do the calculation for the answer.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_4"><a class="anchor" href="#_run_script_4"></a><a class="link" href="#_run_script_4">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">import numpy as np

def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    numbers_called = [int(x) for x in lines_stripped[0].split(",")]
    cards = []

    i = 2
    while i &lt; len(lines_stripped):
        bingo_card = []
        marker_card = []
        for j in range(5):
            bingo_card.append([int(x) for x in lines_stripped[i+j].split()])
            marker_card.append([1]*5)
        cards.append([bingo_card,marker_card])
        i += 6

    return numbers_called, cards

def main():
    with open("input.txt",'r') as bingo_file:
        bingo_lines = bingo_file.readlines()

    (numbers_called, cards) = process_input(bingo_lines)

    card_arrays = [[np.array(bingo_card),np.array(marker_card)] for bingo_card, marker_card in cards]
    bingo = 0
    j = -1
    non_winners = set(range(len(card_arrays)))
    nw_temp = non_winners.copy()

    while len(non_winners)&gt;0:
        j += 1
        for i in non_winners:
            card_arrays[i][1] = np.where(card_arrays[i][0]==numbers_called[j],0,card_arrays[i][1])
            if (~card_arrays[i][1].any(axis=0)).any() or (~card_arrays[i][1].any(axis=1)).any():
               if bingo == 0:
                   bingo = 1
                   winning_card = i
                   print(np.sum(np.multiply(card_arrays[winning_card][0],card_arrays[winning_card][1]))*numbers_called[j])
               if len(non_winners)==1:
                   losing_card = i
               nw_temp.remove(i)
        non_winners = nw_temp.copy()

    print(np.sum(np.multiply(card_arrays[losing_card][0],card_arrays[losing_card][1]))*numbers_called[j])

main()</code></pre>
</div>
</div>
<a id="day05" />
</div>
</div>
<div class="sect2">
<h3 id="_day_05_python"><a class="anchor" href="#_day_05_python"></a><a class="link" href="#_day_05_python">Day 05: python</a></h3>
<div class="paragraph">
<p>Day 5 of year 2021
<a href="https://adventofcode.com/2021/day/5" class="bare">https://adventofcode.com/2021/day/5</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_5"><a class="anchor" href="#_what_i_learned_5"></a><a class="link" href="#_what_i_learned_5">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I refreshed regex for myself (again).</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_5"><a class="anchor" href="#_approach_5"></a><a class="link" href="#_approach_5">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file with a regex and create a list of all of the vectors.</p>
</li>
<li>
<p>For star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I check if the line is vertical and iterate the value in a dictionary for each coordinate on the line.</p>
</li>
<li>
<p>I then check if it is horizontal and do the same.</p>
</li>
<li>
<p>I then check the dictionary for any values more than 1 and sum over the number of those entries.</p>
</li>
</ol>
</div>
</li>
<li>
<p>For star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I still do the horizontal and vertical checks.</p>
</li>
<li>
<p>And then do the diagonal lines.</p>
</li>
<li>
<p>I think this could be simplified / shortened, but I didn&#8217;t bother.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_5"><a class="anchor" href="#_run_script_5"></a><a class="link" href="#_run_script_5">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">import re

def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    regex_vectorline = re.compile('(\d+),(\d+)\s\S+\s(\d+),(\d+)')

    vectors = sum([[[int(i) for i in j] for j in re.findall(regex_vectorline,lines)] for lines in lines_stripped],[])

    return vectors

def star1(vectors):
    vents = {}
    for vector in vectors:
        if vector[0] == vector[2]:
            if vector[1]&gt;vector[3]:
                y_coordinates = range(vector[3],vector[1]+1)
            else:
                y_coordinates = range(vector[1],vector[3]+1)
            for y in y_coordinates:
                if (vector[0],y) in vents:
                    vents[(vector[0],y)] += 1
                else:
                    vents[(vector[0],y)] = 1
        elif vector[1] == vector[3]:
            if vector[0]&gt;vector[2]:
                x_coordinates = range(vector[2],vector[0]+1)
            else:
                x_coordinates = range(vector[0],vector[2]+1)
            for x in x_coordinates:
                if (x,vector[1]) in vents:
                    vents[x,(vector[1])] += 1
                else:
                    vents[x,(vector[1])] = 1
    return vents

def star2(vectors):
    vents = {}
    for vector in vectors:
        if vector[0] == vector[2]:
            if vector[1]&gt;vector[3]:
                y_coordinates = range(vector[3],vector[1]+1)
            else:
                y_coordinates = range(vector[1],vector[3]+1)
            for y in y_coordinates:
                if (vector[0],y) in vents:
                    vents[(vector[0],y)] += 1
                else:
                    vents[(vector[0],y)] = 1
        elif vector[1] == vector[3]:
            if vector[0]&gt;vector[2]:
                x_coordinates = range(vector[2],vector[0]+1)
            else:
                x_coordinates = range(vector[0],vector[2]+1)
            for x in x_coordinates:
                if (x,vector[1]) in vents:
                    vents[x,(vector[1])] += 1
                else:
                    vents[x,(vector[1])] = 1
        else:
            if vector[0]&gt;vector[2]:
                x_coordinates = range(vector[2],vector[0]+1)
            else:
                x_coordinates = range(vector[2],vector[0]-1,-1)
            if vector[1]&gt;vector[3]:
                y_coordinates = range(vector[3],vector[1]+1)
            else:
                y_coordinates = range(vector[3],vector[1]-1,-1)
            for i in range(len(x_coordinates)):
                if (x_coordinates[i],y_coordinates[i]) in vents:
                    vents[x_coordinates[i],y_coordinates[i]] += 1
                else:
                    vents[x_coordinates[i],y_coordinates[i]] = 1

    return vents

def main():
    with open("input.txt",'r') as vector_file:
        vector_lines = vector_file.readlines()

    vectors = process_input(vector_lines)

    vents = star1(vectors)
    critical = sum([1 if value&gt;1 else 0 for value in vents.values()])
    print(critical)

    vents = star2(vectors)
    critical = sum([1 if value&gt;1 else 0 for value in vents.values()])
    print(critical)

main()</code></pre>
</div>
</div>
<a id="day06" />
</div>
</div>
<div class="sect2">
<h3 id="_day_06_python"><a class="anchor" href="#_day_06_python"></a><a class="link" href="#_day_06_python">Day 06: python</a></h3>
<div class="paragraph">
<p>Day 6 of year 2021
<a href="https://adventofcode.com/2021/day/6" class="bare">https://adventofcode.com/2021/day/6</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_6"><a class="anchor" href="#_what_i_learned_6"></a><a class="link" href="#_what_i_learned_6">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It is straightforward as soon as you see that you only have to count the fish.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_6"><a class="anchor" href="#_approach_6"></a><a class="link" href="#_approach_6">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the line and convert to integers.</p>
</li>
<li>
<p>Then I count how many fish are in each of the possible fish states (9 of them).</p>
</li>
<li>
<p>For both stars, you just create a loop with the right number of days.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>You write the number in state 0 into state 8.</p>
</li>
<li>
<p>You add the number from state 7 to the number from state 0 and put it into state 6.</p>
</li>
<li>
<p>All others follow the rule state n is written to state n-1.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_6"><a class="anchor" href="#_run_script_6"></a><a class="link" href="#_run_script_6">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    fish = [int(i) for i in lines_stripped[0].split(",")]

    fish_states = [0]*9

    for lf in fish:
        fish_states[lf] += 1

    return fish_states

def main():
    with open("input.txt",'r') as fish_file:
        fish_lines = fish_file.readlines()

    fish_states = process_input(fish_lines)

    for day in range(256):
        fish_states_temp = fish_states.copy()
        for states in range(len(fish_states)):
            if states == 0:
                fish_states_temp[8] = fish_states[0]
                fish_states_temp[6] = fish_states[0]
            elif states == 7:
                fish_states_temp[6] += fish_states[7]
            else:
                fish_states_temp[states-1] = fish_states[states]
        fish_states = fish_states_temp
        if day == 79:
            print(sum(fish_states))

    print(sum(fish_states))

main()</code></pre>
</div>
</div>
<a id="day07" />
</div>
</div>
<div class="sect2">
<h3 id="_day_07_python"><a class="anchor" href="#_day_07_python"></a><a class="link" href="#_day_07_python">Day 07: python</a></h3>
<div class="paragraph">
<p>Day 7 of year 2021
<a href="https://adventofcode.com/2021/day/7" class="bare">https://adventofcode.com/2021/day/7</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_7"><a class="anchor" href="#_what_i_learned_7"></a><a class="link" href="#_what_i_learned_7">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Straightforward.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_7"><a class="anchor" href="#_approach_7"></a><a class="link" href="#_approach_7">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the line and convert to integers.</p>
</li>
<li>
<p>For star 1, it&#8217;s just statistics.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The optimal spot is the median.</p>
</li>
</ol>
</div>
</li>
<li>
<p>For star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If you start going through all possible values, it might take a while.</p>
</li>
<li>
<p>So, I used the median as my starting point and looked if the fuel consumption is improved by increasing or decreasing from there.</p>
</li>
<li>
<p>Then, I just iterate through until I come to the other side of the global optimum and take the value before that.</p>
</li>
</ol>
</div>
</li>
<li>
<p>It&#8217;s probably not optimized, but it only takes a few seconds to run.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_7"><a class="anchor" href="#_run_script_7"></a><a class="link" href="#_run_script_7">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">import statistics

def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    crabs = [int(i) for i in lines_stripped[0].split(",")]

    return crabs

def main():
    with open("input.txt",'r') as crab_file:
        crab_lines = crab_file.readlines()

    crabs = process_input(crab_lines)

    # The optimal position is the median for star 1
    center = int(statistics.median(crabs))

    fuel = 0
    for crab in crabs:
        fuel += abs(crab-center)
    print(fuel)

    # The median is a good starting point for star 2
    fuel = 0
    for crab in crabs:
        for i in range(abs(crab-center)):
            fuel += i+1

    # Is the optimal answer more or less than the median?
    fuel_old = fuel
    fuel = 0
    center_temp = center - 1
    for crab in crabs:
        for i in range(abs(crab-center_temp)):
            fuel += i+1
    if fuel &lt; fuel_old:
        iterator = -1
    else:
        iterator = 1

    # Iterate until the values start to increase
    fuel = fuel_old
    while fuel&lt;=fuel_old:
        fuel_old = fuel
        fuel = 0
        center = center + iterator
        for crab in crabs:
            for i in range(abs(crab-center)):
                fuel += i+1

    print(fuel_old)

main()</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
<div class="sect2">
<h3 id="_day_08_python"><a class="anchor" href="#_day_08_python"></a><a class="link" href="#_day_08_python">Day 08: python</a></h3>
<div class="paragraph">
<p>Day 8 of year 2021
<a href="https://adventofcode.com/2021/day/8" class="bare">https://adventofcode.com/2021/day/8</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_8"><a class="anchor" href="#_what_i_learned_8"></a><a class="link" href="#_what_i_learned_8">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Frozen sets and some basic set manipulation in Python.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_8"><a class="anchor" href="#_approach_8"></a><a class="link" href="#_approach_8">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the line and create 2 lists with the input and output strings</p>
</li>
<li>
<p>For star 1, i just flatten the output list and count all entries with 2,3,4 or 7 letters.</p>
</li>
<li>
<p>For star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I turned the input and output entries (strings) into frozen sets to avoid messing with ordering.</p>
</li>
<li>
<p>I also sorted the input strings for every entry according to their lengths to minimize searching later.</p>
</li>
<li>
<p>For each input line, I immediately map 1, 7, 4 and 8 since these are only length dependent (I used a dict to hold the mapping).</p>
</li>
<li>
<p>You can logically derive the other ones by using length + looking at which other known numbers are subsets.</p>
</li>
<li>
<p>Then, you just use the dictionary to find the output digits, concatenate them and sum over all lines</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_8"><a class="anchor" href="#_run_script_8"></a><a class="link" href="#_run_script_8">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    inputs = [lines.split("|")[0].split() for lines in lines_stripped]
    outputs = [lines.split("|")[1].split() for lines in lines_stripped]

    return inputs, outputs

def main():
    with open("input.txt",'r') as segment_file:
        segment_lines = segment_file.readlines()

    inputs,outputs = process_input(segment_lines)

    #star 1
    uniques = 0
    flat_list = [item for sublist in outputs for item in sublist]
    for item in flat_list:
        if len(item) in [2,3,4,7]:
            uniques += 1
    print(uniques)

    #star 2
    inputs = [sorted([frozenset(segment) for segment in i],key=len) for i in inputs]
    outputs = [[frozenset(segment) for segment in i] for i in outputs]

    sum_digits = 0
    for j in range(len(inputs)):
        mapping = {inputs[j][0]:1,inputs[j][1]:7,inputs[j][2]:4,inputs[j][9]:8}
        for i in [3,4,5]:
            if inputs[j][1].issubset(inputs[j][i]):
                mapping[inputs[j][i]] = 3
            elif (inputs[j][2]- inputs[j][0]).issubset(inputs[j][i]):
                mapping[inputs[j][i]] = 5
            else:
                mapping[inputs[j][i]] = 2
        for i in [6,7,8]:
            if inputs[j][2].issubset(inputs[j][i]):
                mapping[inputs[j][i]] = 9
            elif inputs[j][0].issubset(inputs[j][i]):
                mapping[inputs[j][i]] = 0
            else:
                mapping[inputs[j][i]] = 6
        digits = int("".join([str(mapping[item]) for item in outputs[j]]))
        sum_digits += digits

    print(sum_digits)

main()</code></pre>
</div>
</div>
<a id="day09" />
</div>
</div>
<div class="sect2">
<h3 id="_day_09_python"><a class="anchor" href="#_day_09_python"></a><a class="link" href="#_day_09_python">Day 09: python</a></h3>
<div class="paragraph">
<p>Day 9 of year 2021
<a href="https://adventofcode.com/2021/day/9" class="bare">https://adventofcode.com/2021/day/9</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_9"><a class="anchor" href="#_what_i_learned_9"></a><a class="link" href="#_what_i_learned_9">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I got the recursion right the first time. (Nothing that I learned, but it&#8217;s probably the first time ever for me.)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_9"><a class="anchor" href="#_approach_9"></a><a class="link" href="#_approach_9">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and create a list of lists with all of the integers (e.g. a matrix)</p>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I take each integer from the matrix and check if its 4 neighbors are all bigger than it.</p>
</li>
<li>
<p>If yes, it&#8217;s a lowest point and its location gets added to a list as a tuple.</p>
</li>
<li>
<p>And I go ahead and sum up the risk within this loop as well.</p>
</li>
<li>
<p>The messy part is taking care that you aren&#8217;t in the first or last column or first or last row.</p>
</li>
<li>
<p>In those cases, you only check 3 neighbors (or 2 if its one of the 4 corners)</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>It seemed to be a clear case for a recursive function.</p>
</li>
<li>
<p>I take each of the lowest points and create a "basin" set with the lowest point in it.</p>
</li>
<li>
<p>Then I call a function that checks all 4 directions from that point out. If the value found is not 9 and the point is not yet in the set, add it to the set and recursively call the function with that point.</p>
</li>
<li>
<p>Again, the messy part is making sure that you are not at any of the edges.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_9"><a class="anchor" href="#_run_script_9"></a><a class="link" href="#_run_script_9">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    floor_plan = [[int(i) for i in list(line)] for line in lines_stripped]

    return floor_plan

def extend_basin(point,map_floor,basin):
    if point[0] != 0:
        if map_floor[point[0]-1][point[1]] != 9:
            if (point[0]-1,point[1]) not in basin:
                basin.add((point[0]-1,point[1]))
                basin = extend_basin((point[0]-1,point[1]),map_floor,basin)
    if point[0] != len(map_floor)-1:
        if map_floor[point[0]+1][point[1]] != 9:
            if (point[0]+1,point[1]) not in basin:
                basin.add((point[0]+1,point[1]))
                basin = extend_basin((point[0]+1,point[1]),map_floor,basin)
    if point[1] != 0:
        if map_floor[point[0]][point[1]-1] != 9:
            if (point[0],point[1]-1) not in basin:
                basin.add((point[0],point[1]-1))
                basin = extend_basin((point[0],point[1]-1),map_floor,basin)
    if point[1] != len(map_floor[0])-1:
        if map_floor[point[0]][point[1]+1] != 9:
            if (point[0],point[1]+1) not in basin:
                basin.add((point[0],point[1]+1))
                basin = extend_basin((point[0],point[1]+1),map_floor,basin)

    return basin

def main():
    with open("input.txt",'r') as floor_file:
        floor_lines = floor_file.readlines()

    map_floor = process_input(floor_lines)

    #star 1
    low_points = []
    sum_risk = 0
    for i in range(len(map_floor)):
        for j in range(len(map_floor[i])):
            if i == 0:
                if j == 0:
                    if map_floor[i][j]&lt;map_floor[i][j+1] and map_floor[i][j]&lt;map_floor[i+1][j]:
                        sum_risk += 1+map_floor[i][j]
                        low_points.append((i,j))
                elif j == len(map_floor[i])-1:
                    if map_floor[i][j]&lt;map_floor[i][j-1] and map_floor[i][j]&lt;map_floor[i+1][j]:
                        sum_risk += 1+map_floor[i][j]
                        low_points.append((i,j))
                elif map_floor[i][j]&lt;map_floor[i][j+1] and map_floor[i][j]&lt;map_floor[i+1][j] and map_floor[i][j]&lt;map_floor[i][j-1]:
                    sum_risk += 1+map_floor[i][j]
                    low_points.append((i,j))
            elif i == len(map_floor)-1:
                if j == 0:
                    if map_floor[i][j]&lt;map_floor[i][j+1] and map_floor[i][j]&lt;map_floor[i-1][j]:
                        sum_risk += 1+map_floor[i][j]
                        low_points.append((i,j))
                elif j == len(map_floor[i])-1:
                    if map_floor[i][j]&lt;map_floor[i][j-1] and map_floor[i][j]&lt;map_floor[i-1][j]:
                        sum_risk += 1+map_floor[i][j]
                        low_points.append((i,j))
                elif map_floor[i][j]&lt;map_floor[i][j+1] and map_floor[i][j]&lt;map_floor[i-1][j] and map_floor[i][j]&lt;map_floor[i][j-1]:
                    sum_risk += 1+map_floor[i][j]
                    low_points.append((i,j))
            elif j == 0:
                if map_floor[i][j]&lt;map_floor[i][j+1] and map_floor[i][j]&lt;map_floor[i+1][j] and map_floor[i][j]&lt;map_floor[i-1][j]:
                    sum_risk += 1+map_floor[i][j]
                    low_points.append((i,j))
            elif j == len(map_floor[i])-1:
                if map_floor[i][j]&lt;map_floor[i][j-1] and map_floor[i][j]&lt;map_floor[i-1][j] and map_floor[i][j]&lt;map_floor[i+1][j]:
                    sum_risk += 1+map_floor[i][j]
                    low_points.append((i,j))
            elif map_floor[i][j]&lt;map_floor[i][j+1] and map_floor[i][j]&lt;map_floor[i+1][j] and map_floor[i][j]&lt;map_floor[i-1][j] and map_floor[i][j]&lt;map_floor[i][j-1]:
                    sum_risk += 1+map_floor[i][j]
                    low_points.append((i,j))

    print(sum_risk)

    #star 2
    size_basin = []
    for i in low_points:
        basin = set()
        basin.add(i)
        basin = extend_basin(i,map_floor,basin)
        size_basin.append(len(basin))
    size_basin.sort(reverse=True)

    print(size_basin[0]*size_basin[1]*size_basin[2])

main()</code></pre>
</div>
</div>
<a id="day10" />
</div>
</div>
<div class="sect2">
<h3 id="_day_10_python"><a class="anchor" href="#_day_10_python"></a><a class="link" href="#_day_10_python">Day 10: python</a></h3>
<div class="paragraph">
<p>Day 10 of year 2021
<a href="https://adventofcode.com/2021/day/10" class="bare">https://adventofcode.com/2021/day/10</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_10"><a class="anchor" href="#_what_i_learned_10"></a><a class="link" href="#_what_i_learned_10">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Another day of recursion with only minor mishaps.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_10"><a class="anchor" href="#_approach_10"></a><a class="link" href="#_approach_10">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and strip the carriage returns from the lines. I leave the lines as strings.</p>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I created 2 functions. One to check the status of the line in total and one to check if 2 characters match.</p>
</li>
<li>
<p>For each of the lines, I call the check line function.</p>
</li>
<li>
<p>It checks the first 2 digits in the line against each other.</p>
</li>
<li>
<p>The matcher function checks if they "match" (one closes the other) or if they are both "openers" or if they are a mismatch.</p>
</li>
<li>
<p>In the case of a mismatch, we have a corruption and done.</p>
</li>
<li>
<p>If we have 2 openers, we check the second opener against the rest of the string with a recursive call of the line checker function.</p>
</li>
<li>
<p>If we have a match, we remove the match and continue / return.</p>
</li>
<li>
<p>When that&#8217;s all done, you add up the error value according to the formula for the corrupted entries.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I only needed minor additions / modifications.</p>
</li>
<li>
<p>You now keep a stack of the openers and for the incomplete lines, you know what has to be closed at the end.</p>
</li>
<li>
<p>Then you just reverse the order, use the formula, sort and find the middle value.</p>
</li>
<li>
<p>After doing star 2, I think I could simplify the whole thing since the whole recursion is just pushing and popping stuff from a stack&#8230;&#8203;</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_10"><a class="anchor" href="#_run_script_10"></a><a class="link" href="#_run_script_10">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    return lines_stripped

def check_line(navicode,opener,stack):
    status = ""
    corruptor = ""
    while len(navicode) &gt; 1 and len(status)==0:
        navicode = navicode[1:]
        status = check_match(opener,navicode[0])
        if status == "corrupt":
            return navicode, "corrupt", navicode[0],stack
        elif status == "match":
            if len(stack[:-1])&gt;0:
                return navicode, "", "", stack[:-1]
            else:
                stack = stack[:-1]
                status = ""
        else:
            stack += status
            (navicode,status,corruptor,stack) = check_line(navicode,navicode[0],stack)

    return navicode, status, corruptor, stack

def check_match(opener,candidate):
    if candidate in ["(","[","&lt;","{"]:
        status = candidate
    else:
        if opener == "(":
            if candidate == ")":
                status = "match"
            else:
                status = "corrupt"
        elif opener == "[":
            if candidate == "]":
                status = "match"
            else:
                status = "corrupt"
        elif opener == "{":
            if candidate == "}":
                status = "match"
            else:
                status = "corrupt"
        else:
            if candidate == "&gt;":
                status = "match"
            else:
                status = "corrupt"

    return status

def main():
    with open("input.txt",'r') as navi_file:
        navi_lines = navi_file.readlines()

    navigation = process_input(navi_lines)

    #star 1
    syntax_error = 0
    incompletes = []
    for navi in navigation:
        (navicode,status,corruptor,stack) = check_line(navi,navi[0],navi[0])
        if status == "corrupt":
            if corruptor == ")":
                syntax_error += 3
            elif corruptor == "]":
                syntax_error += 57
            elif corruptor == "}":
                syntax_error += 1197
            else:
                syntax_error += 25137
        else:
            incompletes.append(stack)

    print(syntax_error)

    #star 2
    scores = []
    for incomplete in incompletes:
        score = 0
        for closer in incomplete[::-1]:
            score *= 5
            if closer == "(":
                score += 1
            elif closer == "[":
                score += 2
            elif closer == "{":
                score += 3
            else:
                score += 4
        scores.append(score)

    scores.sort()
    print(scores[(len(scores)-1)//2])

main()</code></pre>
</div>
</div>
<a id="day11" />
</div>
</div>
<div class="sect2">
<h3 id="_day_11_python"><a class="anchor" href="#_day_11_python"></a><a class="link" href="#_day_11_python">Day 11: python</a></h3>
<div class="paragraph">
<p>Day 11 of year 2021
<a href="https://adventofcode.com/2021/day/11" class="bare">https://adventofcode.com/2021/day/11</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_11"><a class="anchor" href="#_what_i_learned_11"></a><a class="link" href="#_what_i_learned_11">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Brushed up on modula arithmetic.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_11"><a class="anchor" href="#_approach_11"></a><a class="link" href="#_approach_11">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and strip the carriage returns from the lines.</p>
</li>
<li>
<p>I put everything into a single flat list of integers.</p>
</li>
<li>
<p>I created a function to do one step and used it for both stars.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Basically, I just use a set for the indexes of octopuses that flash.</p>
</li>
<li>
<p>I add one to the octopuses and see if anything flashes.</p>
</li>
<li>
<p>If so, I add those indexes to the set.</p>
</li>
<li>
<p>I then start a loop.</p>
</li>
<li>
<p>And then I add one to their neighbors (lots of code to check the edges) and check if any of them are more than 9 <strong>and</strong> not already flashed.</p>
</li>
<li>
<p>Repeat until no new flashes occur. Return the new state and the number of flashes that occured.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Do 100 steps and add up the flashes.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Loop until all Octopuses are 0.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_11"><a class="anchor" href="#_run_script_11"></a><a class="link" href="#_run_script_11">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    octos = [int(i) for lines in lines_stripped for i in lines]

    return octos

def iterate_octos(flashes,octos):
    flashed = set()
    flashed_temp = flashed.copy()
    octos = [octo + 1 for octo in octos]
    if any([octo == 10 for octo in octos]):
        flash_locations = [i for i, e in enumerate(octos) if e &gt;9]
        flashed_temp.update(flash_locations)
    while flashed != flashed_temp:
        for octo in flashed_temp-flashed:
            if octo &gt; 9:
                octos[octo-10] += 1
                if octo % 10 != 0:
                    octos[octo-11] += 1
                if (octo+1) % 10 != 0:
                    octos[octo-9] += 1
            if octo &lt; 90:
                octos[octo+10] += 1
                if octo % 10 != 0:
                    octos[octo+9] += 1
                if (octo+1) % 10 != 0:
                    octos[octo+11] += 1
            if octo % 10 != 0:
                octos[octo-1] +=1
            if (octo+1) % 10 != 0:
                    octos[octo+1] += 1
        flashed = flashed_temp.copy()
        if any([octo &gt; 9 for octo in octos]):
            flash_locations = [i for i, e in enumerate(octos) if e &gt;9]
            flashed_temp.update(flash_locations)

    flashes += sum([1 if octo&gt;9 else 0 for octo in octos])
    octos = [octo if octo &lt;10 else 0 for octo in octos]

    return flashes,octos

def main():
    with open("input.txt",'r') as octo_file:
        octo_lines = octo_file.readlines()

    octos = process_input(octo_lines)
    octos_temp = octos.copy()
    flashes = 0

    #star 1
    for i in range(100):
        flashes,octos = iterate_octos(flashes,octos)

    print(flashes)

    #star 2
    count = 0
    octos = octos_temp
    while octos != [0]*100:
        flashes,octos = iterate_octos(flashes,octos)
        count += 1

    print(count)

main()</code></pre>
</div>
</div>
<a id="day12" />
</div>
</div>
<div class="sect2">
<h3 id="_day_12_python"><a class="anchor" href="#_day_12_python"></a><a class="link" href="#_day_12_python">Day 12: python</a></h3>
<div class="paragraph">
<p>Day 12 of year 2021
<a href="https://adventofcode.com/2021/day/12" class="bare">https://adventofcode.com/2021/day/12</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_12"><a class="anchor" href="#_what_i_learned_12"></a><a class="link" href="#_what_i_learned_12">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I read up on first depth search.</p>
</li>
<li>
<p>I also understood better what happens when you pass a list to a function in Python.</p>
</li>
<li>
<p>Overall, this was the first day this year that gave me bigger headaches, but I think the solution is pretty ok. :-)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_12"><a class="anchor" href="#_approach_12"></a><a class="link" href="#_approach_12">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and create a dictionary with the vertices as keys. The values are sets containing all adjacent vertices.</p>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I do a modified first depth search. I implemented it recursively.</p>
</li>
<li>
<p>The difference to a more standard first depth search is that I don&#8217;t note the nodes I&#8217;ve visited but rather only keep track of any lower case vertex that I&#8217;ve visited.</p>
</li>
<li>
<p>I tried with first breadth search, but somehow I got my head around first depth search easier.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>You just have to modify the way you handle "doubles".</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>You note "start" and "end" as soon you reach them.</p>
</li>
<li>
<p>You note any lower case vertex <strong>if</strong> your list of doubles already has at least 3 elements.</p>
</li>
<li>
<p>You note any lower case vertex <strong>if</strong> it already occurred in the path.</p>
</li>
</ol>
</div>
</li>
<li>
<p>You need some extra logic in the loop for the child vertices to avoid visiting more than one lower case vertex twice.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_12"><a class="anchor" href="#_run_script_12"></a><a class="link" href="#_run_script_12">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    paths_dict = {}
    for line in lines_stripped:
        vertices = line.split("-")
        if vertices[0] in paths_dict:
            temp = paths_dict[vertices[0]]
            temp.add(vertices[1])
            paths_dict[vertices[0]] = temp
        else:
            paths_dict[vertices[0]] = {vertices[1]}
        if vertices[1] in paths_dict:
            temp = paths_dict[vertices[1]]
            temp.add(vertices[0])
            paths_dict[vertices[1]] = temp
        else:
            paths_dict[vertices[1]] = {vertices[0]}

    return paths_dict

def traverse_graph_star1(paths,start,end,path,doubles,found_paths):
    path.append(start)
    if start[0]&gt;"Z":
        doubles.add(start)
    if start == end:
        found_paths.append(path.copy())
    else:
        for child in paths[start].difference(doubles):
            traverse_graph_star1(paths,child,end,path,doubles,found_paths)
    path.pop()
    if start[0]&gt;"Z":
        doubles.remove(start)

    return

def traverse_graph_star2(paths,start,end,path,doubles,found_paths):
    flag = 0
    if start=="end" or start=="start":
        doubles.add(start)
        flag = 1
    elif start[0]&gt;"Z" and len(doubles)&gt;2:
        doubles.add(start)
        flag = 1
    elif start[0]&gt;"Z" and start in path:
        doubles.add(start)
        flag = 1
    path.append(start)
    if start == end:
        found_paths.append(path.copy())
    else:
        for child in paths[start].difference(doubles):
            if len(doubles)&lt;2 or child[0]&lt;"a" or child not in path:
                traverse_graph_star2(paths,child,end,path,doubles,found_paths)
    path.pop()

    if flag == 1:
        doubles.remove(start)

    return

def main():
    with open("input.txt",'r') as paths_file:
        path_lines = paths_file.readlines()

    paths = process_input(path_lines)

    #star 1
    start = "start"
    end = "end"
    path = []
    doubles = set()
    found_paths = []

    traverse_graph_star1(paths,start,end,path,doubles,found_paths)

    print(len(found_paths))

    #star 2
    path = []
    doubles = set()
    found_paths = []

    traverse_graph_star2(paths,start,end,path,doubles,found_paths)

    print(len(found_paths))

main()</code></pre>
</div>
</div>
<a id="day13" />
</div>
</div>
<div class="sect2">
<h3 id="_day_13_python"><a class="anchor" href="#_day_13_python"></a><a class="link" href="#_day_13_python">Day 13: python</a></h3>
<div class="paragraph">
<p>Day 13 of year 2021
<a href="https://adventofcode.com/2021/day/13" class="bare">https://adventofcode.com/2021/day/13</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_13"><a class="anchor" href="#_what_i_learned_13"></a><a class="link" href="#_what_i_learned_13">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>This one was actually straightforward</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_13"><a class="anchor" href="#_approach_13"></a><a class="link" href="#_approach_13">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and create a list with all instrucions and a set with all coordinates.</p>
</li>
<li>
<p>Both Stars</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I look at each coordinate and compare it to the cutting line.</p>
</li>
<li>
<p>If it&#8217;s above or to the left of the line (depending on vertical or horizontal cutting line), I put the coordinate into the new set.</p>
</li>
<li>
<p>If it&#8217;s not, I mirror it to the right spot and put it into the set.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Do the first instruction and find the length of the resulting set.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Do all of the instructions.</p>
</li>
<li>
<p>Print the coordinates in a grid. (# for present, . for absent). Read the letters in the ASCII graphic.</p>
</li>
<li>
<p>I didn&#8217;t right a parser to read the 8 letters, but did it manually. :-)</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_13"><a class="anchor" href="#_run_script_13"></a><a class="link" href="#_run_script_13">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    i = 0
    coordinates = set()
    instructions = []
    while lines_stripped[i]:
        coord = lines_stripped[i].split(",")
        coordinates.add((int(coord[0]),int(coord[1])))
        i += 1

    i += 1
    while i &lt; len(lines_stripped):
        parts = lines_stripped[i].split()
        instructions.append((parts[2][0],int(parts[2][2:])))
        i += 1

    return (coordinates,instructions)

def main():
    with open("input.txt",'r') as paper_file:
        paper_lines = paper_file.readlines()

    (coordinates,instructions) = process_input(paper_lines)

    # star 1
    folded_coordinates = set()
    for coord in coordinates:
        if instructions[0][0] == 'y':
            if coord[1]&lt;instructions[0][1]:
                folded_coordinates.add(coord)
            else:
                folded_coordinates.add((coord[0],2*instructions[0][1]-coord[1]))
        else:
            if coord[0]&lt;instructions[0][1]:
                folded_coordinates.add(coord)
            else:
                folded_coordinates.add((2*instructions[0][1]-coord[0],coord[1]))

    print(len(folded_coordinates))

    # star 2
    for inst in instructions:
        folded_coordinates = set()
        for coord in coordinates:
            if inst[0] == 'y':
                if coord[1]&lt;inst[1]:
                    folded_coordinates.add(coord)
                else:
                    folded_coordinates.add((coord[0],2*inst[1]-coord[1]))
            else:
                if coord[0]&lt;inst[1]:
                    folded_coordinates.add(coord)
                else:
                    folded_coordinates.add((2*inst[1]-coord[0],coord[1]))
        coordinates = folded_coordinates

    max_x = max(set([coordinate[0] for coordinate in coordinates]))
    max_y = max(set([coordinate[1] for coordinate in coordinates]))

    for y in range(max_y+1):
        for x in range(max_x+1):
            if (x,y) in coordinates:
                print("#",end='')
            else:
                print(".",end='')
        print()

main()</code></pre>
</div>
</div>
<a id="day14" />
</div>
</div>
<div class="sect2">
<h3 id="_day_14_python"><a class="anchor" href="#_day_14_python"></a><a class="link" href="#_day_14_python">Day 14: python</a></h3>
<div class="paragraph">
<p>Day 14 of year 2021
<a href="https://adventofcode.com/2021/day/14" class="bare">https://adventofcode.com/2021/day/14</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_14"><a class="anchor" href="#_what_i_learned_14"></a><a class="link" href="#_what_i_learned_14">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I practiced with linked lists, but you can&#8217;t see that here since it only works for star 1.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_14"><a class="anchor" href="#_approach_14"></a><a class="link" href="#_approach_14">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and create</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>A list containing the initial pairs of letters.</p>
</li>
<li>
<p>A dictionary with the letter pairs as key and the values are the two new letter pairs created by the letter insertion.</p>
</li>
<li>
<p>A set containing all of the valid letter pairs.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Both Stars</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I initially solved star 1 with a linked list and brute force. That works fine for up to about 20 iterations, but then you get into major trouble.</p>
</li>
<li>
<p>So, after some thought, I noticed that there are a finite number of letter pairs that can occur. Each of these letter pairs breeds exactly two pairs of letters in the next step. So, you just have to keep track of how many of each pairs you have and you know how many of each pair you have in the next step.</p>
</li>
<li>
<p>Then, you just have to do some math to turn the number of pairs in the final line into the number of corresponding letters.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_14"><a class="anchor" href="#_run_script_14"></a><a class="link" href="#_run_script_14">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    all_combos = set()
    breed = {}
    for i in range(2,len(lines_stripped)):
        (key,value) = lines_stripped[i].split(" -&gt; ")
        breed[key] = (key[0]+value,value+key[1])
        all_combos.update(breed[key])

    initial_seed = []
    for i in range(len(lines_stripped[0])-1):
        initial_seed.append(lines_stripped[0][i]+lines_stripped[0][i+1])
        all_combos.add(lines_stripped[0][i]+lines_stripped[0][i+1])

    all_combos = list(all_combos)

    return initial_seed, breed, all_combos

def main():
    with open("input.txt",'r') as poly_file:
        poly_lines = poly_file.readlines()

    (initial_seed, breed, all_combos) = process_input(poly_lines)

    all_letters = list(set([item for sublist in all_combos for item in sublist]))

    count_pairs = [0]*len(all_combos)

    for seed in initial_seed:
        count_pairs[all_combos.index(seed)] += 1

    for j in range(40): # replace with 10 for star 1
        count_pairs_temp = [0]*len(all_combos)
        for i,pair in enumerate(all_combos):
            new_pairs = breed[pair]
            count_pairs_temp[all_combos.index(new_pairs[0])] += count_pairs[i]
            count_pairs_temp[all_combos.index(new_pairs[1])] += count_pairs[i]
        count_pairs = count_pairs_temp

    count_letters = [0]*len(all_letters)
    for i,letter in enumerate(all_letters):
        for j,combo in enumerate(all_combos):
            for letter1 in combo:
                if letter == letter1:
                    count_letters[i] += count_pairs[j]

    count_fix = []
    for i,count in enumerate(count_letters):
        if all_letters[i] == initial_seed[0][0] or all_letters[i] == initial_seed[-1][1]:
            count_fix.append((count+1)//2)
        else:
            count_fix.append(count//2)

    print(max(count_fix)-min(count_fix))

main()</code></pre>
</div>
</div>
<a id="day15" />
</div>
</div>
<div class="sect2">
<h3 id="_day_15_python"><a class="anchor" href="#_day_15_python"></a><a class="link" href="#_day_15_python">Day 15: python</a></h3>
<div class="paragraph">
<p>Day 15 of year 2021
<a href="https://adventofcode.com/2021/day/15" class="bare">https://adventofcode.com/2021/day/15</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_15"><a class="anchor" href="#_what_i_learned_15"></a><a class="link" href="#_what_i_learned_15">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I understood Dijsktra&#8217;s algorithm.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_15"><a class="anchor" href="#_approach_15"></a><a class="link" href="#_approach_15">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I parse the file and create a list containing each node of the graph.</p>
</li>
<li>
<p>For each node, I hold it&#8217;s index, risk, distance to start, neighbors and parent.</p>
</li>
<li>
<p>Initially, the distance is "Inf" and the parent is 0 (as a placeholder).</p>
</li>
<li>
<p>It turns out that I didn&#8217;t need the parent, but you never know what Star2 might bring&#8230;&#8203;</p>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I implemented Dijkstra&#8217;s algorithm to find the shortest path.</p>
</li>
<li>
<p>The distance is already computed, so the answer is then readily available.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I decided to re-read the data in and create the bigger grid from scratch.</p>
</li>
<li>
<p>The distance calculation is principally the same. My first implementation was not efficient enough. After 20 minutes without an answer, I decided to improve it.</p>
</li>
<li>
<p>The key seems to be that I now have 2 sets. One for the visited nodes and one for the nodes with a non-Inf value that are not visited yet. It seems to have massively speeded up the search for the next node. (Finding min distance and the corresponding node is much faster this way).</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_15"><a class="anchor" href="#_run_script_15"></a><a class="link" href="#_run_script_15">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def return_first(elem):
    return elem[0]

def process_input_star1(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    nodes = list()
    line_length = len(lines_stripped[0])
    for i,line in enumerate(lines_stripped):
        for j,risk in enumerate(line):
            adjacent = set()
            index = i*line_length+j
            if i != 0:
                adjacent.add(index-line_length)
            if i != line_length-1:
                adjacent.add(index+line_length)
            if index % line_length != 0:
                adjacent.add(index-1)
            if (index+1) % (line_length) != 0:
                adjacent.add(index+1)
            if index == 0:
                distance = 0
            else:
                distance = float('Inf')
            nodes.append([index,int(risk),distance,adjacent,0])

    return nodes

def process_input_star2(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    nodes = list()
    line_length = len(lines_stripped[0])
    for k in range(5):
        for i,line in enumerate(lines_stripped):
            for m in range(5):
                for j,risk in enumerate(line):
                    adjacent = set()
                    index = (i+m*line_length)*line_length*5+j+k*line_length
                    risk = int(risk)+m+k
                    if risk &gt; 9:
                        risk = risk - 9
                    if index &gt; line_length*5-1:
                        adjacent.add(index-line_length*5)
                    if index &lt; line_length*5*line_length*5-line_length*5:
                        adjacent.add(index+line_length*5)
                    if index % (5*line_length) != 0:
                        adjacent.add(index-1)
                    if (index+1) % (5*line_length) != 0:
                        adjacent.add(index+1)
                    if index == 0:
                        distance = 0
                    else:
                        distance = float('Inf')
                    nodes.append([index,risk,distance,adjacent,0])

    nodes.sort(key=return_first)

    return nodes

def find_shortest_path(nodes):
    visited = set()
    current_node = 0
    valued = {current_node}
    while current_node != len(nodes)-1:
        neighbors = nodes[current_node][3]
        valued.update(neighbors-visited)
        for neighbor in neighbors:
            if neighbor not in visited:
                if nodes[neighbor][2] &gt; nodes[current_node][2]+nodes[neighbor][1]:
                    nodes[neighbor][2] = nodes[current_node][2]+nodes[neighbor][1]
                    nodes[neighbor][4] = current_node

        visited.add(current_node)
        valued.remove(current_node)
        min_distance = min([nodes[node][2] for node in valued])

        for node in valued:
            if nodes[node][2] == min_distance:
                current_node = node

    risk = nodes[current_node][2]

    return risk


def main():
    with open("input.txt",'r') as chiton_file:
        chiton_lines = chiton_file.readlines()

    #star 1
    nodes = process_input_star1(chiton_lines)

    risk = find_shortest_path(nodes)

    print(risk)

    #star 2
    nodes = process_input_star2(chiton_lines)

    risk = find_shortest_path(nodes)

    print(risk)


main()</code></pre>
</div>
</div>
<a id="day16" />
</div>
</div>
<div class="sect2">
<h3 id="_day_16_python"><a class="anchor" href="#_day_16_python"></a><a class="link" href="#_day_16_python">Day 16: python</a></h3>
<div class="paragraph">
<p>Day 16 of year 2021
<a href="https://adventofcode.com/2021/day/16" class="bare">https://adventofcode.com/2021/day/16</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_16"><a class="anchor" href="#_what_i_learned_16"></a><a class="link" href="#_what_i_learned_16">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hex and Bin manipulation in Python</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_16"><a class="anchor" href="#_approach_16"></a><a class="link" href="#_approach_16">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I take the line from the file and turn it in to a binary string.</p>
</li>
<li>
<p>To decode the transmission and find the sums and the versions, you basically just follow the instructions.</p>
</li>
<li>
<p>Honestly, it&#8217;s mostly just reading the requirements closely and not creating any unnecessary bugs in the code.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_16"><a class="anchor" href="#_run_script_16"></a><a class="link" href="#_run_script_16">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">def hex_to_binary(hex_num, num_digits):

    return str(bin(int(hex_num, 16)))[2:].zfill(num_digits)

def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    return hex_to_binary(lines_stripped[0],len(lines_stripped[0])*4)

def do_type_code(type_code,value,v,flag):
    if type_code == 0:
        value += v
    elif type_code == 1:
        if flag == 0:
            value = v
            flag = 1
        else:
            value *= v
    elif type_code == 2:
        if flag == 0:
            value = v
            flag = 1
        else:
            value = min(value,v)
    elif type_code == 3:
        if flag == 0:
            value = v
            flag = 1
        else:
            value = max(value,v)
    elif type_code == 5:
        if flag == 0:
            value = v
            flag = 1
        elif value &gt; v:
            value = 1
        else:
            value = 0
    elif type_code == 6:
        if flag == 0:
            value = v
            flag = 1
        elif value &lt; v:
            value = 1
        else:
            value = 0
    elif type_code == 7:
        if flag == 0:
            value = v
            flag = 1
        elif value == v:
            value = 1
        else:
            value = 0

    return value,flag

def decode_transmission(code,versions):
    value = 0
    versions.append(int(code[0:3],2))
    type_code = int(code[3:6],2)
    length = 6

    if type_code == 4:
        bits = ""
        while int(code[length])!=0:
            bits += code[length+1:length+5]
            length += 5
        bits += code[length+1:length+5]
        length += 5

        value = int(bits,2)
    else:
        flag = 0
        if int(code[length])==0:
            length += 1
            subpacket_length = int(code[length:length+15],2)
            length += 15
            length_temp = length + subpacket_length

            while length &lt; length_temp:
                (x,v) = decode_transmission(code[length:],versions)
                length += x
                value,flag = do_type_code(type_code,value,v,flag)

        else:
            length += 1
            no_subpackets = int(code[length:length+11],2)
            length += 11
            for i in range(no_subpackets):
                (x,v) = decode_transmission(code[length:], versions)
                length += x
                value,flag = do_type_code(type_code,value,v,flag)

    return length, value

def main():
    with open("input.txt",'r') as hex_file:
        hex_lines = hex_file.readlines()

    bin_num = process_input(hex_lines)

    versions = list()
    length, value = decode_transmission(bin_num,versions)
    print(sum(versions))

    print(value)

main()</code></pre>
</div>
</div>
<a id="day17" />
</div>
</div>
<div class="sect2">
<h3 id="_day_17_python"><a class="anchor" href="#_day_17_python"></a><a class="link" href="#_day_17_python">Day 17: python</a></h3>
<div class="paragraph">
<p>Day 17 of year 2021
<a href="https://adventofcode.com/2021/day/17" class="bare">https://adventofcode.com/2021/day/17</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_17"><a class="anchor" href="#_what_i_learned_17"></a><a class="link" href="#_what_i_learned_17">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Some basic math. :-)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_17"><a class="anchor" href="#_approach_17"></a><a class="link" href="#_approach_17">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I take the line from the file and use a regex to extract the 4 numbers and put them into a list.</p>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>This is just math. If the probe goes up with a certain velocity, it is guaranteed to come back down through and exactly hit zero.</p>
</li>
<li>
<p>The velocity when it hits zero will be negative and its magnitude is the initial velocity + 1.</p>
</li>
<li>
<p>So, the max velocity is the absolute value of the bottom edge of the target area minus 1. And the maximum height is then also clear.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Maybe there is a cool math solution, but I didn&#8217;t find it, so I just brute force this by trying all theoretically possible initial velocity combinations and playing it through for each.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_17"><a class="anchor" href="#_run_script_17"></a><a class="link" href="#_run_script_17">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">import regex as re

def process_input(file_contents):
    input_regex = re.compile('(-?\d+)')
    area = re.findall(input_regex,file_contents[0])
    area = [int(i) for i in area]

    return area

def landed(x,y,area):

    pos1 = 0
    pos2 = 0
    hit = 0
    while pos1 &lt; area[1]+1 and pos2 &gt; area[2]-1:
        pos1 += x
        pos2 += y
        if pos1 in list(range(area[0],area[1]+1)) and pos2 in list(range(area[2],area[3]+1)):
            hit=1
        if x != 0:
            x -= abs(x)//x
        y -= 1

    return hit

def main():
    with open("input.txt",'r') as trajectory_file:
        trajectory_lines = trajectory_file.readlines()

    area = process_input(trajectory_lines)
    # star 1
    print(max(-1*area[2],-1*area[3])*(max(-1*area[2],-1*area[3])-1)//2)

    hits = 0
    for x in range(1,area[1]+1):
        for y in range(area[2],-1*area[2]-1+1):
            hits += landed(x,y,area)
    print(hits)

main()</code></pre>
</div>
</div>
<a id="day18" />
</div>
</div>
<div class="sect2">
<h3 id="_day_18_python"><a class="anchor" href="#_day_18_python"></a><a class="link" href="#_day_18_python">Day 18: python</a></h3>
<div class="paragraph">
<p>Day 18 of year 2021
<a href="https://adventofcode.com/2021/day/18" class="bare">https://adventofcode.com/2021/day/18</a></p>
</div>
<div class="sect3">
<h4 id="_what_i_learned_18"><a class="anchor" href="#_what_i_learned_18"></a><a class="link" href="#_what_i_learned_18">What I learned</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Working with match objects from regex</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_approach_18"><a class="anchor" href="#_approach_18"></a><a class="link" href="#_approach_18">Approach</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I just read in the lines and strip them and put them into a list.</p>
</li>
<li>
<p>Star 1</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>After some thought, I didn&#8217;t have any better idea than to leave everything as a string and parse it.</p>
</li>
<li>
<p>I setup a loop that stops if neither condition is met.</p>
</li>
<li>
<p>For explode
&#8230;&#8203;I regex to find the pairs that could explode. And then count up the [ to the left (subtracting closers if any).</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>If more than 4, then it explodes. I scan through to see if there are any numbers to the left or right and do the addition and substition.</p>
</li>
</ol>
</div>
</li>
<li>
<p>For split</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>It&#8217;s actually easy. I just check for any double digits and do the substition.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Star 2</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>I use the same code as before and just run 2 nested loops and keep the max magnitude while running through.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_run_script_18"><a class="anchor" href="#_run_script_18"></a><a class="link" href="#_run_script_18">Run script</a></h4>
<div class="paragraph">
<p>Run the solution with <code>python solution.py</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-python" data-lang="python">import regex as re
import math

def process_input(file_contents):
    lines_stripped = [line.strip() for line in file_contents]

    return lines_stripped

def explode(snail):
    for m in re.finditer("(\d+),(\d+)", snail):
        parenths = 0
        for character in snail[:m.start()]:
            if character == "[":
                parenths += 1
            elif character == "]":
                parenths -= 1
        if parenths &gt; 4:
            cl = ""
            cr = ""
            for i, character in enumerate(snail[0:m.start()]):
                if character.isnumeric():
                    cl = character
                    il = i
                    if snail[i-1].isnumeric():
                        cl = snail[i-1]+cl
            for i, character in enumerate(snail[m.end():]):
                if character.isnumeric():
                    cr = character
                    ir = i
                    if snail[m.end()+i+1].isnumeric():
                        cr = cr + snail[m.end()+i+1]
                    break

            if bool(cr):
                snail = snail[:m.end()+ir]+str(int(cr)+int(m.group(2)))+snail[m.end()+ir+len(cr):]
            snail = snail[:m.start()-1]+"0"+snail[m.end()+1:]
            if bool(cl):
                snail = snail[:il-len(cl)+1]+str(int(cl)+int(m.group(1)))+snail[il+1:]

            break

    return snail

def split(snail):
    pattern = re.compile("\d\d")
    m = pattern.search(snail)
    if m:
        num_to_split = int(m.group(0))
        left = math.floor(int(num_to_split)/2)
        right = math.ceil(int(num_to_split)/2)
        snail = snail[:m.start()]+"["+str(left)+","+str(right)+"]"+snail[m.end():]

    return snail

def main():
    with open("input.txt",'r') as snail_file:
        snail_lines = snail_file.readlines()

    snails = process_input(snail_lines)

    # star 1
    snail = snails[0]
    for snail_temp in snails[1:]:
        snail = "["+snail+","+snail_temp+"]"
        snail_temp = ""
        while snail_temp != snail:
            snail_temp = snail
            snail = explode(snail)
            if snail == snail_temp:
                snail = split(snail)

    pattern = re.compile("\[(\d+),(\d+)\]")
    while not snail.isnumeric():
        m = pattern.search(snail)
        snail = snail[:m.start()]+str(int(m.group(1))*3+int(m.group(2))*2)+snail[m.end():]

    print(snail)

    # star 2
    max_mag = 0
    for snail1 in snails:
        for snail2 in snails:
            snail = "["+snail1+","+snail2+"]"
            snail_temp = ""
            while snail_temp != snail:
                snail_temp = snail
                snail = explode(snail)
                if snail == snail_temp:
                    snail = split(snail)
            pattern = re.compile("\[(\d+),(\d+)\]")
            while not snail.isnumeric():
                m = pattern.search(snail)
                snail = snail[:m.start()]+str(int(m.group(1))*3+int(m.group(2))*2)+snail[m.end():]
            max_mag = max(max_mag,int(snail))

    print(max_mag)
main()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2021 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>