<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2021: mr-kaffee</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2021/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2021/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2021.netlify.app/","doctoolchain.org/aoc-2021/");
          }
      </script>
<!-- /aoc-2021/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2021//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2021//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2021//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2021//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2021//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2021</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:aoc-2021.netlify.com">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_mr_kaffee">mr-kaffee</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_rust">Day 00: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world">Day 00: Hello World</a>
<ul class="sectlevel4">
<li><a href="#_general_structure">General structure</a></li>
<li><a href="#_run_solutions">Run Solutions</a></li>
<li><a href="#_personal_challenges">Personal Challenges</a></li>
<li><a href="#_run_all_solutions">Run all Solutions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_00_ruby">Day 00: ruby</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world_2">Day 00: Hello World</a>
<ul class="sectlevel4">
<li><a href="#_solution">Solution</a></li>
<li><a href="#_test">Test</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_01_sonar_sweep">Day 01: Sonar Sweep</a>
<ul class="sectlevel4">
<li><a href="#_part_1">Part 1</a></li>
<li><a href="#_part_2">Part 2</a></li>
<li><a href="#_today_i_learned">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_02_dive">Day 02: Dive!</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2">Part 1</a></li>
<li><a href="#_part_2_2">Part 2</a></li>
<li><a href="#_today_i_learned_2">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_ruby">Day 02: ruby</a>
<ul class="sectlevel3">
<li><a href="#_day_02_dive_2">Day 02: Dive!</a>
<ul class="sectlevel4">
<li><a href="#_part_1_3">Part 1</a></li>
<li><a href="#_part_2_3">Part 2</a></li>
<li><a href="#_tests">Tests</a></li>
<li><a href="#_today_i_learned_3">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_03_binary_diagnostic">Day 03: Binary Diagnostic</a>
<ul class="sectlevel4">
<li><a href="#_part_1_4">Part 1</a></li>
<li><a href="#_part_2_4">Part 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_04_giant_squid">Day 04: Giant Squid</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2_2">Part 1 &amp; 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_05_hydrothermal_venture">Day 05: Hydrothermal Venture</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2_3">Part 1 &amp; 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
<li><a href="#_today_i_learned_4">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_06_lanternfish">Day 06: Lanternfish</a>
<ul class="sectlevel4">
<li><a href="#_parts_1_2">Parts 1 &amp; 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
<li><a href="#_some_more_thoughts">Some more thoughts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_07_the_treachery_of_whales">Day 07: The Treachery of Whales</a>
<ul class="sectlevel4">
<li><a href="#_part_1_5">Part 1</a></li>
<li><a href="#_part_2_5">Part 2</a></li>
<li><a href="#_solution_revisited">Solution Revisited</a></li>
<li><a href="#_tests_6">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_rust">Day 08: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_08_seven_segment_search">Day 08: Seven Segment Search</a>
<ul class="sectlevel4">
<li><a href="#_part_1_6">Part 1</a></li>
<li><a href="#_part_2_6">Part 2</a></li>
<li><a href="#_tests_7">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_rust">Day 09: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_09_smoke_basin">Day 09: Smoke Basin</a>
<ul class="sectlevel4">
<li><a href="#_part_1_7">Part 1</a></li>
<li><a href="#_part_2_7">Part 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
<li><a href="#_today_i_learned_5">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_rust">Day 10: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a>
<ul class="sectlevel4">
<li><a href="#_part_1_8">Part 1</a></li>
<li><a href="#_part_2_8">Part 2</a></li>
<li><a href="#_tests_9">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_rust">Day 11: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a>
<ul class="sectlevel4">
<li><a href="#_part_1_9">Part 1</a></li>
<li><a href="#_part_2_9">Part 2</a></li>
<li><a href="#_tests_10">Tests</a></li>
<li><a href="#_today_i_learned_6">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_12_rust">Day 12: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_12_passage_pathing">Day 12: Passage Pathing</a>
<ul class="sectlevel4">
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_tests_11">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_13_rust">Day 13: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_13_transparent_origami">Day 13: Transparent Origami</a>
<ul class="sectlevel4">
<li><a href="#_part_1_10">Part 1</a></li>
<li><a href="#_part_2_10">Part 2</a></li>
<li><a href="#_tests_12">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_14_rust">Day 14: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_14_extended_polymerization">Day 14: Extended Polymerization</a>
<ul class="sectlevel4">
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_tests_13">Tests</a></li>
<li><a href="#_today_i_learned_7">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_15_rust">Day 15: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_15_chiton">Day 15: Chiton</a>
<ul class="sectlevel4">
<li><a href="#_solution_4">Solution</a></li>
<li><a href="#_tests_14">Tests</a></li>
<li><a href="#_today_i_learned_8">Today I Learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_16_rust">Day 16: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_16_packet_decoder">Day 16: Packet Decoder</a>
<ul class="sectlevel4">
<li><a href="#_part_1_11">Part 1</a></li>
<li><a href="#_part_2_11">Part 2</a></li>
<li><a href="#_tests_15">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_17_rust">Day 17: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_17_trick_shot">Day 17: Trick Shot</a>
<ul class="sectlevel4">
<li><a href="#_part_1_12">Part 1</a></li>
<li><a href="#_part_2_12">Part 2</a></li>
<li><a href="#_tests_16">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_18_rust">Day 18: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_18_snailfish">Day 18: Snailfish</a>
<ul class="sectlevel4">
<li><a href="#_part_1_13">Part 1</a></li>
<li><a href="#_part_2_13">Part 2</a></li>
<li><a href="#_tests_17">Tests</a></li>
<li><a href="#_thoughts">Thoughts</a></li>
<li><a href="#_today_i_learned_9">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_19_rust">Day 19: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_19_beacon_scanner">Day 19: Beacon Scanner</a>
<ul class="sectlevel4">
<li><a href="#_parts_1_2_2">Parts 1 &amp; 2</a></li>
<li><a href="#_tests_18">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_20_rust">Day 20: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_20_trench_map">Day 20: Trench Map</a>
<ul class="sectlevel4">
<li><a href="#_parts_1_2_3">Parts 1 &amp; 2</a></li>
<li><a href="#_tests_19">Tests</a></li>
<li><a href="#day20-til">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_21_rust">Day 21: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_21_dirac_dice">Day 21: Dirac Dice</a>
<ul class="sectlevel4">
<li><a href="#_part_1_14">Part 1</a></li>
<li><a href="#_part_2_14">Part 2</a></li>
<li><a href="#_tests_20">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_22_rust">Day 22: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_22_reactor_reboot">Day 22: Reactor Reboot</a>
<ul class="sectlevel4">
<li><a href="#_solution_5">Solution</a></li>
<li><a href="#_cuboids_implementation">Cuboids Implementation</a></li>
<li><a href="#_tests_21">Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_mr_kaffee"><a class="anchor" href="#_mr_kaffee"></a><a class="link" href="#_mr_kaffee">mr-kaffee</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars0.githubusercontent.com/u/73745454?v=4" alt="73745454?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>mr-kaffee</strong><br>
Peter Wieland<br>
Github: <a href="https://github.com/mr-kaffee">mr-kaffee</a>,
Strava: <a href="https://www.strava.com/athletes/89256720">Peter Wieland</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a curious amateur coder (lots of Java, MATLAB, recently Rust), I like cycling on and off roads and much more &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><a href="https://www.zusammengegencorona.de/impfen/">Corona sucks - let&#8217;s stop it!</a></p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_rust"><a class="anchor" href="#_day_00_rust"></a><a class="link" href="#_day_00_rust">Day 00: rust</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world"><a class="anchor" href="#_day_00_hello_world"></a><a class="link" href="#_day_00_hello_world">Day 00: Hello World</a></h4>
<div class="paragraph">
<p>It&#8217;ll be another day of <a href="https://www.rust-lang.org/">Rust</a> solutions for the 2021 edition of
<a href="https://adventofcode.com/2021">Advent of Code</a></p>
</div>
<div class="sect4">
<h5 id="_general_structure"><a class="anchor" href="#_general_structure"></a><a class="link" href="#_general_structure">General structure</a></h5>
<div class="paragraph">
<p>Generally, my solutions will contain a <code>src/main.rs</code> file which reads the input from <code>input.txt</code>,
calls the solution functions and measures time.</p>
</div>
<div class="paragraph">
<p>The actual solution will be implemented in <code>src/lib.rs</code> file.</p>
</div>
<div class="paragraph">
<p>The <code>lib.rs</code> file also contains the tests in a separate submodule. I will use this for test-driven
development, e.g., based on the examples given in the puzzles.</p>
</div>
</div>
<div class="sect4">
<h5 id="_run_solutions"><a class="anchor" href="#_run_solutions"></a><a class="link" href="#_run_solutions">Run Solutions</a></h5>
<div class="paragraph">
<p>Run solution with <code>cargo run --release</code></p>
</div>
<div class="paragraph">
<p>Run tests with <code>cargo test</code> or <code>cargo test --release</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_personal_challenges"><a class="anchor" href="#_personal_challenges"></a><a class="link" href="#_personal_challenges">Personal Challenges</a></h5>
<div class="paragraph">
<p>It is December 21st in the meantime. I got that far trying to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keep the overall time for all solutions as small as possible (&lt; 500ms would be great)</p>
</li>
<li>
<p>Do not use anything but out of the box Rust</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s see whether I can keep up with these constraints until the end.</p>
</div>
</div>
<div class="sect4">
<h5 id="_run_all_solutions"><a class="anchor" href="#_run_all_solutions"></a><a class="link" href="#_run_all_solutions">Run all Solutions</a></h5>
<div class="paragraph">
<p>My <code>day00</code> solution this year will run all my solutions. The code looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">const DAYS: &amp;[fn()] = &amp;[
    day00::solve,
    day01::solve,
    day02::solve,
    day03::solve,
    day04::solve,
    day05::solve,
    day06::solve,
    day07::solve,
    day08::solve,
    day09::solve,
    day10::solve,
    day11::solve,
    day12::solve,
    day13::solve,
    day14::solve,
    day15::solve,
    day16::solve,
    day17::solve,
    day18::solve,
    day19::solve,
    day20::solve,
    day21::solve,
    day22::solve,
    day23::solve,
    day24::solve,
    day25::solve,
];

pub fn solve(indices: impl Iterator&lt;Item = usize&gt;) {
    let timer = Instant::now();

    let mut count = 0;
    for idx in indices {
        DAYS[idx]();
        count += 1;
    }

    let elapsed = timer.elapsed();
    println!(
        "Total time for {} days: {:?} ({:?} per day)",
        count,
        elapsed,
        elapsed.checked_div(count).unwrap()
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run all solutions, use <code>cargo run --release&#8201;&#8212;&#8201;from 1 --to 25</code>. The command line options <code>--from &lt;day&gt;</code> and <code>--to &lt;day&gt;</code> specify the range of days to run (bounds included). The default is to run all days from 1 to 25 (inclusive). If a day is not yet implemented, the program panics.</p>
</div>
<a id="day00" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_00_ruby"><a class="anchor" href="#_day_00_ruby"></a><a class="link" href="#_day_00_ruby">Day 00: ruby</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world_2"><a class="anchor" href="#_day_00_hello_world_2"></a><a class="link" href="#_day_00_hello_world_2">Day 00: Hello World</a></h4>
<div class="paragraph">
<p>Maybe I&#8217;ll try out some <a href="https://www.ruby-lang.org/">Ruby</a> this year. At least a hello world is done ;)</p>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>The actual solution resides in <code>solution.rb</code></p>
</div>
<div class="paragraph">
<p>It will define classes, methods and similar to calculate the solution, e.g.,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def say_hello(name = "World")
  "Hello, #{name}!"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>And a section to run the actual solution and measure time, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">if __FILE__ == $0
  b = Benchmark.measure { puts say_hello }
  puts "Solved in #{b.real}s"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The part <code>if <em>FILE</em> == $0</code> is taken from <a href="https://www.ruby-lang.org/en/documentation/quickstart/4/">Ruby in Twenty Minutes</a></p>
</div>
<div class="paragraph">
<p>The solution is executed with <code>ruby solution.rb</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_test"><a class="anchor" href="#_test"></a><a class="link" href="#_test">Test</a></h5>
<div class="paragraph">
<p>To test my code, there will be a <code>solution_test.rb</code> file which defines a test class derived from <code>Test::Unit::TestCase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">class TestSolution &lt; Test::Unit::TestCase
  def test_say_hello
    assert_equal "Hello, World!", say_hello
    assert_equal "Hello, Eric Wastl!", say_hello("Eric Wastl")
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tests are executed with <code>ruby solution_test.rb</code></p>
</div>
<a id="day01" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_01_sonar_sweep"><a class="anchor" href="#_day_01_sonar_sweep"></a><a class="link" href="#_day_01_sonar_sweep">Day 01: Sonar Sweep</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/1">AoC|2021|01</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1"><a class="anchor" href="#_part_1"></a><a class="link" href="#_part_1">Part 1</a></h5>
<div class="paragraph">
<p>Parse the input</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse each line into a number
pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    content
        .lines()
        .map(|line| line.parse().expect("Could not parse line"))
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And count how often consecutive inputs increase (test is part of documentation)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count how often consecutive numbers increase
///
/// # Examples
/// ```
/// let data: Vec&lt;usize&gt; = vec![199, 200, 208, 210, 200, 207, 240, 269, 260, 263];
/// assert_eq!(7, mr_kaffee_2021_01::count_increase(&amp;data));
/// ```
pub fn count_increase(data: &amp;[usize]) -&gt; usize {
    data.iter()
        .zip(data[1..].iter())
        .filter(|(a, b)| b &gt; a)
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2"><a class="anchor" href="#_part_2"></a><a class="link" href="#_part_2">Part 2</a></h5>
<div class="paragraph">
<p>Create sliding sums over three consecutive numbers (again with test as part of documentation)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// calculate sliding sums over three elements
///
/// # Examples
///
/// ```
/// let data: Vec&lt;usize&gt; = vec![199, 200, 208, 210, 200, 207, 240, 269, 260, 263];
/// let sums: Vec&lt;usize&gt; = vec![607, 618, 618, 617, 647, 716, 769, 792];
/// assert_eq!(sums, mr_kaffee_2021_01::sliding_sums(&amp;data));
/// ```
pub fn sliding_sums(data: &amp;[usize]) -&gt; Vec&lt;usize&gt; {
    data.iter()
        .zip(data[1..].iter())
        .zip(data[2..].iter())
        .map(|((a, b), c)| a + b + c)
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and use function <code>count_increase</code> from part 1 again</p>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned"><a class="anchor" href="#_today_i_learned"></a><a class="link" href="#_today_i_learned">Today I learned</a></h5>
<div class="paragraph">
<p>The <code>zip</code> function on iterators is useful.</p>
</div>
<div class="paragraph">
<p>Later, looking at other solutions, I felt stupid: Obviously <code><code>a[k] + a[k + 1] + a[k + 2] &lt; a[k + 1] + a[k + 2] + a[k + 3]</code></code>
if and only if <code><code>a[k] &lt; a[k + 3]</code></code> and thus there is no need at all to calculate the sliding sums for part 2.</p>
</div>
<div class="paragraph">
<p>This is a generic solution with <code><code>offset = 1</code></code> for part 1 and <code><code>offset = 3</code></code> for part 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count how often numbers with distance `offset` increase
///
/// # Examples
/// ```
/// let data: Vec&lt;usize&gt; = vec![199, 200, 208, 210, 200, 207, 240, 269, 260, 263];
/// assert_eq!(7, mr_kaffee_2021_01::count_increase_with_offset(&amp;data, 1));
/// assert_eq!(5, mr_kaffee_2021_01::count_increase_with_offset(&amp;data, 3));
/// ```
pub fn count_increase_with_offset(data: &amp;[usize], offset: usize) -&gt; usize {
    data.iter()
        .zip(data[offset..].iter())
        .filter(|(a, b)| b &gt; a)
        .count()
}</code></pre>
</div>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_02_dive"><a class="anchor" href="#_day_02_dive"></a><a class="link" href="#_day_02_dive">Day 02: Dive!</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/2">AoC|2021|02</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_2"><a class="anchor" href="#_part_1_2"></a><a class="link" href="#_part_1_2">Part 1</a></h5>
<div class="paragraph">
<p>The most difficult part today was to parse the input. My rust knowledge obviously is slightly rusty&#8230;&#8203;
Eventually I created an enum with a <code>parse</code> function as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Command {
    Up(isize),
    Down(isize),
    Forward(isize),
}

impl Command {
    /// parse command
    ///
    /// # Examples
    /// ```
    /// # use mr_kaffee_2021_02::*;
    /// assert_eq!(Command::Up(5), Command::parse("up 5"));
    /// assert_eq!(Command::Down(6), Command::parse("down 6"));
    /// assert_eq!(Command::Forward(-2), Command::parse("forward -2"));
    /// ```
    ///
    /// ```should_panic
    /// # use mr_kaffee_2021_02::*;
    /// // this will panic since the first part is not a valid command
    /// let cmd = Command::parse("invalid-command 7");
    /// ```
    ///
    /// ```should_panic
    /// # use mr_kaffee_2021_02::*;
    /// // this will panic since the two parts are not separated by a single blank
    /// let cmd = Command::parse("up\t7");
    /// ```
    ///
    /// ```should_panic
    /// # use mr_kaffee_2021_02::*;
    /// // this will panic since the second part is not a number
    /// let cmd = Command::parse("down not-a-number");
    /// ```
    pub fn parse(line: &amp;str) -&gt; Self {
        let (cmd, v) = line.split_once(' ').expect("Invalid line");
        let v = v.parse().expect("Could not parse value");
        match cmd {
            "up" =&gt; Command::Up(v),
            "down" =&gt; Command::Down(v),
            "forward" =&gt; Command::Forward(v),
            _ =&gt; panic!("Unexpected command"),
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution then is done with a simple fold operation on an iterator accumulating depth (y) and horizontal position (x)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Calculate positions
///
/// # Example
/// ```
/// # use mr_kaffee_2021_02::*;
/// assert_eq!((5, 0), calc_position("forward 5"));
/// assert_eq!((0, 5), calc_position("down 5"));
/// assert_eq!((3, -5), calc_position("up 5\nforward 3"));
/// assert_eq!((0, 0), calc_position(""));
/// ```
pub fn calc_position(input: &amp;str) -&gt; (isize, isize) {
    input
        .lines()
        .map(|line| Command::parse(line))
        .fold((0, 0), |(x, y), cmd| match cmd {
            Command::Up(v) =&gt; (x, y - v),
            Command::Down(v) =&gt; (x, y + v),
            Command::Forward(v) =&gt; (x + v, y),
        })
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_2"><a class="anchor" href="#_part_2_2"></a><a class="link" href="#_part_2_2">Part 2</a></h5>
<div class="paragraph">
<p>The second part was an easy extension to the first part. Just add a third accumulator state for the aim (small trap: my horizontal position is called 'x' which is not the same as the 'X' in the puzzle description)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Calculate positions with aim
///
/// # Example
/// ```
/// # use mr_kaffee_2021_02::*;
/// assert_eq!((5, 0, 0), calc_position_with_aim("forward 5"));
/// assert_eq!((5, 0, 5), calc_position_with_aim("forward 5\ndown 5"));
/// assert_eq!((13, 40, 5), calc_position_with_aim("forward 5\ndown 5\nforward 8"));
/// ```
pub fn calc_position_with_aim(input: &amp;str) -&gt; (isize, isize, isize) {
    input
        .lines()
        .map(|line| Command::parse(line))
        .fold((0, 0, 0), |(x, y, aim), cmd| match cmd {
            Command::Up(v) =&gt; (x, y, aim - v),
            Command::Down(v) =&gt; (x, y, aim + v),
            Command::Forward(v) =&gt; (x + v, y + aim * v, aim),
        })
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_2"><a class="anchor" href="#_today_i_learned_2"></a><a class="link" href="#_today_i_learned_2">Today I learned</a></h5>
<div class="paragraph">
<p>Parsing simple inputs does not require regular expressions &amp; creating enums with parse functions leads to a bit more code but looks much prettier</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_ruby"><a class="anchor" href="#_day_02_ruby"></a><a class="link" href="#_day_02_ruby">Day 02: ruby</a></h3>
<div class="sect3">
<h4 id="_day_02_dive_2"><a class="anchor" href="#_day_02_dive_2"></a><a class="link" href="#_day_02_dive_2">Day 02: Dive!</a></h4>
<div class="paragraph">
<p><a href="https://www.ruby-lang.org">Ruby</a> solution to <a href="https://adventofcode.com/2021/day/2">AoC|2021|02</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_3"><a class="anchor" href="#_part_1_3"></a><a class="link" href="#_part_1_3">Part 1</a></h5>
<div class="paragraph">
<p>Generic function to calculate the position.
Takes the input string, an initial value and a hash of lambdas updating the position</p>
</div>
<div class="paragraph">
<p>The function iterates through the lines of the <code>input</code>. Each <code>line</code> is split in the command part <code>cmd</code> and the value part <code>v</code> (single space as separator). The command is used to select a lambda from the <code>steps</code> hash which is then called with the accumulator <code>acc</code> and the value <code>v</code> to udpate the accumulator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def calc_position(input, init, steps)
  input.split("\n")
       .map { |line| line.split(' ') }
       .inject(init) { |acc, cmd| steps[cmd.first].call acc, cmd.last.to_i }
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>For part 1, this function is called as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def calc_position_1(input)
  calc_position(input, [0, 0], {
    'up' =&gt; -&gt;(acc, v) { [acc[0], acc[1] - v] },
    'down' =&gt; -&gt;(acc, v) { [acc[0], acc[1] + v] },
    'forward' =&gt; -&gt;(acc, v) { [acc[0] + v, acc[1]] }
  })
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_3"><a class="anchor" href="#_part_2_3"></a><a class="link" href="#_part_2_3">Part 2</a></h5>
<div class="paragraph">
<p>For part 2, the aim has to be considered as additional value and the update rules are changed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def calc_position_2(input)
  calc_position(input, [0, 0, 0], {
    'up' =&gt; -&gt;(acc, v) { [acc[0], acc[1], acc[2] - v] },
    'down' =&gt; -&gt;(acc, v) { [acc[0], acc[1], acc[2] + v] },
    'forward' =&gt; -&gt;(acc, v) { [acc[0] + v, acc[1] + acc[2] * v, acc[2]] }
  })
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests"><a class="anchor" href="#_tests"></a><a class="link" href="#_tests">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">class TestSolution &lt; Test::Unit::TestCase
  CONTENT = %(forward 5
down 5
forward 8
up 3
down 8
forward 2).freeze

  def test_calc_position_1
    assert_equal [15, 10], calc_position_1(CONTENT)
  end

  def test_calc_position_2
    assert_equal [15, 60, 10], calc_position_2(CONTENT)
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_3"><a class="anchor" href="#_today_i_learned_3"></a><a class="link" href="#_today_i_learned_3">Today I learned</a></h5>
<div class="paragraph">
<p>... that I don&#8217;t know how to set up VS Code for decent Ruby development :(</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_03_binary_diagnostic"><a class="anchor" href="#_day_03_binary_diagnostic"></a><a class="link" href="#_day_03_binary_diagnostic">Day 03: Binary Diagnostic</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/3">AoC|2021|03</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_4"><a class="anchor" href="#_part_1_4"></a><a class="link" href="#_part_1_4">Part 1</a></h5>
<div class="paragraph">
<p>As always, first challenge is to parse the input. I decided to read the input into integers. That caused some headaches later on to get the bit ordering correct. After I realized that the line length in the example differs from the line length in the puzzle input, I also return the length from my parse function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse input into integers
/// return bit-length of values in addition
pub fn parse(input: &amp;str) -&gt; (Vec&lt;usize&gt;, usize) {
    let len = input.lines().next().expect("No lines").len();
    let values = input
        .lines()
        .map(|line| usize::from_str_radix(line, 2).expect("Could not parse line"))
        .collect();
    (values, len)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Part 1 is then solved with the help of a function that counts for every position, how often the bit is set in the input. Another function then calculates epsilon by setting all the bits in the positions where most of the input values have bits set and gamma as the inverse</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Count how often bits are set in the values.
///
/// returns vector of counts with first element indicating how often least significant
/// bit is set and last element indicating how often most significant bit is set
pub fn count_all_ones(values: &amp;[usize], len: usize) -&gt; Vec&lt;usize&gt; {
    values.iter().fold(vec![0; len], |counts, value| {
        counts
            .iter()
            .enumerate()
            .map(|(k, one)| *one + ((*value &gt;&gt; k) &amp; 1))
            .collect()
    })
}

/// calculate the gamma and epsilon values
///
/// gamma is the value of all the most common bits
/// epsilon is the value of all the least common bits
///
/// returns ``(gamma, epsilon, gamma * epsilon)``
pub fn calc_gamma_epsilon(values: &amp;[usize], len: usize) -&gt; (usize, usize, usize) {
    let counts = count_all_ones(values, len);
    let gamma = (0..len).fold(0, |gamma, bit| {
        gamma + (((2 * counts[bit] &gt;= values.len()) as usize) &lt;&lt; bit)
    });
    let epsilon = !gamma &amp; ((1 &lt;&lt; len) - 1);
    (gamma, epsilon, gamma * epsilon)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_4"><a class="anchor" href="#_part_2_4"></a><a class="link" href="#_part_2_4">Part 2</a></h5>
<div class="paragraph">
<p>As the puzzle states, part 2 is the trickier one.</p>
</div>
<div class="paragraph">
<p>I wrote a filter function to reduce the list of values step by step until only one is left. Whether oxygen or co2 ratings are calculated is controlled with a <code><code>invert</code></code> flag. The filter function uses a new <code>count_ones</code> function that only counts the specific bit we are interested in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Count how often specific bit is set in the values.
pub fn count_ones(values: &amp;[usize], bit: usize) -&gt; usize {
    values
        .iter()
        .fold(0, |count, value| count + ((value &gt;&gt; bit) &amp; 1))
}

/// filter out all the values whos given bit is not equal to the most common
/// bit in that position.
///
/// If invert is true, do the opposite and keep all the values whos given bit
/// is not equal to the most common bit in that position.
pub fn filter(values: Vec&lt;usize&gt;, bit: usize, invert: bool) -&gt; Vec&lt;usize&gt; {
    // determin expected value (xor with invert)
    let exp = ((2 * count_ones(&amp;values, bit) &gt;= values.len()) ^ invert) as usize;
    values
        .into_iter()
        .filter(|value| (*value &gt;&gt; bit) &amp; 1 == exp)
        .collect()
}

/// calc oxygen (``invert = false``) or co2 (``invert = true``) ratings
pub fn calc_rating(values: &amp;[usize], len: usize, invert: bool) -&gt; usize {
    let mut values = values.to_vec();
    let mut bit = Some(len - 1);
    while values.len() &gt; 1 &amp;&amp; bit.is_some() {
        values = filter(values, bit.unwrap(), invert);
        bit = match bit {
            Some(v) if v &gt; 0 =&gt; Some(v - 1),
            _ =&gt; None,
        };
    }
    *values.first().expect("No value left")
}

/// calc oxygen and co2 ratings
///
/// returns ``(oxygen, co2, oxygen * co2)``
pub fn calc_ratings(vals: &amp;[usize], len: usize) -&gt; (usize, usize, usize) {
    let oxygen = calc_rating(vals, len, false);
    let co2 = calc_rating(vals, len, true);
    (oxygen, co2, oxygen * co2)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_2"><a class="anchor" href="#_tests_2"></a><a class="link" href="#_tests_2">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010";

    const EXP_VALUES: &amp;'static [usize] = &amp;[
        0b00100, 0b11110, 0b10110, 0b10111, 0b10101, 0b01111, 0b00111, 0b11100, 0b10000, 0b11001,
        0b00010, 0b01010,
    ];

    const EXP_LEN: usize = 5;

    #[test]
    fn test_parse() {
        let (vals, len) = parse(CONTENT);
        assert_eq!(EXP_LEN, len);
        assert_eq!(EXP_VALUES, vals);
    }

    #[test]
    fn test_count_all_ones() {
        assert_eq!(vec![5, 7, 8, 5, 7], count_all_ones(EXP_VALUES, EXP_LEN));
    }

    #[test]
    fn test_calc_gamma_epsilon() {
        assert_eq!((22, 9, 22 * 9), calc_gamma_epsilon(EXP_VALUES, EXP_LEN));
    }

    #[test]
    fn test_filter() {
        let values = filter(EXP_VALUES.to_vec(), EXP_LEN - 1, false);
        assert_eq!(
            vec![0b11110, 0b10110, 0b10111, 0b10101, 0b11100, 0b10000, 0b11001],
            values
        );

        let values = filter(EXP_VALUES.to_vec(), EXP_LEN - 1, true);
        assert_eq!(vec![0b00100, 0b01111, 0b00111, 0b00010, 0b01010], values);
    }

    #[test]
    fn test_calc_rating() {
        let (values, len) = parse(CONTENT);
        assert_eq!(23, calc_rating(&amp;values, len, false));
        assert_eq!(10, calc_rating(&amp;values, len, true));
    }

    #[test]
    fn test_calc_ratings() {
        let (values, len) = parse(CONTENT);
        assert_eq!((23, 10, 230), calc_ratings(&amp;values, len));
    }
}</code></pre>
</div>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_04_giant_squid"><a class="anchor" href="#_day_04_giant_squid"></a><a class="link" href="#_day_04_giant_squid">Day 04: Giant Squid</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/4">AoC|2021|04</a>.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s play Bingo (I don&#8217;t remember when I last did&#8230;&#8203;)</p>
</div>
<div class="sect4">
<h5 id="_part_1_2_2"><a class="anchor" href="#_part_1_2_2"></a><a class="link" href="#_part_1_2_2">Part 1 &amp; 2</a></h5>
<div class="paragraph">
<p>After I solved part 1 today, there was very little to add for part 2. Hence, there is only one solution for both parts.</p>
</div>
<div class="paragraph">
<p>I created a <code>struct</code> for a bingo board with a function <code>new</code> to create new boards, <code>apply_draws</code> to apply draws until a row or a column is complete, and a function <code>get_score</code> to calculate the final score:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// structure for a bingo board with ``data`` containing numbers, ``marked`` containing
/// flags which numbers have been drawn, ``draws_count`` holding the count af draws
/// (including draws that did not match), ``last`` holding the last number drawn, and
/// ``bingo`` is a flag indicating whether the board has at least one row or column completely
/// marked
pub struct Board {
    data: Vec&lt;usize&gt;,
    marked: Vec&lt;bool&gt;,
    count: usize,
    last: Option&lt;usize&gt;,
    bingo: bool,
}

impl Board {
    /// dimension of the boad
    pub const N: usize = 5;

    /// create new board from data vector
    pub fn new(data: Vec&lt;usize&gt;) -&gt; Self {
        if data.len() != Self::N * Self::N {
            panic!("Illegal data length: {}", data.len());
        }
        Board {
            data,
            marked: vec![false; Self::N * Self::N],
            count: 0,
            last: None,
            bingo: false,
        }
    }

    /// apply draws to board, stops applying draws if a row or column is entirely marked
    pub fn apply_draws(&amp;mut self, draws: &amp;[usize]) {
        if self.bingo {
            return;
        }

        for draw in draws {
            self.count += 1;
            self.last = Some(*draw);
            if let Some((idx, _)) = self.data.iter().enumerate().find(|(_, v)| *v == draw) {
                self.marked[idx] = true;

                let x0 = idx % Self::N;
                let y0 = idx / Self::N;

                if (0..5).all(|x| self.marked[x + Self::N * y0])
                    || (0..5).all(|y| self.marked[x0 + Self::N * y])
                {
                    self.bingo = true;
                    return;
                }
            }
        }
    }

    /// get score (sum of numbers not marked multiplied by last number drawn)
    pub fn get_score(&amp;self) -&gt; usize {
        if !self.bingo {
            panic!("Board not solved.");
        }

        self.data
            .iter()
            .zip(self.marked.iter())
            .filter(|(_, marked)| !*marked)
            .map(|(v, _)| v)
            .sum::&lt;usize&gt;()
            * self.last.expect("No draws")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, I created a function which parses the input to a vector of boards and a vector of numbers drawn</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn parse(input: &amp;str) -&gt; (Vec&lt;Board&gt;, Vec&lt;usize&gt;) {
    let mut lines = input.lines();

    // parse drawn numbers
    let draws = lines
        .next()
        .expect("No draws")
        .split(',')
        .map(|part| part.parse().expect("Could not parse number"))
        .collect();

    // parse boards
    let mut boards = Vec::new();
    let mut data = Vec::with_capacity(Board::N * Board::N);
    loop {
        let (eof, line) = lines.next().map(|line| (false, line)).unwrap_or((true, ""));
        if line.trim().len() == 0 &amp;&amp; data.len() &gt; 0 {
            // block complete
            boards.push(Board::new(data));
            data = Vec::with_capacity(Board::N * Board::N);
        } else {
            // add data to block
            line.split_whitespace()
                .map(|v| v.parse().expect("Could not parse number"))
                .for_each(|v| data.push(v));
        }

        if eof {
            // no more lines
            return (boards, draws);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we are ready to play bingo. I play all the boards one by one and then look for the one which wins first and the one which wins last and return their scores</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// play bingo
///
/// returns scores of winning and loosing board
pub fn play&lt;'a&gt;(boards: &amp;'a mut [Board], draws: &amp;[usize]) -&gt; (usize, usize) {
    // boards that wins first and board that wins last with draw index
    let mut winner: Option&lt;&amp;Board&gt; = None;
    let mut looser: Option&lt;&amp;Board&gt; = None;
    for board in boards {
        board.apply_draws(&amp;draws);

        winner = winner
            .filter(|winner| board.count &gt;= winner.count)
            .or(Some(board));
        looser = looser
            .filter(|looser| board.count &lt;= looser.count)
            .or(Some(board));
    }

    // unwrap results
    (
        winner.expect("No winner").get_score(),
        looser.expect("No looser").get_score(),
    )
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_3"><a class="anchor" href="#_tests_3"></a><a class="link" href="#_tests_3">Tests</a></h5>
<div class="paragraph">
<p>I kind of did TDD ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1

22 13 17 11  0
 8  2 23  4 24
21  9 14 16  7
 6 10  3 18  5
 1 12 20 15 19

 3 15  0  2 22
 9 18 13 17  5
19  8  7 25 23
20 11 10 24  4
14 21 16 12  6

14 21 17 24  4
10 16 15  9 19
18  8 23 26 20
22 11 13  6  5
 2  0 12  3  7";

    const EXP_DRAWS: &amp;'static [usize] = &amp;[
        7, 4, 9, 5, 11, 17, 23, 2, 0, 14, 21, 24, 10, 16, 13, 6, 15, 25, 12, 22, 18, 20, 8, 19, 3,
        26, 1,
    ];

    const DATA_0: &amp;'static [usize] = &amp;[
        22, 13, 17, 11, 0, 8, 2, 23, 4, 24, 21, 9, 14, 16, 7, 6, 10, 3, 18, 5, 1, 12, 20, 15, 19,
    ];

    #[test]
    fn test_board_new() {
        let board = Board::new(DATA_0.to_owned());
        assert_eq!(DATA_0, board.data);
        assert_eq!(vec![false; Board::N * Board::N], board.marked);
        assert_eq!(false, board.bingo);
        assert_eq!(0, board.count);
        assert_eq!(None, board.last);
    }

    #[test]
    fn test_parse() {
        let (boards, draws) = parse(CONTENT);
        assert_eq!(EXP_DRAWS, draws);
        assert_eq!(3, boards.len());
        assert_eq!(DATA_0, boards[0].data);
    }

    #[test]
    #[should_panic]
    fn test_get_score_panics() {
        let (boards, _) = parse(CONTENT);
        // this fails since no bingo yet
        boards[0].get_score();
    }

    #[test]
    fn test_board_apply_draws() {
        let (mut boards, draws) = parse(CONTENT);

        // 15th number (24) wins for board at index 2
        boards[1].apply_draws(&amp;draws);
        assert_eq!(15, boards[1].count);
        assert_eq!(Some(13), boards[1].last);
        assert!(boards[1].bingo);

        // 12th number (13) wins for board at index 2
        boards[2].apply_draws(&amp;draws);
        assert_eq!(12, boards[2].count);
        assert_eq!(Some(24), boards[2].last);
        assert!(boards[2].bingo);
    }

    #[test]
    fn test_play() {
        let (mut boards, draws) = parse(CONTENT);
        assert_eq!((4512, 1924), play(&amp;mut boards, &amp;draws));
    }
}</code></pre>
</div>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_05_hydrothermal_venture"><a class="anchor" href="#_day_05_hydrothermal_venture"></a><a class="link" href="#_day_05_hydrothermal_venture">Day 05: Hydrothermal Venture</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/5">AoC|2021|05</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_2_3"><a class="anchor" href="#_part_1_2_3"></a><a class="link" href="#_part_1_2_3">Part 1 &amp; 2</a></h5>
<div class="paragraph">
<p>I played around a little bit how to best represent lines. Eventually, I decided to simply represent them as tuples <code><code>(x1, y1, x2, y2)</code></code>. When parsing the inputs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse lines ``"x1,y1 -&gt; x2,y2"`` to tuples ``(x1, y1, x2, y2)``
pub fn parse(content: &amp;str) -&gt; Vec&lt;(isize, isize, isize, isize)&gt; {
    content
        .lines()
        .map(|line| {
            let mut parts = line.split(" -&gt; ");
            let mut xy1 = parts.next().expect("No first point").split(',');
            let x1 = xy1
                .next()
                .expect("No x1")
                .parse()
                .expect("Could not parse x1");
            let y1 = xy1
                .next()
                .expect("No y1")
                .parse()
                .expect("Could not parse y1");
            let mut xy2 = parts.next().expect("NO second point").split(',');
            let x2 = xy2
                .next()
                .expect("No x2")
                .parse()
                .expect("Could not parse x2");
            let y2 = xy2
                .next()
                .expect("No y2")
                .parse()
                .expect("Could not parse y2");

            (x1, y1, x2, y2)
        })
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I initially decided to count vents in a flat list representing the relevant part of the ocean&#8217;s ground. To identify that relevant part, I have a function to determine the bounding box of all lines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get bounding box over lines
///
/// returns ``(x_min, y_min, x_max, y_max)`` so that all points ``(x, y)`` on
/// any line satisfy ``x_min &lt;= x &lt; x_max`` and ``y_min &lt;= y &lt; y_max``
pub fn get_bbox(lines: &amp;[(isize, isize, isize, isize)]) -&gt; (isize, isize, isize, isize) {
    lines.iter().fold(
        (isize::MAX, isize::MAX, isize::MIN, isize::MIN),
        |(x_min, y_min, x_max, y_max), (x1, y1, x2, y2)| {
            (
                cmp::min(cmp::min(x_min, *x1), *x2),
                cmp::min(cmp::min(y_min, *y1), *y2),
                cmp::max(cmp::max(x_max, *x1 + 1), *x2 + 1),
                cmp::max(cmp::max(y_max, *y1 + 1), *y2 + 1),
            )
        },
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Later on, I realized that a lot of other solutions used hash maps to keep the counters. So I wanted to try that as well and see the runtime impact. I made my solution generic using a trait <code>VentsCount</code> and implementing it for <code>HashMap</code> directly and for vectors using a struct <code>VecVentsCount</code> with a bit of extra information on the bounding box.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// to allow using the same code with counts stored in a vector or in a hash map, the interface is modeled as a trait
pub trait VentsCount {
    /// increment count at given coordinate
    fn increment(&amp;mut self, coord: (isize, isize));
    /// count number of coordinates with count &gt; 1
    fn count_dangerous(&amp;self) -&gt; usize;
}

impl VentsCount for HashMap&lt;(isize, isize), usize&gt; {
    fn increment(&amp;mut self, coord: (isize, isize)) {
        // get entry, create and initialize with value 0 if not yet present
        let count = self.entry(coord).or_insert(0);
        // increment
        *count += 1;
    }

    fn count_dangerous(&amp;self) -&gt; usize {
        self.values().filter(|count| **count &gt; 1).count()
    }
}

/// structure to count vents based on a vector
pub struct VecVentsCount {
    counts: Vec&lt;usize&gt;,
    width: isize,
    x_min: isize,
    y_min: isize,
}

impl VecVentsCount {
    /// create new ``VecVentsCount`` for bounding box
    pub fn new((x_min, y_min, x_max, y_max): (isize, isize, isize, isize)) -&gt; Self {
        let width = x_max - x_min;
        let counts = vec![0usize; (width * (y_max - y_min)) as usize];
        VecVentsCount {
            counts,
            width,
            x_min,
            y_min,
        }
    }
}

impl VentsCount for VecVentsCount {
    fn increment(&amp;mut self, (x, y): (isize, isize)) {
        self.counts[(x - self.x_min + self.width * (y - self.y_min)) as usize] += 1;
    }

    fn count_dangerous(&amp;self) -&gt; usize {
        self.counts.iter().filter(|count| **count &gt; 1).count()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is then build by iterating over all lines and for each line iterating over all points it contains and increment a counter for the coordinate of that point. Then count all coordinates which belong to more than one line (have counter value greater than 1).</p>
</div>
<div class="paragraph">
<p>To iterate over the points, I calculate deltas <code>dx</code> and <code>dy</code> that define the difference in the x and y coordinate from one point to the next. They can be one of 0, 1, or -1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// this function uses the struct [VecVentsCount] by default. This behavior can be changed to using ``HashMap`` based
/// counting using the feature ``hash_counters``
pub fn count_overlaps(lines: &amp;[(isize, isize, isize, isize)], incl_diagonal: bool) -&gt; usize {
    let mut counts: Box&lt;dyn VentsCount&gt; = if cfg!(feature = "hash_counters") {
        Box::new(HashMap::new())
    } else {
        Box::new(VecVentsCount::new(get_bbox(lines)))
    };

    for (x1, y1, x2, y2) in lines {
        if incl_diagonal || x1 == x2 || y1 == y2 {
            let dx = match x1.cmp(&amp;x2) {
                Ordering::Equal =&gt; 0,
                Ordering::Greater =&gt; -1,
                Ordering::Less =&gt; 1,
            };
            let dy = match y1.cmp(&amp;y2) {
                Ordering::Equal =&gt; 0,
                Ordering::Greater =&gt; -1,
                Ordering::Less =&gt; 1,
            };
            let len = cmp::max((x2 - x1) * dx, (y2 - y1) * dy) + 1;
            for k in 0..len {
                counts.increment((x1 + k * dx, y1 + k * dy));
            }
        }
    }

    counts.count_dangerous()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whether or not to include diagonal lines is controlled with a flag <code><code>include_diagonal</code></code> which is set to <code><code>false</code></code> for part 1 and <code><code>true</code></code> for part 2.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tests_4"><a class="anchor" href="#_tests_4"></a><a class="link" href="#_tests_4">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "0,9 -&gt; 5,9
8,0 -&gt; 0,8
9,4 -&gt; 3,4
2,2 -&gt; 2,1
7,0 -&gt; 7,4
6,4 -&gt; 2,0
0,9 -&gt; 2,9
3,4 -&gt; 1,4
0,0 -&gt; 8,8
5,5 -&gt; 8,2";

    const LINES: &amp;'static [(isize, isize, isize, isize)] = &amp;[
        (0, 9, 5, 9),
        (8, 0, 0, 8),
        (9, 4, 3, 4),
        (2, 2, 2, 1),
        (7, 0, 7, 4),
        (6, 4, 2, 0),
        (0, 9, 2, 9),
        (3, 4, 1, 4),
        (0, 0, 8, 8),
        (5, 5, 8, 2),
    ];

    #[test]
    fn test_parse() {
        assert_eq!(LINES, parse(CONTENT));
    }

    #[test]
    fn test_get_bbox() {
        assert_eq!((0, 0, 10, 10), get_bbox(LINES));
    }

    #[test]
    fn test_count_overlaps_straight() {
        assert_eq!(5, count_overlaps(LINES, false));
    }

    #[test]
    fn test_count_overlaps() {
        assert_eq!(12, count_overlaps(LINES, true));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_4"><a class="anchor" href="#_today_i_learned_4"></a><a class="link" href="#_today_i_learned_4">Today I learned</a></h5>
<div class="paragraph">
<p>A range is empty, if the upper bound is less than the lower bound.</p>
</div>
<div class="paragraph">
<p>It is not easy to write functions in rust that return iterators, since the actual type of the iterator depends on how it is constructed. Implementing an iterator on your own is not always worth the effort.</p>
</div>
<div class="paragraph">
<p>Sometimes, it is a good idea to use signed types even if all the results are positive. This allows to deal with negative increments much more directly.</p>
</div>
<div class="paragraph">
<p>Hash map based counting may come with a runtime penalty. In today&#8217;s puzzle, vector based counting performs three to four times faster.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_06_lanternfish"><a class="anchor" href="#_day_06_lanternfish"></a><a class="link" href="#_day_06_lanternfish">Day 06: Lanternfish</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/6">AoC|2021|06</a>.</p>
</div>
<div class="sect4">
<h5 id="_parts_1_2"><a class="anchor" href="#_parts_1_2"></a><a class="link" href="#_parts_1_2">Parts 1 &amp; 2</a></h5>
<div class="paragraph">
<p>The key is to not keep a list of fishes but a list of timer values.</p>
</div>
<div class="paragraph">
<p>Parsing the input is done as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse fishes
///
/// returns an vector of the number of fishes per given timer value
///
/// ```
/// # use mr_kaffee_2021_06::*;
/// assert_eq!(vec![0, 1, 1, 2, 1, 0, 0, 0, 0], parse("3,4,3,1,2"));
/// ```
pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    let mut fishes = vec![0; 9];

    for age in content.trim().split(',') {
        fishes[age.parse::&lt;usize&gt;().expect("Could not parse fish")] += 1;
    }

    fishes
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simulations are done with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// simulate a given number of days
///
/// the timer values of all fishes are decreased by one. If the timer value is 0,
/// it is reset to 6 and the same amount of fishes with time value 8 is added.
pub fn simulate(mut fishes: Vec&lt;usize&gt;, days: usize) -&gt; Vec&lt;usize&gt; {
    for _ in 0..days {
        let new_fishes = fishes[0];
        for k in 1..fishes.len() {
            fishes[k - 1] = fishes[k];
        }
        fishes[6] += new_fishes;
        fishes[8] = new_fishes;
    }
    fishes
}

/// simulate given number of rounds and return sum
pub fn simulate_and_count(mut fishes: Vec&lt;usize&gt;, days: usize) -&gt; usize {
    fishes = simulate(fishes, days);
    fishes.iter().sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_5"><a class="anchor" href="#_tests_5"></a><a class="link" href="#_tests_5">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const DATA: &amp;'static [usize] = &amp;[0, 1, 1, 2, 1, 0, 0, 0, 0];

    #[test]
    fn test_simulate() {
        let mut fishes = DATA.to_vec();
        fishes = simulate(fishes, 1);
        assert_eq!(fishes, parse("2,3,2,0,1"));
        fishes = simulate(fishes, 1);
        assert_eq!(fishes, parse("1,2,1,6,0,8"));
        fishes = simulate(fishes, 1);
        assert_eq!(fishes, parse("0,1,0,5,6,7,8"));
    }

    #[test]
    fn test_simulate_and_count() {
        assert_eq!(5934, simulate_and_count(DATA.to_vec(), 80));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_some_more_thoughts"><a class="anchor" href="#_some_more_thoughts"></a><a class="link" href="#_some_more_thoughts">Some more thoughts</a></h5>
<div class="paragraph">
<p>I was thinking to create an explicit solution (in memory of my time at <a href="https://www.ist.uni-stuttgart.de/">University Stuttgart</a>). Fish growth is governed by the discrte time ODE</p>
</div>
<div class="literalblock">
<div class="content">
<pre>timers[k + 1] = A timers[k]
count[k] = C timers[k]</pre>
</div>
</div>
<div class="paragraph">
<p>with the matrices</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    | 0 1 0 0 0 0 0 0 0 |
    | 0 0 1 0 0 0 0 0 0 |
    | 0 0 0 1 0 0 0 0 0 |
    | 0 0 0 0 1 0 0 0 0 |
A = | 0 0 0 0 0 1 0 0 0 |
    | 0 0 0 0 0 0 1 0 0 |
    | 1 0 0 0 0 0 0 1 0 |
    | 0 0 0 0 0 0 0 0 1 |
    | 1 0 0 0 0 0 0 0 0 |</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>C = ( 1 1 1 1 1 1 1 1 1 )</pre>
</div>
</div>
<div class="paragraph">
<p>The characteristic equation of A is</p>
</div>
<div class="literalblock">
<div class="content">
<pre>z^9 - z^2 - 1 = 0</pre>
</div>
</div>
<div class="paragraph">
<p>which <a href="https://maxima.sourceforge.io/">Maxima</a> is not able to solve :( - so no explicit solution that I would be able to come up with</p>
</div>
<div class="paragraph">
<p>For a big number of rounds, it might be interesting to calculate powers of the above matrix using <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">exponentiation by squaring</a>, but for 256 rounds, a direct approach is certainly more efficient.</p>
</div>
<div class="paragraph">
<p>I might not have a direct soluton for an arbitrary number of rounds, but a direct solution for 80 and 256 rounds can still be given as</p>
</div>
<div class="literalblock">
<div class="content">
<pre>count[80] = ( 1421 1401 1191 1154 1034 950 905 779 768 ) * timers[0]
count[256] = ( 6703087164 6206821033 5617089148 5217223242 4726100874 4368232009 3989468462 3649885552 3369186778 ) * timers[0]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">const CA_80: &amp;'static [usize] = &amp;[1421, 1401, 1191, 1154, 1034, 950, 905, 779, 768];
const CA_256: &amp;'static [usize] = &amp;[
    6703087164, 6206821033, 5617089148, 5217223242, 4726100874, 4368232009, 3989468462, 3649885552,
    3369186778,
];

pub fn solve_direct(fishes: &amp;[usize], days: usize) -&gt; usize {
    fishes
        .iter()
        .zip(
            match days {
                80 =&gt; CA_80,
                256 =&gt; CA_256,
                _ =&gt; panic!("No direct solution for {} days", days),
            }
            .iter(),
        )
        .map(|(counter, factor)| counter * factor)
        .sum()
}

#[cfg(test)]
mod direct_solution_test {
    use super::*;

    const INPUT: &amp;str = "4,1,1,4,1,2,1,4,1,3,4,4,1,5,5,1,3,1,1,1,4,4,3,1,5,3,1,2,5,1,1,5,\
1,1,4,1,1,1,1,2,1,5,3,4,4,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,5,1,1,1,4,1,2,3,5,1,2,2,4,1,4,4,4,\
1,2,5,1,2,1,1,1,1,1,1,4,1,1,4,3,4,2,1,3,1,1,1,3,5,5,4,3,4,1,5,1,1,1,2,2,1,3,1,2,4,1,1,3,3,\
1,3,3,1,1,3,1,5,1,1,3,1,1,1,5,4,1,1,1,1,4,1,1,3,5,4,3,1,1,5,4,1,1,2,5,4,2,1,4,1,1,1,1,3,1,\
1,1,1,4,1,1,1,1,2,4,1,1,1,1,3,1,1,5,1,1,1,1,1,1,4,2,1,3,1,1,1,2,4,2,3,1,4,1,2,1,4,2,1,4,4,\
1,5,1,1,4,4,1,2,2,1,1,1,1,1,1,1,1,1,1,1,4,5,4,1,3,1,3,1,1,1,5,3,5,5,2,2,1,4,1,4,2,1,4,1,2,\
1,1,2,1,1,5,4,2,1,1,1,2,4,1,1,1,1,2,1,1,5,1,1,2,2,5,1,1,1,1,1,2,4,2,3,1,2,1,5,4,5,1,4";

    #[test]
    #[should_panic]
    fn test_direct_fails() {
        solve_direct(&amp;parse(INPUT), 56);
    }

    #[test]
    fn test_direct_80() {
        let fishes = parse(INPUT);
        let sol_direct = solve_direct(&amp;fishes, 80);
        let sol_classic = simulate_and_count(fishes, 80);
        assert_eq!(sol_classic, sol_direct);
    }

    #[test]
    fn test_direct_256() {
        let fishes = parse(INPUT);
        let sol_direct = solve_direct(&amp;fishes, 256);
        let sol_classic = simulate_and_count(fishes, 256);
        assert_eq!(sol_classic, sol_direct);
    }
}</code></pre>
</div>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_07_the_treachery_of_whales"><a class="anchor" href="#_day_07_the_treachery_of_whales"></a><a class="link" href="#_day_07_the_treachery_of_whales">Day 07: The Treachery of Whales</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/7">AoC|2021|07</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_5"><a class="anchor" href="#_part_1_5"></a><a class="link" href="#_part_1_5">Part 1</a></h5>
<div class="paragraph">
<p>Parse input into a vector of numbers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    content
        .trim()
        .split(',')
        .map(|v| v.parse().expect("Could not parse"))
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a function that calculates the fuel need for a given alignment position (after refactoring for part 2, this contains a cost function - mapping distance to cost - as argument; for part 1, this is just the identity)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn get_fuel(crabs: &amp;[usize], position: usize, cost: fn(usize) -&gt; usize) -&gt; usize {
    crabs
        .iter()
        .map(|crab| {
            cost(if crab &gt; &amp;position {
                crab - position
            } else {
                position - crab
            })
        })
        .sum()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I did not even think about anything more clever than linear search to solve the optimization problem.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// linear search optimization
pub fn get_optimal_positions_fuel(crabs: &amp;[usize], cost: fn(usize) -&gt; usize) -&gt; usize {
    let pos_min = *crabs.iter().min().expect("No min");
    let pos_max = *crabs.iter().max().expect("No max");
    (pos_min..=pos_max)
        .map(|position| get_fuel(crabs, position, cost))
        .min()
        .expect("No min")
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_5"><a class="anchor" href="#_part_2_5"></a><a class="link" href="#_part_2_5">Part 2</a></h5>
<div class="paragraph">
<p>For part two I just use a different cost function: <code>COST_LINEAR</code> solves part 1, <code>COST_INCREASING</code> solves part 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// cost function for part 1: identity
pub const COST_LINEAR: fn(usize) -&gt; usize = |distance| distance;

/// cost function for part 2: Euler formula for the sum 1 + ... + distance
pub const COST_INCREASING: fn(usize) -&gt; usize = |distance| distance * (distance + 1) / 2;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution_revisited"><a class="anchor" href="#_solution_revisited"></a><a class="link" href="#_solution_revisited">Solution Revisited</a></h5>
<div class="paragraph">
<p>I learned about <a href="https://gitlab.com/akoeltringer/advent_of_code/-/tree/main/y2021/d07">something more clever than linear search from a colleague</a>:</p>
</div>
<div class="paragraph">
<p>The solution to part 1 is the solution to the optimization problem <code>min_p sum_i |p - pos[i]|</code>. Since the cost function to minimize is V-shaped, the optimization is solved by the median.</p>
</div>
<div class="paragraph">
<p>The solution to part 2 is the solution to the optimization problem <code>min_p sum_i |p - pos[i]| (|p - pos[i]| + 1) / 2</code>. This is the same as <code>min_p (sum_i (p - pos[i])^2 / 2 + sum_i |p - pos[i]| / 2)</code>.</p>
</div>
<div class="paragraph">
<p>The solution to <code>min_p (sum_i (p - pos[i])^2 / 2</code> is given by the mean of the <code>p[i]</code> values, so I start from the mean and look in both directions to potentially find something better.</p>
</div>
<div class="paragraph">
<p>You can run the direct solution using <code>cargo run --release --features direct_solution</code>. Quite a bit faster than linear search ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// solution for part 1
///
/// default: linear search, see [get_optimal_positions_fuel] and [COST_LINEAR]
///
/// if feature ``direct_solution`` is selected, calculate median as solution, see [select]
pub fn solution_1(crabs: &amp;[usize]) -&gt; usize {
    if cfg!(feature = "direct_solution") {
        // calculate median and comput cost for median
        get_fuel(crabs, select(&amp;crabs, crabs.len() / 2), COST_LINEAR)
    } else {
        // linear search
        get_optimal_positions_fuel(crabs, COST_LINEAR)
    }
}

/// solution for part 1
///
/// default: linear search, see [get_optimal_positions_fuel] and [COST_INCREASING]
///
/// if feature ``direct_solution`` is selected, calculate mean and search for solution in neighborhood
pub fn solution_2(crabs: &amp;[usize]) -&gt; usize {
    if cfg!(feature = "direct_solution") {
        // calculate mean and cost for mean
        let mean = (crabs.iter().sum::&lt;usize&gt;() + crabs.len() - 1) / crabs.len();
        let mut cost = get_fuel(crabs, mean, COST_INCREASING);

        // search for improvements for increasing positions
        let mut delta = 1;
        loop {
            let cost_upd = get_fuel(crabs, mean + delta, COST_INCREASING);
            if cost_upd &gt;= cost {
                break;
            }

            cost = cost_upd;
            delta += 1;
        }

        // if no improvment found, search for improvements for decreasing positions
        if delta == 1 {
            loop {
                let cost_upd = get_fuel(crabs, mean - delta, COST_INCREASING);
                if cost_upd &gt;= cost {
                    break;
                }

                cost = cost_upd;
                delta += 1;
            }
        }

        cost
    } else {
        // linear search
        get_optimal_positions_fuel(crabs, COST_INCREASING)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The median is calculated recursively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Recursive calculation of k-th element.
///
/// # Examples
///
/// ```
/// # use mr_kaffee_2021_07::*;
/// let data = vec![1,4,7,12,8,13,101];
/// assert_eq!(8, select(&amp;data, data.len() / 2));
/// ```
pub fn select(data: &amp;[usize], k: usize) -&gt; usize {
    if k &gt;= data.len() {
        panic!(
            "Cannot get select rank {} of list of size {}",
            k,
            data.len()
        );
    }

    if data.len() == 1 {
        return data[0];
    }

    let pivot = data[0];

    let lows = data
        .into_iter()
        .filter(|d| d &lt; &amp;&amp;pivot)
        .map(|d| *d)
        .collect::&lt;Vec&lt;_&gt;&gt;();
    let pivots = data
        .into_iter()
        .filter(|d| d == &amp;&amp;pivot)
        .map(|d| *d)
        .collect::&lt;Vec&lt;_&gt;&gt;();
    let highs = data
        .into_iter()
        .filter(|d| d &gt; &amp;&amp;pivot)
        .map(|d| *d)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    return if k &lt; lows.len() {
        select(&amp;lows, k)
    } else if k &lt; lows.len() + pivots.len() {
        pivots[0]
    } else {
        select(&amp;highs, k - lows.len() - pivots.len())
    };
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_6"><a class="anchor" href="#_tests_6"></a><a class="link" href="#_tests_6">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "16,1,2,0,4,2,7,1,2,14";
    const DATA: &amp;'static [usize] = &amp;[16, 1, 2, 0, 4, 2, 7, 1, 2, 14];

    #[test]
    fn test_parse() {
        assert_eq!(DATA, parse(CONTENT));
    }

    #[test]
    fn test_get_fuel() {
        assert_eq!(37, get_fuel(DATA, 2, COST_LINEAR));
        assert_eq!(41, get_fuel(DATA, 1, COST_LINEAR));
        assert_eq!(39, get_fuel(DATA, 3, COST_LINEAR));
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(37, solution_1(DATA));
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(168, solution_2(DATA));
    }
}</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_rust"><a class="anchor" href="#_day_08_rust"></a><a class="link" href="#_day_08_rust">Day 08: rust</a></h3>
<div class="sect3">
<h4 id="_day_08_seven_segment_search"><a class="anchor" href="#_day_08_seven_segment_search"></a><a class="link" href="#_day_08_seven_segment_search">Day 08: Seven Segment Search</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/8">AoC|2021|08</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_6"><a class="anchor" href="#_part_1_6"></a><a class="link" href="#_part_1_6">Part 1</a></h5>
<div class="paragraph">
<p>For part 1, the most difficult part for me was to parse the input. In the current version, I parse the unique patterns and outputs to integers, where bits <code>0</code> to <code>6</code> correspond to wires <code>a</code> to <code>g</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// return a vector of tuples, each containing a vector of unique patterns and a vector of outputs
///
/// each pattern / output is represented by an integer whos bits indicate the state of segments a (bit 0) to g (bit 6)
pub fn parse(content: &amp;str) -&gt; Vec&lt;(Vec&lt;usize&gt;, Vec&lt;usize&gt;)&gt; {
    content
        .lines()
        .map(|line| {
            line.split(" | ") // separate patterns from outputs
                .map(|part| {
                    part.split_ascii_whitespace() // separate individual patterns
                        .map(|pattern| {
                            // convert pattern to usize
                            pattern
                                .chars()
                                .fold(0, |bits, c| bits | 1 &lt;&lt; (c as usize - 'a' as usize))
                        })
                        .collect::&lt;Vec&lt;_&gt;&gt;() // patterns / outputs as usize
                })
                .collect::&lt;VecDeque&lt;_&gt;&gt;() // VecDeque with one element for patterns and one for outputs
        })
        .map(|mut parts| (parts.pop_front().unwrap(), parts.pop_front().unwrap()))
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Counting the unique outputs is simple</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count unique ouput values (1 - 2 bits set, 7 - 3 bits set, 4 - 4 bits set, 8 - 7 bits set) in all outputs
pub fn solution_1(displays: &amp;[(Vec&lt;usize&gt;, Vec&lt;usize&gt;)]) -&gt; usize {
    displays
        .iter()
        .map(|(_, outputs)| {
            outputs
                .iter()
                .filter(|output| [2, 3, 4, 7].contains(&amp;output.count_ones()))
                .count()
        })
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_6"><a class="anchor" href="#_part_2_6"></a><a class="link" href="#_part_2_6">Part 2</a></h5>
<div class="paragraph">
<p>For part 2 I did not really have a good idea and tried around for a while. What I came up with is a map of wires to candidate segments. I iterate over all unique patterns and exclude candidate segments for each wire.</p>
</div>
<div class="paragraph">
<p>For patterns with 2, 3, or 4 wires, the 2, 3, or 4 corresponding segments are known.</p>
</div>
<div class="paragraph">
<p>For patterns with 5 or 6 wires, the unused wires correspond to one of 4 or 3 segments, respectively.</p>
</div>
<div class="paragraph">
<p>Once all patterns processed, the map is further reduced by removing segments which are the only candidate left for one wire from the candidates of all other wires.</p>
</div>
<div class="paragraph">
<p>That was enough in my case to end up with a unique mapping.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// sum over decoded outputs
pub fn solution_2(displays: &amp;[(Vec&lt;usize&gt;, Vec&lt;usize&gt;)]) -&gt; usize {
    let f = if cfg!(feature = "rjplog_solution") {
        // alternative decoder if feature "rjplog_solution" is chosen
        self::decode_alt
    } else {
        self::decode
    };

    displays
        .iter()
        .map(|(patterns, outputs)| f(patterns, outputs))
        .sum()
}

/// determine wiring by unique batterns and decode output
///
/// # Example
/// ```
/// # use mr_kaffee_2021_08::*;
/// let content =
///     "acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf";
/// let displays = parse(content);
/// let (patterns, outputs) = &amp;displays[0];
/// assert_eq!(5353, decode(patterns, outputs));
/// ```
pub fn decode(patterns: &amp;[usize], outputs: &amp;[usize]) -&gt; usize {
    // map is a vector of 7 integers, one for each segment
    // each row represents a wire in a display (a = 0 to g = 6).
    // Each bit in the entry represents a segment, the wire actually controls (a = 0 to g = 6)
    let mut map: Vec&lt;usize&gt; = vec![(1 &lt;&lt; 7) - 1; 7];

    // 1 -&gt; _ _ c _ _ f _ -&gt; set bits match 0b0100100
    // 7 -&gt; a _ c _ _ f _ -&gt; set bits match 0b0100101
    // 4 -&gt; _ b c d _ f _ -&gt; set bits match 0b0101110
    // 2 -&gt; a _ c d e _ g
    // 3 -&gt; a _ c d _ f g
    // 5 -&gt; a b _ d _ f g -&gt; unset bits match 0b0110110
    // 0 -&gt; a b c _ e f g
    // 6 -&gt; a b _ d e f g
    // 9 -&gt; a b c d _ f g -&gt; unset bits match 0b0011100
    let masks = HashMap::from([
        (2, (0b0100100, !0b0100100)),
        (3, (0b0100101, !0b0100101)),
        (4, (0b0101110, !0b0101110)),
        (5, (0b1111111, 0b0110110)),
        (6, (0b1111111, 0b0011100)),
    ]);

    // for each pattern, reduce map by impossible bits
    for pattern in patterns {
        if let Some((p, n)) = masks.get(&amp;pattern.count_ones()) {
            for wire in 0..7 {
                map[wire] &amp;= if (pattern &gt;&gt; wire) &amp; 1 == 1 { p } else { n };
            }
        }
    }

    // reduce map
    // if a row contains only one bit set, this bit is removed from every other row
    for wire_1 in 0..7 {
        if map[wire_1].count_ones() == 1 {
            for wire_2 in (0..7).filter(|wire_2| *wire_2 != wire_1) {
                map[wire_2] &amp;= !map[wire_1];
            }
        }
    }

    // determine digits and fold to output
    outputs
        .iter()
        .map(|output| {
            // map wires to segments
            (0..7)
                .filter(|wire| (output &gt;&gt; wire) &amp; 1 == 1)
                .fold(0, |digit, wire| digit | map[wire])
        })
        .fold(0, |result, digit| {
            // calculate output from digits
            10 * result
                + match digit {
                    // map digit patterns to decimal digit
                    0b1110111 =&gt; 0,
                    0b0100100 =&gt; 1,
                    0b1011101 =&gt; 2,
                    0b1101101 =&gt; 3,
                    0b0101110 =&gt; 4,
                    0b1101011 =&gt; 5,
                    0b1111011 =&gt; 6,
                    0b0100101 =&gt; 7,
                    0b1111111 =&gt; 8,
                    0b1101111 =&gt; 9,
                    _ =&gt; panic!("Invalid digit: {}", digit),
                }
        })
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_alternative_solution"><a class="anchor" href="#_alternative_solution"></a><a class="link" href="#_alternative_solution">Alternative Solution</a></h6>
<div class="paragraph">
<p>I looked at the solution by <a href="https://github.com/RJPlog">RJPlog</a> later, which is actually much simpler than mine. Here is a Rust version of his decode idea.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// decode output (solution idea by https://github.com/RJPlog[RJPlog])
///
/// # Example
/// ```
/// # use mr_kaffee_2021_08::*;
/// let content =
///     "acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf";
/// let displays = parse(content);
/// let (patterns, outputs) = &amp;displays[0];
/// assert_eq!(5353, decode(patterns, outputs));
/// ```
pub fn decode_alt(patterns: &amp;[usize], outputs: &amp;[usize]) -&gt; usize {
    let mut map: Vec&lt;usize&gt; = vec![0; 10];
    for pattern in patterns {
        // unique segment counts
        // 1 -&gt; _ _ c _ _ f _  2 segments
        // 7 -&gt; a _ c _ _ f _  3 segments
        // 4 -&gt; _ b c d _ f _  4 segments
        // 8 -&gt; a b c d e f g  7 segments
        match pattern.count_ones() {
            2 =&gt; map[1] = *pattern,
            3 =&gt; map[7] = *pattern,
            4 =&gt; map[4] = *pattern,
            7 =&gt; map[8] = *pattern,
            _ =&gt; {} // nothing here
        }
    }
    for pattern in patterns.iter().filter(|pattern| pattern.count_ones() == 5) {
        // 2 -&gt; a _ c d e _ g
        // 3 -&gt; a _ c d _ f g
        // 5 -&gt; a b _ d _ f g
        if pattern &amp; map[1] == map[1] {
            // c | f is only contained in segments for 3
            map[3] = *pattern;
        } else if pattern &amp; (map[4] &amp; !map[1]) == (map[4] &amp; !map[1]) {
            // b | c | d | f &amp; !(c | f) = b | d is only contained in segments for 5
            map[5] = *pattern;
        } else {
            // if it is neither 3 nor 5, it must be 2
            map[2] = *pattern;
        }
    }
    for pattern in patterns.iter().filter(|pattern| pattern.count_ones() == 6) {
        // 0 -&gt; a b c _ e f g
        // 6 -&gt; a b _ d e f g
        // 9 -&gt; a b c d _ f g
        if pattern &amp; map[3] == map[3] {
            // a | c | d | f | g is only contained in the segments for 9
            map[9] = *pattern;
        } else if pattern &amp; map[5] == map[5] {
            // a | b | d | f | g is contained in the segments for 9 (already handled) and 6
            map[6] = *pattern;
        } else {
            // if it is neither 9 nor 6, it must be 0
            map[0] = *pattern;
        }
    }

    outputs
        .iter()
        .map(|output| map.iter().position(|pattern| output == pattern).unwrap())
        .fold(0, |result, digit| 10 * result + digit)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the alternative solution with <code>cargo run --release --features rjplog_solution</code></p>
</div>
<div class="paragraph">
<p>Not only is this solution simpler but it also runs faster. With compiler optimizations turned on, my original part 2 solves in about 1ms, the alternative solution takes about 0.1ms.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_7"><a class="anchor" href="#_tests_7"></a><a class="link" href="#_tests_7">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str =
        "be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce";

    #[test]
    fn test_solution_1() {
        let displays = parse(CONTENT);
        assert_eq!(26, solution_1(&amp;displays));
    }

    #[test]
    fn test_solution_2() {
        let data = parse(CONTENT);
        let sol = solution_2(&amp;data);
        assert_eq!(61229, sol);
    }
}</code></pre>
</div>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_rust"><a class="anchor" href="#_day_09_rust"></a><a class="link" href="#_day_09_rust">Day 09: rust</a></h3>
<div class="sect3">
<h4 id="_day_09_smoke_basin"><a class="anchor" href="#_day_09_smoke_basin"></a><a class="link" href="#_day_09_smoke_basin">Day 09: Smoke Basin</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/9">AoC|2021|09</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_7"><a class="anchor" href="#_part_1_7"></a><a class="link" href="#_part_1_7">Part 1</a></h5>
<div class="paragraph">
<p>I parse the input into a flat list and return the width of the grid in addition</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get width of grid and numbers as flat vector
///
/// ```
/// # use mr_kaffee_2021_09::*;
/// assert_eq!((1, vec![0,1]), parse("0\n1"));
/// ```
pub fn parse(content: &amp;str) -&gt; (usize, Vec&lt;usize&gt;) {
    let w = content.lines().next().expect("No lines").len();
    let grid = content
        .chars()
        .filter(|c| c.is_ascii_digit())
        .map(|c| (c as usize - '0' as usize))
        .collect();
    (w, grid)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Part one is about finding the low points. This is quite straightforward.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// find all elements for which all adjacents have higher values, sum their values incremented by 1
pub fn solution_1(w: usize, grid: &amp;[usize]) -&gt; usize {
    (0..grid.len())
        .map(|idx| (idx % w, idx / w))
        .filter(|(x, y)| {
            (*x == 0 || grid[x - 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*x == w - 1 || grid[x + 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*y == 0 || grid[x + w * (y - 1)] &gt; grid[x + w * y])
                &amp;&amp; (*y == grid.len() / w - 1 || grid[x + w * (y + 1)] &gt; grid[x + w * y])
        })
        .fold(0, |sum, (x, y)| sum + grid[x + w * y] + 1)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_7"><a class="anchor" href="#_part_2_7"></a><a class="link" href="#_part_2_7">Part 2</a></h5>
<div class="paragraph">
<p>Finally a puzzle where a breadth-first-traversal could be used (there might be easier approaches&#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p><span class="line-through">I did not read the instructions well and thought that adjacent coordinates only belong to a basin if their value was heigher than the neighbor&#8217;s value. My tests helped me to sort that out and understand that I only have to look for coordinates with value <code>9</code> that delimit the basins.</span></p>
</div>
<div class="paragraph">
<p>Actually, the problem was that in my test case I did not start from the low point <code>(1, 0)</code> but a neighbor <code>(0, 0)</code>. Looking only for numbers with higher values would work when starting from the low point, but it is not necessary. Only looking for nines is fine and allows to start from anywhere in the basin.</p>
</div>
<div class="paragraph">
<p>The depth first traversal is put in its own function <code>get_basin_size</code> for readability ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get the basin sizes of the basins the given coordinates belong to with a breadth first traversal
pub fn get_basin_size(w: usize, grid: &amp;[usize], x: usize, y: usize) -&gt; usize {
    let mut unknown = vec![true; grid.len()];
    let mut queue = VecDeque::new();

    unknown[x + w * y] = false;
    queue.push_back((x, y));
    let mut count = 0;

    let h = grid.len() / w;

    // breadth first traversal
    while let Some((x, y)) = queue.pop_front() {
        count += 1;

        for (x_a, y_a) in [
            (x.wrapping_sub(1), y),
            (x + 1, y),
            (x, y.wrapping_sub(1)),
            (x, y + 1),
        ] {
            if (x_a &lt; w &amp;&amp; y_a &lt; h) &amp;&amp; unknown[x_a + w * y_a] &amp;&amp; grid[x_a + w * y_a] != 9 {
                // if adjacent is within grid, is not yet seen and has a value != 9, mark known and add to queue
                unknown[x_a + w * y_a] = false;
                queue.push_back((x_a, y_a));
            }
        }
    }

    count
}

/// get the product of the sizes of the (at most) three biggest basins
pub fn solution_2(w: usize, grid: &amp;[usize]) -&gt; usize {
    // determine low points and calculate basin sizes for those
    let mut basins = (0..grid.len())
        .map(|idx| (idx % w, idx / w))
        .filter(|(x, y)| {
            (*x == 0 || grid[x - 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*x == w - 1 || grid[x + 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*y == 0 || grid[x + w * (y - 1)] &gt; grid[x + w * y])
                &amp;&amp; (*y == grid.len() / w - 1 || grid[x + w * (y + 1)] &gt; grid[x + w * y])
        })
        .map(|(x, y)| get_basin_size(w, grid, x, y))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // sort basin sizes
    basins.sort_unstable();

    // product over the last three elements
    basins.iter().rev().take(3).product()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_8"><a class="anchor" href="#_tests_8"></a><a class="link" href="#_tests_8">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "2199943210\n3987894921\n9856789892\n8767896789\n9899965678";
    const W: usize = 10;
    const GRID: &amp;'static [usize] = &amp;[
        2, 1, 9, 9, 9, 4, 3, 2, 1, 0, 3, 9, 8, 7, 8, 9, 4, 9, 2, 1, 9, 8, 5, 6, 7, 8, 9, 8, 9, 2,
        8, 7, 6, 7, 8, 9, 6, 7, 8, 9, 9, 8, 9, 9, 9, 6, 5, 6, 7, 8,
    ];

    #[test]
    fn test_parse() {
        assert_eq!((W, GRID.to_vec()), parse(CONTENT));
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(15, solution_1(W, GRID));
    }

    #[test]
    fn test_get_basin_size() {
        for (exp, (x, y)) in [(3, (1, 0)), (9, (9, 0)), (14, (2, 2)), (9, (6, 4))] {
            assert_eq!(exp, get_basin_size(W, GRID, x, y));
        }
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(1_134, solution_2(W, GRID));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_5"><a class="anchor" href="#_today_i_learned_5"></a><a class="link" href="#_today_i_learned_5">Today I learned</a></h5>
<div class="paragraph">
<p>Read the puzzle description carefully (ha, not really a new learning) and continue to test (I think we had that before).</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_rust"><a class="anchor" href="#_day_10_rust"></a><a class="link" href="#_day_10_rust">Day 10: rust</a></h3>
<div class="sect3">
<h4 id="_day_10_syntax_scoring"><a class="anchor" href="#_day_10_syntax_scoring"></a><a class="link" href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/10">AoC|2021|10</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_8"><a class="anchor" href="#_part_1_8"></a><a class="link" href="#_part_1_8">Part 1</a></h5>
<div class="paragraph">
<p>Solution idea is to parse the characters one by one. If they are open delimiters, push the corresponding closing delimiter to a stack. If they are closing delimites, pop values from the stack and compare them to the current character.</p>
</div>
<div class="paragraph">
<p>If a comparison fails, an illegal character is found and its score is returned. Then the sum over the scores is taken.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// return illegal char's score if any in as ``Some`` value, otherwise ``None``
pub fn get_illegal_score(line: &amp;str) -&gt; Option&lt;usize&gt; {
    let mut stack = Vec::new();
    for c in line.chars() {
        match c {
            '(' =&gt; stack.push(')'),
            '[' =&gt; stack.push(']'),
            '{' =&gt; stack.push('}'),
            '&lt;' =&gt; stack.push('&gt;'),
            ')' if c != stack.pop().unwrap() =&gt; return Some(3),
            ']' if c != stack.pop().unwrap() =&gt; return Some(57),
            '}' if c != stack.pop().unwrap() =&gt; return Some(1_197),
            '&gt;' if c != stack.pop().unwrap() =&gt; return Some(25_137),
            _ =&gt; {} // nothing here
        }
    }
    None
}

/// Calculate sum of scores of illegal chars
pub fn solution_1(lines: &amp;[&amp;str]) -&gt; usize {
    lines
        .iter()
        .filter_map(|line| get_illegal_score(line))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_8"><a class="anchor" href="#_part_2_8"></a><a class="link" href="#_part_2_8">Part 2</a></h5>
<div class="paragraph">
<p>Same idea as for part 1. Now discard lines where comparisons fail. What remains in the stack once a line is processed are the characters required to repair the line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get the repair score if the line is incomplete as a ``Some`` value, otherwise return ``None``
pub fn get_repair_score(line: &amp;str) -&gt; Option&lt;usize&gt; {
    let mut stack = Vec::new();
    for c in line.chars() {
        match c {
            '(' =&gt; stack.push(')'),
            '[' =&gt; stack.push(']'),
            '{' =&gt; stack.push('}'),
            '&lt;' =&gt; stack.push('&gt;'),
            ')' | '&gt;' | '}' | ']' if c != stack.pop().unwrap() =&gt; return None,
            _ =&gt; {} // nothing here
        }
    }

    Some(stack.iter().rev().fold(0, |score, c| {
        score * 5
            + match c {
                ')' =&gt; 1,
                ']' =&gt; 2,
                '}' =&gt; 3,
                '&gt;' =&gt; 4,
                _ =&gt; unreachable!(),
            }
    }))
}

/// get the middle repair score
pub fn solution_2(lines: &amp;[&amp;str]) -&gt; usize {
    let mut scores = lines
        .iter()
        .filter_map(|line| get_repair_score(line))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    scores.sort_unstable();
    scores[scores.len() / 2]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_9"><a class="anchor" href="#_tests_9"></a><a class="link" href="#_tests_9">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "[({(&lt;(())[]&gt;[[{[]{&lt;()&lt;&gt;&gt;
[(()[&lt;&gt;])]({[&lt;{&lt;&lt;[]&gt;&gt;(
{([(&lt;{}[&lt;&gt;[]}&gt;{[]{[(&lt;()&gt;
(((({&lt;&gt;}&lt;{&lt;{&lt;&gt;}{[]{[]{}
[[&lt;[([]))&lt;([[{}[[()]]]
[{[{({}]{}}([{[{{{}}([]
{&lt;[[]]&gt;}&lt;{[{[{[]{()[[[]
[&lt;(&lt;(&lt;(&lt;{}))&gt;&lt;([]([]()
&lt;{([([[(&lt;&gt;()){}]&gt;(&lt;&lt;{{
&lt;{([{{}}[&lt;[[[&lt;&gt;{}]]]&gt;[]]";

    #[test]
    fn test_find_illegal_char() {
        let lines = parse(CONTENT);
        assert_eq!(
            vec![
                None,
                None,
                Some(1197),
                None,
                Some(3),
                Some(57),
                None,
                Some(3),
                Some(25137),
                None
            ],
            lines
                .iter()
                .map(|line| get_illegal_score(line))
                .collect::&lt;Vec&lt;_&gt;&gt;()
        );
    }

    #[test]
    fn test_solution_1() {
        let lines = parse(CONTENT);
        assert_eq!(26_397, solution_1(&amp;lines));
    }

    #[test]
    fn test_get_repair_score() {
        let lines = parse(CONTENT);
        assert_eq!(
            vec![
                Some(288957),
                Some(5566),
                None,
                Some(1480781),
                None,
                None,
                Some(995444),
                None,
                None,
                Some(294)
            ],
            lines
                .iter()
                .map(|line| get_repair_score(line))
                .collect::&lt;Vec&lt;_&gt;&gt;()
        );
    }

    #[test]
    fn test_solution_2() {
        let lines = parse(CONTENT);
        assert_eq!(288_957, solution_2(&amp;lines));
    }
}</code></pre>
</div>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_rust"><a class="anchor" href="#_day_11_rust"></a><a class="link" href="#_day_11_rust">Day 11: rust</a></h3>
<div class="sect3">
<h4 id="_day_11_dumbo_octopus"><a class="anchor" href="#_day_11_dumbo_octopus"></a><a class="link" href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/11">AoC|2021|11</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_9"><a class="anchor" href="#_part_1_9"></a><a class="link" href="#_part_1_9">Part 1</a></h5>
<div class="paragraph">
<p>Parse the input into a flat list of integers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse energy levels
///
/// # Panics
/// if number of energy levels parsed is not [N]^2
pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    let energies = content
        .chars()
        .filter(char::is_ascii_digit)
        .map(|c| c as usize - '0' as usize)
        .collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(N * N, energies.len(), "Bad length");
    energies
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In each update step, first increment all energy levels and reset them to 0 if they exceed 9. All indices for reset entries (octopus flashed) are added to a stack.</p>
</div>
<div class="paragraph">
<p>Then do a depth first traversal (breadth first would work just as well):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>pop elements off the stack while it is not empty</p>
</li>
<li>
<p>loop through all adjacents skipping adjecents which have already flashed (energy level already reset to 0)</p>
</li>
<li>
<p>increment adjacent&#8217;s energy level</p>
</li>
<li>
<p>if energy level exceeds 9, reset and add index to stack</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// do an update step on the energy levels
///
/// return the count of flashes in that step
pub fn step(energies: &amp;mut [usize]) -&gt; usize {
    // flashing stack
    let mut stack = Vec::new();

    // increase all elements by one
    for k in 0..energies.len() {
        energies[k] += 1;
        if energies[k] &gt; FLASH_THRESHOLD {
            // flashed -&gt; reset, add index to stack
            energies[k] = 0;
            stack.push((k % N, k / N));
        }
    }

    // depth first traversal to determine all flashes
    let mut flash_count = 0;
    while let Some((x, y)) = stack.pop() {
        flash_count += 1;

        // loop over adjacent entries
        for (x_a, y_a) in [
            (x + 1, y),
            (x + 1, y + 1),
            (x, y + 1),
            (x.wrapping_sub(1), y + 1),
            (x.wrapping_sub(1), y),
            (x.wrapping_sub(1), y.wrapping_sub(1)),
            (x, y.wrapping_sub(1)),
            (x + 1, y.wrapping_sub(1)),
        ] {
            if x_a &gt;= N || y_a &gt;= N {
                // out of bounds
                continue;
            }

            // flat index
            if energies[x_a + N * y_a] == 0 {
                // already flashed
                continue;
            }

            // not flashed yet, increment
            energies[x_a + N * y_a] += 1;
            if energies[x_a + N * y_a] &gt; FLASH_THRESHOLD {
                // flashed -&gt; reset, add index to stack
                energies[x_a + N * y_a] = 0;
                stack.push((x_a, y_a));
            }
        }
    }

    flash_count
}

pub const ROUNDS: usize = 100;

/// perform [ROUNDS] update steps and return total count of flashes
pub fn solution_1(energies: &amp;[usize]) -&gt; usize {
    // work on my own copy of the grid
    let mut energies = energies.to_owned();
    (0..ROUNDS).map(|_| step(&amp;mut energies)).sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_9"><a class="anchor" href="#_part_2_9"></a><a class="link" href="#_part_2_9">Part 2</a></h5>
<div class="paragraph">
<p>Perform update steps until all 100 octopuses flash at the same time. Could have re-used the updated grid from part 1, but the solution is fast enough to re-do the first 100 steps ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// perform update steps until all octopuses flash at the same time
///
/// return the first step when this occurs.
pub fn solution_2(energies: &amp;[usize]) -&gt; usize {
    // work on my own copy of the grid
    let mut energies = energies.to_owned();
    let mut rounds = 1; // one based counting
    while step(&amp;mut energies) &lt; N * N {
        rounds += 1;
    }
    rounds
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_10"><a class="anchor" href="#_tests_10"></a><a class="link" href="#_tests_10">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526";

    const ENERGIES: &amp;'static [usize] = &amp;[
        5, 4, 8, 3, 1, 4, 3, 2, 2, 3, 2, 7, 4, 5, 8, 5, 4, 7, 1, 1, 5, 2, 6, 4, 5, 5, 6, 1, 7, 3,
        6, 1, 4, 1, 3, 3, 6, 1, 4, 6, 6, 3, 5, 7, 3, 8, 5, 4, 7, 8, 4, 1, 6, 7, 5, 2, 4, 6, 4, 5,
        2, 1, 7, 6, 8, 4, 1, 7, 2, 1, 6, 8, 8, 2, 8, 8, 1, 1, 3, 4, 4, 8, 4, 6, 8, 4, 8, 5, 5, 4,
        5, 2, 8, 3, 7, 5, 1, 5, 2, 6,
    ];

    const CONTENT_1: &amp;str = "6594254334
3856965822
6375667284
7252447257
7468496589
5278635756
3287952832
7993992245
5957959665
6394862637";

    const CONTENT_2: &amp;str = "8807476555
5089087054
8597889608
8485769600
8700908800
6600088989
6800005943
0000007456
9000000876
8700006848";

    const CONTENT_10: &amp;str = "0481112976
0031112009
0041112504
0081111406
0099111306
0093511233
0442361130
5532252350
0532250600
0032240000";

    #[test]
    fn test_parse() {
        assert_eq!(ENERGIES, parse(CONTENT));
    }

    #[test]
    fn test_step() {
        let mut energies = parse(CONTENT);
        let energies_1 = parse(CONTENT_1);
        let energies_2 = parse(CONTENT_2);
        let energies_10 = parse(CONTENT_10);

        let mut flash_count = 0;

        // one step
        flash_count += step(&amp;mut energies);
        assert_eq!(0, flash_count);
        assert_eq!(energies_1, energies);

        // another step
        flash_count += step(&amp;mut energies);
        assert_eq!(35, flash_count);
        assert_eq!(energies_2, energies);

        // 8 more steps
        for _ in 2..10 {
            flash_count += step(&amp;mut energies);
        }
        assert_eq!(204, flash_count);
        assert_eq!(energies_10, energies);
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(1656, solution_1(&amp;parse(CONTENT)));
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(195, solution_2(&amp;parse(CONTENT)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_6"><a class="anchor" href="#_today_i_learned_6"></a><a class="link" href="#_today_i_learned_6">Today I learned</a></h5>
<div class="paragraph">
<p>In depth first traversal (as well as in breadth first traversal), be careful to not add elements to the stack (or queue) multiple times. In my first approach, I only reset the energy levels when they were popped from the queue. Thus entries could get modified while their indices were in the queue, and indices could be added multiple times. Took a while to sort that out.</p>
</div>
<a id="day12" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_12_rust"><a class="anchor" href="#_day_12_rust"></a><a class="link" href="#_day_12_rust">Day 12: rust</a></h3>
<div class="sect3">
<h4 id="_day_12_passage_pathing"><a class="anchor" href="#_day_12_passage_pathing"></a><a class="link" href="#_day_12_passage_pathing">Day 12: Passage Pathing</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/12">AoC|2021|12</a>.</p>
</div>
<div class="sect4">
<h5 id="_solution_2"><a class="anchor" href="#_solution_2"></a><a class="link" href="#_solution_2">Solution</a></h5>
<div class="paragraph">
<p>Again a kind of breadth first traversal and the first day in the 2021 edition where my solution takes significant time (more than a couple of ms) to compute. After some optimizations, I am now down to about 40ms for part 2.</p>
</div>
<div class="sect5">
<h6 id="_data_structure_for_the_cave_map"><a class="anchor" href="#_data_structure_for_the_cave_map"></a><a class="link" href="#_data_structure_for_the_cave_map">Data Structure for the Cave Map</a></h6>
<div class="paragraph">
<p>To start, I parse the input into a struct <code>CaveMap</code> (see comments in code for details):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Map of Caves
///
/// Each cave has a unique ID: the position of it's name in the [CaveMap::caves] field.
/// The adjacents of the cave are stored in the list at the same position in the [CaveMap::adjacents] field.
///
/// The IDs of the start and end cave are stored in the fields [CaveMap::start] and [CaveMap::end].
pub struct CaveMap&lt;'a&gt; {
    pub caves: Vec&lt;&amp;'a str&gt;,
    pub adjacents: Vec&lt;Vec&lt;usize&gt;&gt;,
    pub start: usize,
    pub end: usize,
}

impl&lt;'a&gt; CaveMap&lt;'a&gt; {
    /// parse input to map
    pub fn parse(input: &amp;'a str) -&gt; Self {
        let mut caves = Vec::new();
        let mut adjacents = Vec::new();
        let mut start = 0;
        let mut end = 0;

        for line in input.lines() {
            let mut parts = line.split('-').map(|part| {
                caves
                    .iter()
                    .position(|cave| *cave == part)
                    .unwrap_or_else(|| {
                        caves.push(part);
                        adjacents.push(Vec::new());
                        // keep ID to start or end
                        match part {
                            "start" =&gt; start = caves.len() - 1,
                            "end" =&gt; end = caves.len() - 1,
                            _ =&gt; {}
                        }
                        caves.len() - 1
                    })
            });

            let lhs_id = parts.next().expect("No LHS");
            let rhs_id = parts.next().expect("No RHS");
            assert!(parts.next().is_none(), "More than two parts");
            adjacents[lhs_id].push(rhs_id);
            adjacents[rhs_id].push(lhs_id);
        }

        CaveMap {
            caves,
            adjacents,
            start,
            end,
        }
    }

    /// check whether cave with given ID is small
    pub fn is_small(&amp;self, id: usize) -&gt; bool {
        self.caves[id].chars().next().unwrap().is_ascii_lowercase()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In my initial implementation, I used a <code>BTreeMap</code> to map cave names to adjacent names. In the current version, I use cave IDs instead, which are the addresses to the fields in the CaveMap structure. This reduced the runtime by about 25%.</p>
</div>
</div>
<div class="sect5">
<h6 id="_searching_for_paths"><a class="anchor" href="#_searching_for_paths"></a><a class="link" href="#_searching_for_paths">Searching for Paths</a></h6>
<div class="paragraph">
<p>The general soluton idea is to do a (breadth first) traversal on a graph of all possible paths through the cave (graph nodes are paths, not caves):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Push a path consisting of the <code>start</code> cave only to the queue</p>
</li>
<li>
<p>Pop a path from the queue, and look at all adjacent caves of the last cave on the path</p>
<div class="ulist">
<ul>
<li>
<p>if the adjacent cave is <code>start</code>, ignore it</p>
</li>
<li>
<p>if the adjacent cave is <code>end</code>, the path is complete; increase the unqiue path counter</p>
</li>
<li>
<p>if the adjacent cave is a large cave, append it to the path and push the extended path to the queue</p>
</li>
<li>
<p>if the adjacent cave is a small cave, append it to the path and push the extended path to the queue if</p>
<div class="ulist">
<ul>
<li>
<p>the small cave is not yet on the path (part 1 &amp; 2) or</p>
</li>
<li>
<p>the small cave is already on the path and no small cave is on the path twice yet (part 2 only)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Repeat step 2 until queue is empty</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count number of distinct pathes using map
///
/// the flag ``no_duplicate_small`` controls whether small caves may be visited more than
/// once. If the flag is set to ``true``, this is not allowed at all. If it is set to false,
/// it is allowed at most once.
pub fn get_path_count(map: &amp;CaveMap, no_duplicate_small: bool) -&gt; usize {
    // store all path elements as a cave ID and a parent pointer (= index to this vec) wrapped in an Option
    let mut paths: Vec&lt;(usize, Option&lt;usize&gt;)&gt; = Vec::new();

    // count of unique paths
    let mut path_count = 0;

    let mut queue = VecDeque::new();
    paths.push((map.start, None));
    queue.push_back((paths.len() - 1, no_duplicate_small));

    while let Some((ptr, no_duplicate_small)) = queue.pop_front() {
        let cave_id = paths[ptr].0;
        for &amp;id in &amp;map.adjacents[cave_id] {
            if id == map.start {
                // never go back to start
                continue;
            } else if id == map.end {
                // new path to "end" found
                path_count += 1;
                continue;
            }

            let duplicate_small = map.is_small(id) &amp;&amp; contains(&amp;paths, ptr, id);
            if no_duplicate_small &amp;&amp; duplicate_small {
                // skip small cave already on path, if no duplicate small caves are allowed
                continue;
            }

            // push new path element to paths vec
            paths.push((id, Some(ptr)));

            // add pointer to path element to queue
            // if a duplicate small was added, no further duplicate smalls are allowed
            queue.push_back((paths.len() - 1, no_duplicate_small || duplicate_small));
        }
    }

    path_count
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Initially, I used <code>Vec</code>s to represent paths. To extend a path by another cave, I copied the complete <code>Vec</code>, added the cave&#8217;s name and pushed the <code>Vec</code> to the queue. In the current version, I use kind of a linked list (each path element has a reference to the parent element). Since linked lists are something that does not go very well with Rust&#8217;s ownership and borrowing system (or maybe I just don&#8217;t know how to do that properly), I keep a <code>Vec</code> of all path elements (for part 2, a total of 427.805 path elements are created). Each path element is a tuple of a cave ID and and a parent pointer, which points to the parent path element in that <code>Vec</code>. Because the start of a path has no parent, the parent pointer is wrapped in an <code>Option</code>. This optimization reduced the runtime by about 75%.</p>
</div>
<div class="paragraph">
<p>The check whether a cave ID is contained in a path is implemented as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// determine whether a path contains a cave
fn contains(paths: &amp;[(usize, Option&lt;usize&gt;)], ptr: usize, id: usize) -&gt; bool {
    let mut ptr = ptr;
    loop {
        let (cave_id, opt_ptr) = paths[ptr];
        if cave_id == id {
            return true;
        }

        if let Some(next_ptr) = opt_ptr {
            ptr = next_ptr;
        } else {
            return false;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_11"><a class="anchor" href="#_tests_11"></a><a class="link" href="#_tests_11">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use std::collections::{BTreeMap, BTreeSet};

    use super::*;

    const TEST_INPUT: &amp;str = "start-A
start-b
A-c
A-b
b-d
A-end
b-end";

    fn get_test_data() -&gt; BTreeMap&lt;&amp;'static str, BTreeSet&lt;&amp;'static str&gt;&gt; {
        BTreeMap::from([
            ("start", BTreeSet::from(["A", "b"])),
            ("A", BTreeSet::from(["start", "c", "b", "end"])),
            ("b", BTreeSet::from(["start", "A", "d", "end"])),
            ("c", BTreeSet::from(["A"])),
            ("d", BTreeSet::from(["b"])),
            ("end", BTreeSet::from(["A", "b"])),
        ])
    }

    fn get_adjacents&lt;'a&gt;(map: &amp;'a CaveMap, name: &amp;str) -&gt; Option&lt;impl Iterator&lt;Item = &amp;'a str&gt;&gt; {
        map.caves
            .iter()
            .position(|cave| *cave == name)
            .map(|idx| map.adjacents[idx].iter().map(|adj| map.caves[*adj]))
    }

    #[test]
    fn test_parse() {
        let map = parse(TEST_INPUT);
        for (name, adjacents) in get_test_data() {
            assert_eq!(
                Some(adjacents),
                get_adjacents(&amp;map, name).map(|it| it.collect())
            );
        }
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(10, solution_1(&amp;parse(&amp;TEST_INPUT)))
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(36, solution_2(&amp;parse(&amp;TEST_INPUT)))
    }
}</code></pre>
</div>
</div>
<a id="day13" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_13_rust"><a class="anchor" href="#_day_13_rust"></a><a class="link" href="#_day_13_rust">Day 13: rust</a></h3>
<div class="sect3">
<h4 id="_day_13_transparent_origami"><a class="anchor" href="#_day_13_transparent_origami"></a><a class="link" href="#_day_13_transparent_origami">Day 13: Transparent Origami</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/13">AoC|2021|13</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_10"><a class="anchor" href="#_part_1_10"></a><a class="link" href="#_part_1_10">Part 1</a></h5>
<div class="paragraph">
<p>I parse the points in a set (that does the duplicates handling for me) and the fold instructions in a list of tuples with a boolean flag and a fold coordinate. The boolean flag is set to true for horizontal folds and false for vertical folds</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn parse(content: &amp;str) -&gt; (HashSet&lt;(usize, usize)&gt;, Vec&lt;(bool, usize)&gt;) {
    let mut parts = content.split("\n\n");
    (
        parts
            .next()
            .expect("No points")
            .lines()
            .map(|line| line.split(","))
            .map(|mut point_parts| {
                (
                    point_parts
                        .next()
                        .expect("No x coordinate")
                        .parse()
                        .expect("Could not parse x"),
                    point_parts
                        .next()
                        .expect("No y coordinate")
                        .parse()
                        .expect("Could not parse y"),
                )
            })
            .collect(),
        parts
            .next()
            .expect("No fold instructions")
            .lines()
            .map(|line| line.split("="))
            .map(|mut fold_parts| {
                (
                    match fold_parts.next() {
                        Some("fold along y") =&gt; true,
                        Some("fold along x") =&gt; false,
                        _ =&gt; panic!("Unexpected fold instruction"),
                    },
                    fold_parts
                        .next()
                        .expect("No fold coordinate")
                        .parse()
                        .expect("Could not parse fold coordinate"),
                )
            })
            .collect(),
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fold function iterates over all points, checks whether they are below / to the right of the fold coordinate and maps them above / to the left. Then everything is collected to a set again (removing duplicates)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// perform a single fold
pub fn fold(
    points: &amp;HashSet&lt;(usize, usize)&gt;,
    horizontal: bool,
    coord: usize,
) -&gt; HashSet&lt;(usize, usize)&gt; {
    points
        .iter()
        .map(|(x, y)| {
            if horizontal &amp;&amp; y &gt; &amp;coord {
                (*x, 2 * coord - *y)
            } else if !horizontal &amp;&amp; x &gt; &amp;coord {
                (2 * coord - *x, *y)
            } else {
                (*x, *y)
            }
        })
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is used for part 1 as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count points after first fold operation
pub fn solution_1(points: &amp;HashSet&lt;(usize, usize)&gt;, folds: &amp;[(bool, usize)]) -&gt; usize {
    let (horizontal, fold_coordinate) = folds.first().expect("No folds");
    fold(points, *horizontal, *fold_coordinate).len()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_10"><a class="anchor" href="#_part_2_10"></a><a class="link" href="#_part_2_10">Part 2</a></h5>
<div class="paragraph">
<p>Part 2 adds calculating a bounding box of the result and putting everything together in a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn points_to_string(points: &amp;HashSet&lt;(usize, usize)&gt;) -&gt; String {
    // calculate bounding box
    let (x_min, y_min, x_max, y_max) = points.iter().fold(
        (usize::MAX, usize::MAX, 0, 0),
        |(x_min, y_min, x_max, y_max), (x, y)| {
            (
                cmp::min(x_min, *x),
                cmp::min(y_min, *y),
                cmp::max(x_max, *x + 1),
                cmp::max(y_max, *y + 1),
            )
        },
    );

    // assemble result string
    (y_min..y_max)
        .map(|y| {
            (x_min..x_max)
                .map(|x| if points.contains(&amp;(x, y)) { '#' } else { '.' })
                .collect::&lt;String&gt;()
        })
        .map(|line| line.add("\n"))
        .collect::&lt;String&gt;()
}

/// perform all fold operations and return result as a ``String``
pub fn solution_2(points: &amp;HashSet&lt;(usize, usize)&gt;, folds: &amp;[(bool, usize)]) -&gt; String {
    let mut points = points.to_owned();
    for (horizontal, fold_coordinate) in folds {
        points = fold(&amp;points, *horizontal, *fold_coordinate);
    }

    points_to_string(&amp;points)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Solving part 2 took much longer than it should for me, because I messed up with the bounding box. Tried to find my mistake in the calculations to figure out that I just took <code>y_min</code> for <code>x_max</code> and vice versa resulting in empty strings all the time :(.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tests_12"><a class="anchor" href="#_tests_12"></a><a class="link" href="#_tests_12">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const TEST_CONTENT: &amp;str = "6,10
0,14
9,10
0,3
10,4
4,11
6,0
6,12
4,1
0,13
10,12
3,4
3,0
8,4
1,10
2,14
8,10
9,0

fold along y=7
fold along x=5";

    const TEST_POINTS: [(usize, usize); 18] = [
        (6, 10),
        (0, 14),
        (9, 10),
        (0, 3),
        (10, 4),
        (4, 11),
        (6, 0),
        (6, 12),
        (4, 1),
        (0, 13),
        (10, 12),
        (3, 4),
        (3, 0),
        (8, 4),
        (1, 10),
        (2, 14),
        (8, 10),
        (9, 0),
    ];

    const TEST_FOLDS: &amp;[(bool, usize)] = &amp;[(true, 7), (false, 5)];

    const TEST_RESULT: &amp;str = "#####\n\
                               #...#\n\
                               #...#\n\
                               #...#\n\
                               #####\n";

    #[test]
    fn test_parse() {
        let (points, folds) = parse(&amp;TEST_CONTENT);
        assert_eq!(HashSet::from(TEST_POINTS), points);
        assert_eq!(TEST_FOLDS, folds);
    }

    #[test]
    fn test_solution_1() {
        let (points, folds) = parse(&amp;TEST_CONTENT);
        assert_eq!(17, solution_1(&amp;points, &amp;folds));
    }

    #[test]
    fn test_solution_2() {
        let (points, folds) = parse(&amp;TEST_CONTENT);
        assert_eq!(TEST_RESULT, solution_2(&amp;points, &amp;folds));
    }
}</code></pre>
</div>
</div>
<a id="day14" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_14_rust"><a class="anchor" href="#_day_14_rust"></a><a class="link" href="#_day_14_rust">Day 14: rust</a></h3>
<div class="sect3">
<h4 id="_day_14_extended_polymerization"><a class="anchor" href="#_day_14_extended_polymerization"></a><a class="link" href="#_day_14_extended_polymerization">Day 14: Extended Polymerization</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/14">AoC|2021|14</a>.</p>
</div>
<div class="sect4">
<h5 id="_solution_3"><a class="anchor" href="#_solution_3"></a><a class="link" href="#_solution_3">Solution</a></h5>
<div class="paragraph">
<p>Ough! Today&#8217;s was the biggest headache so far this year.</p>
</div>
<div class="paragraph">
<p>I was aware when starting part 1 that a solution based on arrays will probably not solve part 2. It was good enough for part 1 though.</p>
</div>
<div class="paragraph">
<p>But while implementing it, I was sure I will need linked lists for part 2 and I was afraid of it, because I really don&#8217;t know how to implement linked lists in Rust and the <code>LinkedList</code> Rust comes with did not help a lot. So I spent quite some time trying to implement a linked list in Rust and - again - failed. Switch to Java, where linked lists are no pain at all just to realize that no list based solution will work at all for today.</p>
</div>
<div class="paragraph">
<p>With a little bit of thinking on the problem, I realized that it would be enough to just count the pairs. It does not really matter where they appear in the polymer. With this idea, the solution was not very complicated&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Parse the input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// porse content into a vector of chars and a map with pairs of chars as keys and the
/// char to be inserted as value
pub fn parse(content: &amp;str) -&gt; (Vec&lt;char&gt;, HashMap&lt;(char, char), char&gt;) {
    let mut parts = content.split("\n\n");

    let template = parts
        .next()
        .expect("No template")
        .chars()
        .collect::&lt;Vec&lt;_&gt;&gt;();

    let rules = parts
        .next()
        .expect("No rules")
        .lines()
        .map(|line| {
            let mut chars = line.chars();
            let a = chars.next().expect("No first char");
            let b = chars.next().expect("No second char");
            let c = chars.skip(4).next().expect("No resulting char");
            ((a, b), c)
        })
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();

    (template, rules)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simulate rounds of insertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// simulate given number of rounds starting from polymer template and using given
/// rules
pub fn simulate_rounds(
    template: &amp;[char],
    rules: &amp;HashMap&lt;(char, char), char&gt;,
    rounds: usize,
) -&gt; usize {
    // map of pairs to number of occurances of those
    let mut pairs = HashMap::new();
    for (c1, c2) in template.iter().zip(template.iter().skip(1)) {
        let cnt = pairs.entry((*c1, *c2)).or_insert(0usize);
        *cnt += 1;
    }

    // in each round, update pairs
    for _ in 0..rounds {
        let mut upd = HashMap::new();
        for ((c1, c2), cnt0) in &amp;pairs {
            if let Some(d) = rules.get(&amp;(*c1, *c2)) {
                // if pair is found in rules, replace (c1, c2) by (c1, d) and (d, c2)
                let cnt = upd.entry((*c1, *d)).or_insert(0);
                *cnt += cnt0;
                let cnt = upd.entry((*d, *c2)).or_insert(0);
                *cnt += cnt0;
            } else {
                // if pair is not found in rules, keep pair
                let cnt = upd.entry((*c1, *c2)).or_insert(0);
                *cnt += cnt0;
            }
        }
        pairs = upd;
    }

    // count symbols in pairs
    // each symbol contributes to two pairs except for the first and the last symbol
    // start with count = 1 for first and last symbol to consistently count every symbol
    // twice
    let mut counts = HashMap::new();
    counts.insert(template[0], 1);
    counts.insert(template[template.len() - 1], 1);
    for ((c1, c2), cnt) in &amp;pairs {
        let count = counts.entry(*c1).or_insert(0);
        *count += cnt;
        let count = counts.entry(*c2).or_insert(0);
        *count += cnt;
    }

    // get (twice the) count for most and less frequent symbol
    let min = counts.values().min().expect("No min");
    let max = counts.values().max().expect("No max");

    // return difference, divide by 2 because every symbol is counted twice
    (max - min) / 2
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_13"><a class="anchor" href="#_tests_13"></a><a class="link" href="#_tests_13">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "NNCB

CH -&gt; B
HH -&gt; N
CB -&gt; H
NH -&gt; C
HB -&gt; C
HC -&gt; B
HN -&gt; C
NN -&gt; C
BH -&gt; H
NC -&gt; B
NB -&gt; B
BN -&gt; B
BB -&gt; N
BC -&gt; B
CC -&gt; N
CN -&gt; C";
    const TEST_TEMPLATE: [char; 4] = ['N', 'N', 'C', 'B'];
    const TEST_RULES: [((char, char), char); 16] = [
        (('C', 'H'), 'B'),
        (('H', 'H'), 'N'),
        (('C', 'B'), 'H'),
        (('N', 'H'), 'C'),
        (('H', 'B'), 'C'),
        (('H', 'C'), 'B'),
        (('H', 'N'), 'C'),
        (('N', 'N'), 'C'),
        (('B', 'H'), 'H'),
        (('N', 'C'), 'B'),
        (('N', 'B'), 'B'),
        (('B', 'N'), 'B'),
        (('B', 'B'), 'N'),
        (('B', 'C'), 'B'),
        (('C', 'C'), 'N'),
        (('C', 'N'), 'C'),
    ];

    #[test]
    fn test_parse() {
        let (template, rules) = parse(&amp;CONTENT);
        assert_eq!(Vec::from(TEST_TEMPLATE), template);
        assert_eq!(HashMap::from(TEST_RULES), rules);
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(
            1_588,
            solution_1(&amp;Vec::from(TEST_TEMPLATE), &amp;HashMap::from(TEST_RULES))
        );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_7"><a class="anchor" href="#_today_i_learned_7"></a><a class="link" href="#_today_i_learned_7">Today I learned</a></h5>
<div class="paragraph">
<p>If Eric Wastl says "This polymer grows quickly" and the examples provided in the puzzle description produce numbers &gt; 2 Trillions, there is probably no list based implementation (be it linked or array based lists) that efficiently solve the puzzle.</p>
</div>
<a id="day15" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_15_rust"><a class="anchor" href="#_day_15_rust"></a><a class="link" href="#_day_15_rust">Day 15: rust</a></h3>
<div class="sect3">
<h4 id="_day_15_chiton"><a class="anchor" href="#_day_15_chiton"></a><a class="link" href="#_day_15_chiton">Day 15: Chiton</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/15">AoC|2021|15</a>.</p>
</div>
<div class="sect4">
<h5 id="_solution_4"><a class="anchor" href="#_solution_4"></a><a class="link" href="#_solution_4">Solution</a></h5>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra!?</a></p>
</div>
<div class="paragraph">
<p>When looking at the puzzle, I thought: "Obviously Dijkstra". Then I implemented a solution which I thought was Dijskstra while it actually was not. It still worked.</p>
</div>
<div class="paragraph">
<p>I realized my implementation was not Dijkstra when I tried to extend to <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> to figure out whether this improves performance.</p>
</div>
<div class="paragraph">
<p>Hence, as a second step, I implemented Dijkstra. This works as well (obvisouly) but performs worse than my initial solution. For my Dijkstra implementation, A* (with the length of the shortest path to the target <code>width - 1 - x + height - 1 - y</code> as heuristic) does not perform any better.</p>
</div>
<div class="paragraph">
<p>The reason why my first solution works is the structure of the problem: the weight of an edge to any coordinate (x, y) is independent of the neighbor from where we reach the coordinate. Hence, if a coordinate is reached once in the algorithm, it is not possible to reach it later on with a lower overall risk. That essentially means: there will never be any decrease keys. This can be confirmed in the Dijkstra implementation by using feature <code>dijkstra_panic_decrease</code> which results the program to panic on an attempt to decrease a key. Run puzzle with <code>cargo run --release --features dijkstra_panic_release</code>.</p>
</div>
<div class="sect5">
<h6 id="_simple_algorithm"><a class="anchor" href="#_simple_algorithm"></a><a class="link" href="#_simple_algorithm">Simple Algorithm</a></h6>
<div class="paragraph">
<p>The simple solution (my first solution) is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solve(grid: &amp;[usize], w: usize, n: usize) -&gt; usize {
    let h = grid.len() / w;

    let mut heap = BinaryHeap::new();
    let mut settled = vec![false; grid.len() * n * n];

    heap.push((usize::MAX, 0)); // nodes are tuples (usize::MAX - risk, idx)
    settled[0] = true;

    while let Some((risk, idx)) = heap.pop() {
        if idx == grid.len() * n * n - 1 {
            return usize::MAX - risk; // target reached
        }

        let (x, y) = (idx % (w * n), idx / (w * n));

        for (x_a, y_a) in [
            (x + 1, y),
            (x, y + 1),
            (x.wrapping_sub(1), y),
            (x, y.wrapping_sub(1)),
        ] {
            if x_a &gt;= w * n || y_a &gt;= h * n || settled[x_a + y_a * w * n] {
                continue; // out of bounds or visisted
            }

            let risk = risk - ((grid[x_a % w + y_a % h * w] + x_a / w + y_a / h - 1) % 9) - 1;

            settled[x_a + y_a * w * n] = true; // first visit settles
            heap.push((risk, x_a + y_a * w * n));
        }
    }

    panic!("No path found");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the simple solution, I "invert" the risk (<code>usize::MAX - risk</code>) because <code>BinaryHeap</code> returns the biggest element first.</p>
</div>
</div>
<div class="sect5">
<h6 id="_dijkstra"><a class="anchor" href="#_dijkstra"></a><a class="link" href="#_dijkstra">Dijkstra</a></h6>
<div class="paragraph">
<p>The Dijkstra implementatino looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn solve(grid: &amp;[usize], w: usize, n: usize) -&gt; usize {
        let h = grid.len() / w;

        let mut heap = BTreeSet::new();
        let mut settled = vec![false; w * h * n * n];
        let mut risks = vec![None; w * h * n * n];

        heap.insert((0, 0)); // nodes are tuples (risk, idx)
        risks[0] = Some(0); // keep track of best risks so far
        settled[0] = true; // flag nodes which are settled

        while let Some((risk, idx)) = heap.pop_first() {
            if idx == grid.len() * n * n - 1 {
                return risk; // target reached
            }
            settled[idx] = true; // no further improvement possible

            let (x, y) = (idx % (w * n), idx / (w * n));
            for (x_a, y_a) in [
                (x + 1, y),
                (x, y + 1),
                (x.wrapping_sub(1), y),
                (x, y.wrapping_sub(1)),
            ] {
                let idx_a = x_a + y_a * w * n;
                if x_a &gt;= w * n || y_a &gt;= h * n || settled[idx_a] {
                    continue; // out of bounds or settled
                }

                let risk_upd =
                    risk + ((grid[x_a % w + y_a % h * w] + x_a / w + y_a / h - 1) % 9) + 1;
                if let Some(risk_cur) = risks[idx_a] {
                    if risk_upd &gt;= risk_cur {
                        continue; // no improvement
                    }
                    if cfg!(feature = "dijkstra_panic_decrease") {
                        unreachable!("Decrese key can never happen");
                    }
                    heap.remove(&amp;(risk_cur, idx_a)); // improved path to node seen previously
                }

                heap.insert((risk_upd, idx_a));
                risks[idx_a] = Some(risk_upd);
            }
        }

        panic!("No path found");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>I use a <code>BTreeSet</code> as heap. Decrease key is implemented as remove old node and insert new node (but actually never used, see above).</p>
</div>
<div class="paragraph">
<p>The solution only compiles using the rust nightly channel because <code>BTreeSet::pop_first</code> is unstable. The simple version runs on rust stable.</p>
</div>
<div class="paragraph">
<p>Run the Dijkstra version with <code>cargo run --release --features dijkstra</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_parse"><a class="anchor" href="#_parse"></a><a class="link" href="#_parse">Parse</a></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">///
/// ```
/// # use mr_kaffee_2021_15::*;
/// assert_eq!((vec![0, 1, 2, 3], 2), parse("01\n23"));
/// ```
pub fn parse(content: &amp;str) -&gt; (Vec&lt;usize&gt;, usize) {
    (
        content
            .chars()
            .filter(|c| c.is_ascii_digit())
            .map(|c| c as usize - '0' as usize)
            .collect(),
        content.lines().next().expect("No data").len(),
    )
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_14"><a class="anchor" href="#_tests_14"></a><a class="link" href="#_tests_14">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const TEST_CONTENT: &amp;str = "1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581";

    const TEST_GRID: &amp;'static [usize] = &amp;[
        1, 1, 6, 3, 7, 5, 1, 7, 4, 2, 1, 3, 8, 1, 3, 7, 3, 6, 7, 2, 2, 1, 3, 6, 5, 1, 1, 3, 2, 8,
        3, 6, 9, 4, 9, 3, 1, 5, 6, 9, 7, 4, 6, 3, 4, 1, 7, 1, 1, 1, 1, 3, 1, 9, 1, 2, 8, 1, 3, 7,
        1, 3, 5, 9, 9, 1, 2, 4, 2, 1, 3, 1, 2, 5, 4, 2, 1, 6, 3, 9, 1, 2, 9, 3, 1, 3, 8, 5, 2, 1,
        2, 3, 1, 1, 9, 4, 4, 5, 8, 1,
    ];
    const TEST_WIDTH: usize = 10;

    #[test]
    fn test_parse() {
        let (grid, width) = parse(TEST_CONTENT);
        assert_eq!(TEST_GRID, grid);
        assert_eq!(TEST_WIDTH, width);
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(40, solution_1(&amp;TEST_GRID, TEST_WIDTH))
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(315, solution_2(&amp;TEST_GRID, TEST_WIDTH))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_8"><a class="anchor" href="#_today_i_learned_8"></a><a class="link" href="#_today_i_learned_8">Today I Learned</a></h5>
<div class="paragraph">
<p>A possible way to implement Dijkstra on a simple graph with Rust.</p>
</div>
<div class="paragraph">
<p>Remember how Dijkstra and A* really work and understand that Dijkstra is not always needed depending on the structure of the problem to solve.</p>
</div>
<div class="paragraph">
<p>Use features for conditional compilation and use unstable Rust features.</p>
</div>
<div class="paragraph">
<p>Unfortunately, I also learned that the Rust collections in <code>std::collections</code> offer a quite poor interface. The function <code>BTreeMap::pop_min</code> being unstable is sad.</p>
</div>
<a id="day16" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_16_rust"><a class="anchor" href="#_day_16_rust"></a><a class="link" href="#_day_16_rust">Day 16: rust</a></h3>
<div class="sect3">
<h4 id="_day_16_packet_decoder"><a class="anchor" href="#_day_16_packet_decoder"></a><a class="link" href="#_day_16_packet_decoder">Day 16: Packet Decoder</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/16">AoC|2021|16</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_11"><a class="anchor" href="#_part_1_11"></a><a class="link" href="#_part_1_11">Part 1</a></h5>
<div class="paragraph">
<p>A lot to read today. But then it is just following the instructions.</p>
</div>
<div class="paragraph">
<p>I implemented a structure <code>Packets</code> to keep track of the current position and read numbers from the bits &amp; bytes (I am particularly proud that I got the bit ordering right from the beginning):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct Packets {
    data: Vec&lt;u8&gt;,
    pos: usize,
}

impl Packets {
    pub const SUM: usize = 0;
    pub const PRODUCT: usize = 1;
    pub const MIN: usize = 2;
    pub const MAX: usize = 3;
    pub const VALUE: usize = 4;
    pub const GREATER: usize = 5;
    pub const LESS: usize = 6;
    pub const EQUAL: usize = 7;

    pub const N_VERSION: usize = 3;
    pub const N_TYPE_ID: usize = 3;
    pub const N_FLAG: usize = 1;
    pub const N_VALUE_PART: usize = 4;
    pub const N_LENGTH_TYPE_ID: usize = 1;
    pub const N_LENGTH: [usize; 2] = [15, 11];

    pub fn from(bytes: &amp;[u8]) -&gt; Self {
        Packets {
            data: Vec::from(bytes),
            pos: 0,
        }
    }

    pub fn read_number(&amp;mut self, len: usize) -&gt; usize {
        let mut v = 0usize;
        for _ in 0..len {
            v = v &lt;&lt; 1 | ((self.data[self.pos &gt;&gt; 2] &gt;&gt; (!self.pos &amp; 3)) &amp; 1) as usize;
            self.pos += 1;
        }

        v
    }

    pub fn skip(&amp;mut self, len: usize) {
        self.pos += len;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The input is parsed into that structure with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">///
/// ```
/// # use mr_kaffee_2021_16::*;
/// assert_eq!(Packets::from(&amp;[0, 1, 10]), parse("01A"));
/// ```
pub fn parse(content: &amp;str) -&gt; Packets {
    let data = content
        .trim()
        .chars()
        .map(|c| match c {
            '0'..='9' =&gt; c as u8 - '0' as u8,
            'A'..='F' =&gt; c as u8 - 'A' as u8 + 10,
            _ =&gt; panic!("Illegal character: {}", c),
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
    Packets::from(&amp;data)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, part 1 is solved with the function <code>sum_versions</code> which calls itself recursively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn sum_versions(packets: &amp;mut Packets) -&gt; usize {
    let mut versions_sum = packets.read_number(Packets::N_VERSION);

    let type_id = packets.read_number(Packets::N_TYPE_ID);
    if type_id == Packets::VALUE {
        loop {
            let flag = packets.read_number(Packets::N_FLAG);
            packets.skip(Packets::N_VALUE_PART); // skip value

            if flag == 0 {
                break; // last part's flag is 0
            }
        }
    } else {
        let length_type_id = packets.read_number(Packets::N_LENGTH_TYPE_ID);
        let length = packets.read_number(Packets::N_LENGTH[length_type_id]);

        if length_type_id == 1 {
            for _ in 0..length {
                versions_sum += sum_versions(packets);
            }
        } else {
            let target = packets.pos + length;
            while packets.pos &lt; target {
                versions_sum += sum_versions(packets);
            }
        }
    }

    versions_sum
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_11"><a class="anchor" href="#_part_2_11"></a><a class="link" href="#_part_2_11">Part 2</a></h5>
<div class="paragraph">
<p>For part two the function <code>sum_versions</code> is modified to take into account the operators. The new function <code>process_packet</code> reads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn process_packet(packets: &amp;mut Packets) -&gt; usize {
    packets.skip(Packets::N_VERSION); // skip version

    let type_id = packets.read_number(Packets::N_TYPE_ID);
    if type_id == 4 {
        let mut value = 0;
        loop {
            let flag = packets.read_number(Packets::N_FLAG);
            value = value &lt;&lt; 4 | packets.read_number(Packets::N_VALUE_PART);

            if flag == 0 {
                break; // last part's flag is 0
            }
        }
        value
    } else {
        let length_type_id = packets.read_number(Packets::N_LENGTH_TYPE_ID);
        let length = packets.read_number(Packets::N_LENGTH[length_type_id]);

        let mut values = Vec::new();
        if length_type_id == 1 {
            for _ in 0..length {
                values.push(process_packet(packets));
            }
        } else {
            let target = packets.pos + length;
            while packets.pos &lt; target {
                values.push(process_packet(packets));
            }
        }

        match type_id {
            Packets::SUM =&gt; values.iter().sum(),
            Packets::PRODUCT =&gt; values.iter().product(),
            Packets::MIN =&gt; *values.iter().min().expect("No min"),
            Packets::MAX =&gt; *values.iter().max().expect("No max"),
            Packets::GREATER =&gt; (values[0] &gt; values[1]) as usize,
            Packets::LESS =&gt; (values[0] &lt; values[1]) as usize,
            Packets::EQUAL =&gt; (values[0] == values[1]) as usize,
            _ =&gt; panic!("Illegal type ID: {}", type_id),
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_15"><a class="anchor" href="#_tests_15"></a><a class="link" href="#_tests_15">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT_1: &amp;str = "8A004A801A8002F478";
    const CONTENT_2: &amp;str = "620080001611562C8802118E34";
    const CONTENT_3: &amp;str = "C0015000016115A2E0802F182340";
    const CONTENT_4: &amp;str = "A0016C880162017C3686B18A3D4780";

    const DATA_0: &amp;[u8] = &amp;[0xD, 0x2, 0xF, 0xE, 0x2, 0x8];
    const DATA_2: &amp;[u8] = &amp;[
        6, 2, 0, 0, 8, 0, 0, 0, 1, 6, 1, 1, 5, 6, 2, 0xC, 8, 8, 0, 2, 1, 1, 8, 0xE, 3, 4,
    ];

    const SUM_0: usize = 6;
    const SUM_1: usize = 16;
    const SUM_2: usize = 12;
    const SUM_3: usize = 23;
    const SUM_4: usize = 31;

    #[test]
    fn test_parse() {
        assert_eq!(Packets::from(DATA_2), parse(CONTENT_2));
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(SUM_0, solution_1(&amp;mut Packets::from(DATA_0)));
        assert_eq!(SUM_1, solution_1(&amp;mut parse(CONTENT_1)));
        assert_eq!(SUM_2, solution_1(&amp;mut Packets::from(DATA_2)));
        assert_eq!(SUM_3, solution_1(&amp;mut parse(CONTENT_3)));
        assert_eq!(SUM_4, solution_1(&amp;mut parse(CONTENT_4)));
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(3, solution_2(&amp;mut parse("C200B40A82")));
        assert_eq!(7, solution_2(&amp;mut parse("880086C3E88112")));
        assert_eq!(1, solution_2(&amp;mut parse("9C0141080250320F1802104A08")));
    }
}</code></pre>
</div>
</div>
<a id="day17" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_17_rust"><a class="anchor" href="#_day_17_rust"></a><a class="link" href="#_day_17_rust">Day 17: rust</a></h3>
<div class="sect3">
<h4 id="_day_17_trick_shot"><a class="anchor" href="#_day_17_trick_shot"></a><a class="link" href="#_day_17_trick_shot">Day 17: Trick Shot</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/17">AoC|2021|17</a>.</p>
</div>
<div class="paragraph">
<p>Today it is about Projectile (or Probe) motion and calculating initial conditions to reach a target. I guess, it would be possible to calculate an analytical solution for both parts by solving quadratic equations and than re-constructing the integer solutions, but this is not the approach I took.</p>
</div>
<div class="paragraph">
<p>Note: My solution relies on the fact that the target lies to the right and below the starting point (the <em>below</em> part is actually important).</p>
</div>
<div class="sect4">
<h5 id="_part_1_12"><a class="anchor" href="#_part_1_12"></a><a class="link" href="#_part_1_12">Part 1</a></h5>
<div class="paragraph">
<p>For part 1, I only consider the <code>y</code>-coordinate. If the probe is sent off with some initial velocity <code>vy0</code>, it will come back to the initial <code>y</code> cordinate with velocity <code>-vy0-1</code> after some time. The next <code>y</code> coordinate seen is thus <code>vy0+1</code> units below the initial <code>y</code>-coordinate. If the initial velocity is chosen such that this coordinate is just within the target region, this yields the trajectory with the highest possible maximum. See the comments in the code below for some more details.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solution_1(target: (isize, isize, isize, isize)) -&gt; isize {
    let (x_min, x_max, y_min, y_max) = target;

    assert!(
        x_min &gt; 0 &amp;&amp; x_max &gt; x_min &amp;&amp; y_max &lt; 0 &amp;&amp; y_min &lt; y_max,
        "Solution assumes 0 &lt; x_min &lt; x_max and y_min &lt; y_max &lt; 0"
    );

    // max is reached if x coordinate ends up in target
    // for given initial velocity vy0
    //
    // the max is reached at step k = vy0
    // the max value is vy0 * (vy0 + 1) / 2
    //
    // at step k = 2 * vy0 + 1 the initial value y = 0 is reached again
    // with velocity vy = -vy0 - 1
    //
    // the next step reaches
    //   y = -vy0 - 1
    //
    // the highest max is reached, if y = -vy0 - 1 is just within the target
    // zone, i.e., if y_min = -vy0 - 1 or vy0 = -y_min - 1

    let vy0 = -y_min - 1;
    vy0 * (vy0 + 1) / 2
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, I also need to parse the input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">///
/// ```
/// # use mr_kaffee_2021_17::*;
/// assert_eq!((-1, 2, 0, 10), parse("target area: x=-1..2, y=0..10"));
/// ```
pub fn parse(content: &amp;str) -&gt; (isize, isize, isize, isize) {
    let mut parts = content.trim().split(", ");
    let lhs = parts.next().expect("No lhs");
    let rhs = parts.next().expect("No rhs");

    let x_range = lhs.split("=").skip(1).next().expect("No x range");
    let y_range = rhs.split("=").skip(1).next().expect("No y range");

    let mut x_parts = x_range.split("..");
    let mut y_parts = y_range.split("..");

    let x1 = x_parts
        .next()
        .expect("No x1")
        .parse()
        .expect("Cound not parse x1");
    let x2 = x_parts
        .next()
        .expect("No x2")
        .parse()
        .expect("Cound not parse x2");
    let y1 = y_parts
        .next()
        .expect("No y1")
        .parse()
        .expect("Cound not parse y1");
    let y2 = y_parts
        .next()
        .expect("No y2")
        .parse()
        .expect("Cound not parse y2");

    (x1, x2, y1, y2)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_12"><a class="anchor" href="#_part_2_12"></a><a class="link" href="#_part_2_12">Part 2</a></h5>
<div class="paragraph">
<p>In part 2, it is about figuring out which limits for the initial conditions to check. See the comments in the code for what I came up with.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solution_2(target: (isize, isize, isize, isize)) -&gt; usize {
    let (x_min, x_max, y_min, y_max) = target;

    assert!(
        x_min &gt; 0 &amp;&amp; x_max &gt; x_min &amp;&amp; y_max &lt; 0 &amp;&amp; y_min &lt; y_max,
        "Solution assumes 0 &lt; x_min &lt; x_max and y_min &lt; y_max &lt; 0"
    );

    // vx[0] = vx0
    // run for vx0 steps
    // end at vx0 + (vx0 - 1) + ... = vx0 * (vx0 + 1) / 2
    // find smallest absolute vx0 so that target is reached
    let mut vx_min = 0;
    while vx_min * (vx_min + 1) / 2 &lt;= x_min {
        vx_min += 1;
    }

    // if vx0 is above this value, the first step overshoots
    let vx_max = x_max;

    // if below, first step ends below target
    let vy_min = y_min;

    // max from part 1
    let vy_max = -y_min - 1;

    let mut count = 0;
    for vx in vx_min..=vx_max {
        for vy in vy_min..=vy_max {
            if is_target_reached(target, vx as usize, vy) {
                count += 1;
            }
        }
    }

    count
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For each candidate initial condition, I simulate the trajectory to check whether it reaches the target:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn is_target_reached(target: (isize, isize, isize, isize), vx: usize, vy: isize) -&gt; bool {
    let mut x = 0;
    let mut y = 0;
    let mut vx = vx as isize;
    let mut vy = vy;

    while (vy &gt; 0 || y &gt;= target.2) &amp;&amp; x &lt;= target.1 { // while target can be reached
        x = x + vx;
        y = y + vy;
        vx = if vx &gt; 0 { vx - 1 } else { vx };
        vy = vy - 1;

        if x &gt;= target.0 &amp;&amp; x &lt;= target.1 &amp;&amp; y &gt;= target.2 &amp;&amp; y &lt;= target.3 {
            return true;
        }
    }

    false
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_16"><a class="anchor" href="#_tests_16"></a><a class="link" href="#_tests_16">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "target area: x=20..30, y=-10..-5";
    const TEST_TARGET: (isize, isize, isize, isize) = (20, 30, -10, -5);

    #[test]
    fn test_parse() {
        assert_eq!(TEST_TARGET, parse(CONTENT));
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(45, solution_1(TEST_TARGET));
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(112, solution_2(TEST_TARGET));
    }

    #[test]
    fn test_is_target_reached() {
        let vs = &amp;[
            (23, -10),
            (25, -9),
            (27, -5),
            (29, -6),
            (22, -6),
            (21, -7),
            (9, 0),
            (27, -7),
            (24, -5),
            (25, -7),
            (26, -6),
            (25, -5),
            (6, 8),
            (11, -2),
            (20, -5),
            (29, -10),
            (6, 3),
            (28, -7),
            (8, 0),
            (30, -6),
            (29, -8),
            (20, -10),
            (6, 7),
            (6, 4),
            (6, 1),
            (14, -4),
            (21, -6),
            (26, -10),
            (7, -1),
            (7, 7),
            (8, -1),
            (21, -9),
            (6, 2),
            (20, -7),
            (30, -10),
            (14, -3),
            (20, -8),
            (13, -2),
            (7, 3),
            (28, -8),
            (29, -9),
            (15, -3),
            (22, -5),
            (26, -8),
            (25, -8),
            (25, -6),
            (15, -4),
            (9, -2),
            (15, -2),
            (12, -2),
            (28, -9),
            (12, -3),
            (24, -6),
            (23, -7),
            (25, -10),
            (7, 8),
            (11, -3),
            (26, -7),
            (7, 1),
            (23, -9),
            (6, 0),
            (22, -10),
            (27, -6),
            (8, 1),
            (22, -8),
            (13, -4),
            (7, 6),
            (28, -6),
            (11, -4),
            (12, -4),
            (26, -9),
            (7, 4),
            (24, -10),
            (23, -8),
            (30, -8),
            (7, 0),
            (9, -1),
            (10, -1),
            (26, -5),
            (22, -9),
            (6, 5),
            (7, 5),
            (23, -6),
            (28, -10),
            (10, -2),
            (11, -1),
            (20, -9),
            (14, -2),
            (29, -7),
            (13, -3),
            (23, -5),
            (24, -8),
            (27, -9),
            (30, -7),
            (28, -5),
            (21, -10),
            (7, 9),
            (6, 6),
            (21, -5),
            (27, -10),
            (7, 2),
            (30, -9),
            (21, -8),
            (22, -7),
            (24, -9),
            (20, -6),
            (6, 9),
            (29, -5),
            (8, -2),
            (27, -8),
            (30, -5),
            (24, -7),
        ];
        for (vx0, vy0) in vs {
            assert!(
                is_target_reached(TEST_TARGET, *vx0, *vy0),
                "Failed at {}, {}",
                vx0,
                vy0
            );
        }
    }
}</code></pre>
</div>
</div>
<a id="day18" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_18_rust"><a class="anchor" href="#_day_18_rust"></a><a class="link" href="#_day_18_rust">Day 18: rust</a></h3>
<div class="sect3">
<h4 id="_day_18_snailfish"><a class="anchor" href="#_day_18_snailfish"></a><a class="link" href="#_day_18_snailfish">Day 18: Snailfish</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/18">AoC|2021|18</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_13"><a class="anchor" href="#_part_1_13"></a><a class="link" href="#_part_1_13">Part 1</a></h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parse the snail numbers into vectors of tokens.</p>
</li>
<li>
<p>Implement functions that apply explode and split steps until no further reduction possible</p>
</li>
<li>
<p>Calculate the sum over all snail numbers</p>
</li>
<li>
<p>Calculate magnitude</p>
</li>
</ol>
</div>
<div class="sect5">
<h6 id="_parse_2"><a class="anchor" href="#_parse_2"></a><a class="link" href="#_parse_2">Parse</a></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// holds tokens of a snail number
#[derive(PartialEq, Eq, Debug, Clone, Copy)]
pub enum Token {
    Op,
    Cl,
    Val(usize),
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// # Examples
/// ```
/// # use mr_kaffee_2021_18::*;
/// assert_eq!(
///   vec![
///     vec![
///       Token::Op,
///       Token::Op,
///       Token::Val(0),
///       Token::Val(1),
///       Token::Cl,
///       Token::Val(1),
///       Token::Cl
///     ]
///   ],
///   parse("[[0,1],1]"));
/// ```
#[cfg(not(feature = "recursive"))]
pub fn parse(content: &amp;str) -&gt; Vec&lt;Vec&lt;Token&gt;&gt; {
    content
        .lines()
        .map(|line| {
            line.chars()
                .filter(|c| !c.is_whitespace() &amp;&amp; *c != ',')
                .map(|c| match c {
                    '[' =&gt; Token::Op,
                    ']' =&gt; Token::Cl,
                    '0'..='9' =&gt; Token::Val(c as usize - '0' as usize),
                    _ =&gt; panic!("Unexpected character: {}", c),
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        })
        .collect()
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_reduction"><a class="anchor" href="#_reduction"></a><a class="link" href="#_reduction">Reduction</a></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// perform single explode
///
/// returns true if any explode performed, otherwise false
pub fn explode(snail: &amp;mut Vec&lt;Token&gt;) -&gt; bool {
    let mut level = 0;
    let mut last_val = 0;
    let mut number_seen = false;
    for k in 0..snail.len() {
        match snail[k] {
            Token::Op =&gt; {
                number_seen = false;
                level += 1;
            }
            Token::Cl =&gt; {
                number_seen = false;
                level -= 1;
            }
            Token::Val(val) =&gt; {
                if number_seen &amp;&amp; level == 5 {
                    if let Some((j, x)) = (0..k - 2).rev().find_map(|j| {
                        if let Token::Val(v) = snail[j] {
                            Some((j, v))
                        } else {
                            None
                        }
                    }) {
                        snail[j] = Token::Val(x + last_val);
                    }

                    if let Some((j, x)) = (k + 2..snail.len()).find_map(|j| {
                        if let Token::Val(v) = snail[j] {
                            Some((j, v))
                        } else {
                            None
                        }
                    }) {
                        snail[j] = Token::Val(x + val);
                    }

                    // remove elements k-1, k, k+1
                    snail.drain(k - 1..k + 2);
                    snail[k - 2] = Token::Val(0);

                    return true;
                } else {
                    last_val = val;
                    number_seen = true;
                }
            }
        }
    }

    false
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// perform single split
///
/// returns true if any split performed, otherwise false
pub fn split(snail: &amp;mut Vec&lt;Token&gt;) -&gt; bool {
    if let Some((k, v)) = snail.iter().enumerate().find_map(|(k, e)| {
        if let Token::Val(v) = e {
            if v &gt; &amp;9 {
                Some((k, v))
            } else {
                None
            }
        } else {
            None
        }
    }) {
        let a = v &gt;&gt; 1;
        let b = v - a;
        snail.splice(
            k..k + 1,
            [Token::Op, Token::Val(a), Token::Val(b), Token::Cl],
        );

        true
    } else {
        false
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// reduce snail number
pub fn reduce(snail: &amp;mut Vec&lt;Token&gt;) {
    while explode(snail) || split(snail) {}
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_sum_magnitude"><a class="anchor" href="#_sum_magnitude"></a><a class="link" href="#_sum_magnitude">Sum &amp; Magnitude</a></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// calculate sum over snailnumbers at given indices
pub fn sum(snail: &amp;[Vec&lt;Token&gt;], mut indices: impl Iterator&lt;Item = usize&gt;) -&gt; Vec&lt;Token&gt; {
    let mut sum = snail[indices.next().expect("Empty indices")].to_owned();
    for k in indices {
        sum.insert(0, Token::Op);
        for e in &amp;snail[k] {
            sum.push(*e);
        }
        sum.push(Token::Cl);
        reduce(&amp;mut sum);
    }
    sum
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// recursively calculate magnitude for snailnumber at given position
///
/// returns magnitude and position
pub fn magnitude(snail: &amp;[Token], k: usize) -&gt; (usize, usize) {
    let (a, j) = match snail[k + 1] {
        Token::Op =&gt; magnitude(&amp;snail, k + 1),
        Token::Val(v) =&gt; (v, k + 2),
        Token::Cl =&gt; panic!("Unexpected close tag at {}", k + 1),
    };
    let (b, j) = match snail[j] {
        Token::Op =&gt; magnitude(&amp;snail, j),
        Token::Val(v) =&gt; (v, j + 1),
        Token::Cl =&gt; panic!("Unexpected close tag at {}", j),
    };

    (3 * a + 2 * b, j + 1)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_13"><a class="anchor" href="#_part_2_13"></a><a class="link" href="#_part_2_13">Part 2</a></h5>
<div class="paragraph">
<p>Simple extension</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(not(feature = "recursive"))]
pub fn solution_2(snails: &amp;[Vec&lt;Token&gt;]) -&gt; usize {
    let mut max = 0;
    for k1 in 0..snails.len() {
        for k2 in 0..snails.len() {
            if k1 == k2 {
                continue;
            }

            let sum = sum(snails, [k1, k2].into_iter());
            let (m, _) = magnitude(&amp;sum, 0);
            if m &gt; max {
                max = m;
            }
        }
    }

    max
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_17"><a class="anchor" href="#_tests_17"></a><a class="link" href="#_tests_17">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_explode() {
        let mut snails = parse("[[[[[9,8],1],2],3],4]\n[[[[0,9],2],3],4]");
        assert!(explode(&amp;mut snails[0]), "Did not explode");
        assert_eq!(snails[0], snails[1]);

        let mut snails =
            parse("[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\n[[[[0,7],4],[7,[[8,4],9]]],[1,1]]");
        assert!(explode(&amp;mut snails[0]));
        assert_eq!(snails[0], snails[1]);
    }

    #[test]
    fn test_split() {
        let mut snails = vec![
            vec![
                Token::Op,
                Token::Op,
                Token::Val(1),
                Token::Val(15),
                Token::Cl,
                Token::Val(11),
                Token::Cl,
            ],
            vec![
                Token::Op,
                Token::Op,
                Token::Val(1),
                Token::Op,
                Token::Val(7),
                Token::Val(8),
                Token::Cl,
                Token::Cl,
                Token::Val(11),
                Token::Cl,
            ],
        ];
        assert!(split(&amp;mut snails[0]), "Did not split");
        assert_eq!(snails[0], snails[1]);
    }

    #[test]
    fn test_reduce() {
        let mut snails =
            parse("[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\n[[[[0,7],4],[[7,8],[6,0]]],[8,1]]");

        reduce(&amp;mut snails[0]);
        assert_eq!(snails[0], snails[1]);
    }

    #[test]
    fn test_sum() {
        let snails = parse(
            "[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]
[[[5,[2,8]],4],[5,[[9,9],0]]]
[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]
[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]
[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]
[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]
[[[[5,4],[7,7]],8],[[8,3],8]]
[[9,3],[[9,9],[6,[4,9]]]]
[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]
[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]",
        );

        let sum = sum(&amp;snails, 0..snails.len());
        assert_eq!(
            parse("[[[[6,6],[7,6]],[[7,7],[7,0]]],[[[7,7],[7,7]],[[7,8],[9,9]]]]")[0],
            sum
        );
    }

    #[test]
    fn test_magnitude() {
        let snails = parse("[[[[6,6],[7,6]],[[7,7],[7,0]]],[[[7,7],[7,7]],[[7,8],[9,9]]]]");
        let (m, j) = magnitude(&amp;snails[0], 0);
        assert_eq!(4140, m);
        assert_eq!(snails[0].len(), j);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_thoughts"><a class="anchor" href="#_thoughts"></a><a class="link" href="#_thoughts">Thoughts</a></h5>
<div class="paragraph">
<p>The structure calls for a recursive data structure. I might give it a try later on.</p>
</div>
<div class="paragraph">
<p>For now, the puzzle is solved. Not a solution I am particularly proud of. Specifically, I don&#8217;t like that it increases the overall runtime for all my solutions for this year so far by 40%!</p>
</div>
<div class="paragraph">
<p>I have a solution based on recursive data structures. It is three times slower&#8230;&#8203; Made some small optimizations in the vec based solution instead (use <code>drain</code> and <code>splice</code> instead of removing/inserting values one by one - see above).</p>
</div>
<div class="paragraph">
<p>The recursive solution is also available as a variant and you can run the recursive solution with <code>cargo run --release --features recursive</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    #[derive(Clone, PartialEq, Eq)]
    pub enum Snail {
        Val(usize),
        Pair(Box&lt;Snail&gt;, Box&lt;Snail&gt;),
    }

    impl fmt::Display for Snail {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            match self {
                Self::Val(v) =&gt; write!(f, "{}", v),
                Self::Pair(lhs, rhs) =&gt; write!(f, "[{},{}]", lhs, rhs),
            }
        }
    }

    impl fmt::Debug for Snail {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            match self {
                Self::Val(v) =&gt; write!(f, "{}", v),
                Self::Pair(lhs, rhs) =&gt; write!(f, "[{:?},{:?}]", lhs, rhs),
            }
        }
    }

    impl Snail {
        /// parse a string representation of a snail number
        ///
        /// # Examples
        /// ```
        /// # use mr_kaffee_2021_18::recursive::*;
        /// let snail = Snail::parse("[[1,2]\n, 3]");
        /// assert_eq!("[[1,2],3]", format!("{}", snail));
        /// ```
        pub fn parse(data: &amp;str) -&gt; Self {
            Self::parse_recursive(&amp;mut data.chars().filter(|c| !c.is_whitespace()).peekable())
        }

        fn parse_recursive(data: &amp;mut Peekable&lt;impl Iterator&lt;Item = char&gt;&gt;) -&gt; Self {
            let token = data.next();
            match token {
                Some('[') =&gt; {
                    let lhs = Self::parse_recursive(data);
                    assert_eq!(Some(','), data.next());
                    let rhs = Self::parse_recursive(data);
                    assert_eq!(Some(']'), data.next());
                    Self::Pair(Box::new(lhs), Box::new(rhs))
                }
                Some(c) if c &gt;= '0' &amp;&amp; c &lt;= '9' =&gt; {
                    let mut v = c as usize - '0' as usize;
                    while let Some(d) = data
                        .peek()
                        .filter(|c| c.is_ascii_digit())
                        .map(|c| *c as usize - '0' as usize)
                    {
                        data.next();
                        v = 10 * v + d;
                    }
                    Self::Val(v)
                }
                _ =&gt; panic!("Unexpected token: {:?}", token),
            }
        }

        fn increment_first(&amp;mut self, inc: usize) {
            match self {
                Self::Pair(lhs, _) =&gt; {
                    if let Self::Val(val) = *lhs.as_ref() {
                        let _ = std::mem::replace(lhs, Box::new(Self::Val(val + inc)));
                    } else {
                        lhs.increment_first(inc);
                    }
                }
                _ =&gt; {}
            }
        }

        fn increment_last(&amp;mut self, inc: usize) {
            match self {
                Self::Pair(_, rhs) =&gt; {
                    if let Self::Val(val) = *rhs.as_ref() {
                        let _ = std::mem::replace(rhs, Box::new(Self::Val(val + inc)));
                    } else {
                        rhs.increment_last(inc);
                    }
                }
                _ =&gt; {}
            }
        }

        fn explode(&amp;mut self, level: usize) -&gt; (Option&lt;Self&gt;, Option&lt;(usize, usize)&gt;) {
            match self {
                Self::Val(_) =&gt; (None, None),
                Self::Pair(lhs, rhs) =&gt; {
                    if level == 4 {
                        if let (Self::Val(a), Self::Val(b)) = (lhs.as_ref(), rhs.as_ref()) {
                            (Some(Self::Val(0)), Some((*a, *b)))
                        } else {
                            (None, None)
                        }
                    } else if level &lt; 4 {
                        if let (replace, Some((a, b))) = lhs.explode(level + 1) {
                            if let Self::Val(val) = *rhs.as_ref() {
                                // increment rhs with b
                                let _ = std::mem::replace(rhs, Box::new(Self::Val(val + b)));
                            } else {
                                // increment first number in rhs with b
                                rhs.increment_first(b);
                            }

                            if let Some(replace) = replace {
                                // replace exploded value
                                let _ = std::mem::replace(lhs, Box::new(replace));
                            }
                            (None, Some((a, 0)))
                        } else if let (replace, Some((a, b))) = rhs.explode(level + 1) {
                            if let Self::Val(val) = *lhs.as_ref() {
                                // increment lhs with a
                                let _ = std::mem::replace(lhs, Box::new(Self::Val(val + a)));
                            } else {
                                // increment last number in lhs with a
                                lhs.increment_last(a);
                            }

                            if let Some(replace) = replace {
                                // replace exploded value
                                let _ = std::mem::replace(rhs, Box::new(replace));
                            }

                            (None, Some((0, b)))
                        } else {
                            (None, None)
                        }
                    } else {
                        (None, None)
                    }
                }
            }
        }

        fn split(&amp;mut self) -&gt; bool {
            if let Self::Pair(lhs, rhs) = self {
                if let Self::Val(val) = lhs.as_ref() {
                    if val &gt; &amp;9 {
                        let a = Box::new(Self::Val(val &gt;&gt; 1));
                        let b = Box::new(Self::Val((val &gt;&gt; 1) + (val &amp; 1)));
                        let _ = std::mem::replace(lhs, Box::new(Self::Pair(a, b)));
                        return true;
                    }
                }
                if lhs.split() {
                    return true;
                }
                if let Self::Val(val) = rhs.as_ref() {
                    if val &gt; &amp;9 {
                        let a = Box::new(Self::Val(val &gt;&gt; 1));
                        let b = Box::new(Self::Val((val &gt;&gt; 1) + (val &amp; 1)));
                        let _ = std::mem::replace(rhs, Box::new(Self::Pair(a, b)));
                        return true;
                    }
                }
                return rhs.split();
            }

            false
        }

        pub fn reduce(&amp;mut self) {
            loop {
                let (_, r) = self.explode(0);
                if r.is_none() &amp;&amp; !self.split() {
                    break;
                }
            }
        }

        pub fn add(&amp;self, other: &amp;Snail) -&gt; Self {
            let mut sum = Self::Pair(Box::new(self.clone()), Box::new(other.clone()));
            sum.reduce();
            sum
        }

        pub fn magnitude(&amp;self) -&gt; usize {
            match self {
                Self::Val(v) =&gt; *v,
                Self::Pair(a, b) =&gt; 3 * a.magnitude() + 2 * b.magnitude(),
            }
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_9"><a class="anchor" href="#_today_i_learned_9"></a><a class="link" href="#_today_i_learned_9">Today I learned</a></h5>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>a lot on recursive data structures and the <code>Box</code> structure in Rust but also how to insert / remove elements from a <code>Vec</code> as efficiently as possible.</p>
</li>
</ol>
</div>
<a id="day19" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_19_rust"><a class="anchor" href="#_day_19_rust"></a><a class="link" href="#_day_19_rust">Day 19: rust</a></h3>
<div class="sect3">
<h4 id="_day_19_beacon_scanner"><a class="anchor" href="#_day_19_beacon_scanner"></a><a class="link" href="#_day_19_beacon_scanner">Day 19: Beacon Scanner</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/19">AoC|2021|19</a>.</p>
</div>
<div class="paragraph">
<p>The solution for today&#8217;s puzzle takes ~180ms to complete in my current implementation (optimized from 30 seconds in the first version to ~10 and ~3 seconds in intermediate steps).</p>
</div>
<div class="paragraph">
<p>The optimizations to get down to three seconds include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>check for the bounding box (scanner range) before looking up whether a specific beacon exists in another set</p>
</li>
<li>
<p>use a kind of breadth first search for checking overlaps: start with first set, enqueue all sets which overlap with the first set (set <code>settled = 1</code>) and continue to settle furhter sets that overlap with sets from the queue.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The final optimization to achieve solution times below 1s are taken from <a href="https://github.com/mogron">[Moritz Gronbach</a>: The distances between beacons are invariant under coordinate transformations. So if two scanners have overlapping ranges, they must have at least 12 beacons which have to same distances to each other. Comparing those distances is much cheaper than looping through all the transformations and comparing coordinates.</p>
</div>
<div class="sect4">
<h5 id="_parts_1_2_2"><a class="anchor" href="#_parts_1_2_2"></a><a class="link" href="#_parts_1_2_2">Parts 1 &amp; 2</a></h5>
<div class="paragraph">
<p>To keep the code clean, I created some shortcuts for 3D coordinates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// type alias for 3D coordinate
pub type Coord = (isize, isize, isize);

/// basic math operations for coordinates
pub trait CoordMath {
    fn add(self, rhs: &amp;Self) -&gt; Self;
    fn sub(self, rhs: &amp;Self) -&gt; Self;
    fn abs(&amp;self) -&gt; usize;
}

impl CoordMath for Coord {
    fn add(mut self, rhs: &amp;Self) -&gt; Self {
        self.0 += rhs.0;
        self.1 += rhs.1;
        self.2 += rhs.2;
        self
    }

    fn sub(mut self, rhs: &amp;Self) -&gt; Self {
        self.0 -= rhs.0;
        self.1 -= rhs.1;
        self.2 -= rhs.2;
        self
    }

    fn abs(&amp;self) -&gt; usize {
        (self.0.abs() + self.1.abs() + self.2.abs()) as usize
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The input is read as follows (create sets of beacons and maps of pairwise distances):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse the input into a vector of scanners
///
/// each scanner is a hash set of coordinates in the scanner's local
/// coordinate system and a hashmap of pairwise distances as keys and number of
/// occurance of this distance as value
pub fn parse(content: &amp;str) -&gt; Vec&lt;(HashSet&lt;Coord&gt;, HashMap&lt;usize, usize&gt;)&gt; {
    let mut scanners: Vec&lt;(HashSet&lt;Coord&gt;, HashMap&lt;usize, usize&gt;)&gt; = Vec::new();

    let mut beacons = HashSet::new();
    let mut distances = HashMap::new();
    for line in content.lines().map(|l| l.trim()).filter(|l| l.len() &gt; 0) {
        if line.starts_with("---") {
            if !beacons.is_empty() {
                scanners.push((beacons, distances));
                beacons = HashSet::new();
                distances = HashMap::new();
            }
        } else {
            let mut parts = line.split(',');
            let b_new = (
                parts.next().unwrap().parse().unwrap(),
                parts.next().unwrap().parse().unwrap(),
                parts.next().unwrap().parse().unwrap(),
            );
            for b_old in &amp;beacons {
                // update pairwise distances
                *distances.entry(b_old.sub(&amp;b_new).abs()).or_insert(0) += 1;
            }
            beacons.insert(b_new);
        }
    }
    if !beacons.is_empty() {
        scanners.push((beacons, distances));
    }

    scanners
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then I define all 24 possible transformations with inverse transformations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// transformation functions for all 24 possible transformations
pub const TRAFOS: [fn(Coord) -&gt; Coord; 24] = [
    |(x, y, z)| (x, y, z),
    |(x, y, z)| (x, -y, -z),
    |(x, y, z)| (x, z, -y),
    |(x, y, z)| (x, -z, y),
    |(x, y, z)| (-x, y, -z),
    |(x, y, z)| (-x, -y, z),
    |(x, y, z)| (-x, z, y),
    |(x, y, z)| (-x, -z, -y),
    |(x, y, z)| (y, x, -z),
    |(x, y, z)| (y, -x, z),
    |(x, y, z)| (y, z, x),
    |(x, y, z)| (y, -z, -x),
    |(x, y, z)| (-y, x, z),
    |(x, y, z)| (-y, -x, -z),
    |(x, y, z)| (-y, z, -x),
    |(x, y, z)| (-y, -z, x),
    |(x, y, z)| (z, x, y),
    |(x, y, z)| (z, -x, -y),
    |(x, y, z)| (z, y, -x),
    |(x, y, z)| (z, -y, x),
    |(x, y, z)| (-z, x, -y),
    |(x, y, z)| (-z, -x, y),
    |(x, y, z)| (-z, y, x),
    |(x, y, z)| (-z, -y, -x),
];

/// inverse transformation functions for all 24 possible transformations
pub const INV_TRAFOS: [fn(Coord) -&gt; Coord; 24] = [
    |(x, y, z)| (x, y, z),
    |(x, y, z)| (x, -y, -z),
    |(x, y, z)| (x, -z, y),
    |(x, y, z)| (x, z, -y),
    |(x, y, z)| (-x, y, -z),
    |(x, y, z)| (-x, -y, z),
    |(x, y, z)| (-x, z, y),
    |(x, y, z)| (-x, -z, -y),
    |(x, y, z)| (y, x, -z),
    |(x, y, z)| (-y, x, z),
    |(x, y, z)| (z, x, y),
    |(x, y, z)| (-z, x, -y),
    |(x, y, z)| (y, -x, z),
    |(x, y, z)| (-y, -x, -z),
    |(x, y, z)| (-z, -x, y),
    |(x, y, z)| (z, -x, -y),
    |(x, y, z)| (y, z, x),
    |(x, y, z)| (-y, -z, x),
    |(x, y, z)| (-z, y, x),
    |(x, y, z)| (z, -y, x),
    |(x, y, z)| (y, -z, -x),
    |(x, y, z)| (-y, z, -x),
    |(x, y, z)| (z, y, -x),
    |(x, y, z)| (-z, -y, -x),
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transformations are used to figure out whether two scanner&#8217;s ranges (two sets of beacons in their own coordinate systems) overlap:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// check whether two sets of beacons overlap
///
/// find the transformation ``t`` for the ``beacons_check`` set, and the ``center`` position
/// of the corresponding scanner in the ``beacons_settled``'s coordinate system so that at
/// least ``threshold`` pairs of beacons (b1, b2) in the two sets exist that satisfy
/// ``t(b2) - center = b1``
///
/// return the transformation ``t`` and the ``center`` position
pub fn check_overlap(
    (beacons_settled, distances_settled): &amp;(HashSet&lt;Coord&gt;, HashMap&lt;usize, usize&gt;),
    (beacons_check, distances_check): &amp;(HashSet&lt;Coord&gt;, HashMap&lt;usize, usize&gt;),
    threshold: usize,
) -&gt; Option&lt;(fn(Coord) -&gt; Coord, Coord)&gt; {
    // first check pairwise distances (idea taken from Moritz Gronbach, https://github.com/mogron)
    let mut common_distances = 0;
    for (distance, count) in distances_settled {
        common_distances += cmp::min(distances_check.get(distance).unwrap_or(&amp;0), count);
        if common_distances &gt;= threshold * (threshold - 1) / 2 {
            break;
        }
    }
    if common_distances &lt; threshold * (threshold - 1) / 2 {
        return None; // not enough common distances, no overlap possible
    }

    for t_idx in 0..24 {
        // find all beacons with the same distance as b1[k1] to b2[k2]
        for b1 in beacons_settled {
            for b2 in beacons_check {
                // center = t(b2) - b1
                // =&gt; b1 = t(b2) - center
                let center = TRAFOS[t_idx](*b2).sub(b1);

                // filter for scanner range prior to lookup
                // settled beacons are in transformed coordinate (scanner is not necessarily at origin)
                // =&gt; need to check range in beacons_check via inverse transform
                // (possible optimization: use actual bounding box of beacons)
                let mut count = 0;
                for _ in beacons_settled
                    .iter()
                    .map(|b1| INV_TRAFOS[t_idx](b1.add(&amp;center)))
                    .filter(|(x, y, z)| RANGE.contains(x) &amp;&amp; RANGE.contains(y) &amp;&amp; RANGE.contains(z))
                    .filter(|b1| beacons_check.contains(b1))
                {
                    // don't use iter.count() to avoid checking more elements once threshold is reached
                    count += 1;
                    if count &gt;= threshold {
                        return Some((TRAFOS[t_idx], center));
                    }
                }
            }
        }
    }

    None // no solution found
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With these elements, the solution to both parts is calculated as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// determine number of unique beacons and max Manhatten distance between
/// any two scanners
pub fn solution_1_2(scanners: &amp;[(HashSet&lt;Coord&gt;, HashMap&lt;usize, usize&gt;)]) -&gt; (usize, usize) {
    // use my own mutable copy of the scanners
    let mut scanners = scanners.to_owned();

    // holds flags for settled scanners
    // 0 - not settled
    // 1 - settled, enqueued for furhter extension of settled scanners
    // 2 - fully processed (dequeued)
    let mut settled = vec![0; scanners.len()];
    settled[0] = 1u8; // start with first scanner settled

    // holds scanner coordinates in the coordinate system of the settled scanners.
    // Used to calculate largest distance between any two scanners.
    let mut centers = Vec::with_capacity(scanners.len());
    centers.push((0, 0, 0)); // first scanner's position (= reference)
    let mut max_dist = 0;

    // holds all settled beacons. Start with beacons in range of scanner 1
    let mut beacons: HashSet&lt;Coord&gt; = scanners[0].0.clone();

    while let Some(k1) = settled.iter().position(|s| s == &amp;1) {
        for k2 in 0..settled.len() {
            if settled[k2] != 0 {
                continue; // already settled
            }

            if let Some((t, c)) = check_overlap(&amp;scanners[k1], &amp;scanners[k2], 12) {
                // update scanner to settled coordinates
                scanners[k2].0 = scanners[k2].0.iter().map(|b| t(*b).sub(&amp;c)).collect();

                // add beacons to unique set
                beacons.extend(&amp;scanners[k2].0);

                // update settled to 1 = enqueue
                settled[k2] = 1;

                // update max distance
                for c_settled in &amp;centers {
                    let dist = c.sub(&amp;c_settled).abs();
                    if dist &gt; max_dist {
                        max_dist = dist;
                    }
                }

                // add center
                centers.push(c);
            }
        }

        // update settled to 2 = fully processed
        settled[k1] = 2;
    }

    // return number of beacons and largest distance between any two scanners
    (beacons.len(), max_dist)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_18"><a class="anchor" href="#_tests_18"></a><a class="link" href="#_tests_18">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = include_str!("../test.txt");

    #[test]
    fn test_parse() {
        let scanners = parse(CONTENT);
        assert_eq!(5, scanners.len());
        assert!(scanners[2].0.contains(&amp;(-644, 584, -595)));
        assert!(scanners[4].0.contains(&amp;(30, -46, -14)));
    }

    #[test]
    fn test_compare() {
        let scanners = parse(CONTENT);
        let r = check_overlap(&amp;scanners[0], &amp;scanners[1], 12);
        assert!(r.is_some(), "No transformation found");
        let (t, d) = r.unwrap();

        assert_eq!((-68, 1246, 43), d);
        assert_eq!((-618, -824, -621), t((686, 422, 578)).sub(&amp;d));
    }

    #[test]
    fn test_solution_1_2() {
        let scanners = parse(CONTENT);
        assert_eq!((79, 3621), solution_1_2(&amp;scanners));
    }

    #[test]
    fn test_trafos() {
        for k in 0..24 {
            assert_eq!(
                (1, 2, 3),
                TRAFOS[k](INV_TRAFOS[k]((1, 2, 3))),
                "Failed trafo after inverse at {}",
                k
            );
            assert_eq!(
                (1, 2, 3),
                INV_TRAFOS[k](TRAFOS[k]((1, 2, 3))),
                "Failed inverse after trafo at {}",
                k
            );
        }
    }
}</code></pre>
</div>
</div>
<a id="day20" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_20_rust"><a class="anchor" href="#_day_20_rust"></a><a class="link" href="#_day_20_rust">Day 20: rust</a></h3>
<div class="sect3">
<h4 id="_day_20_trench_map"><a class="anchor" href="#_day_20_trench_map"></a><a class="link" href="#_day_20_trench_map">Day 20: Trench Map</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/20">AoC|2021|20</a>.</p>
</div>
<div class="paragraph">
<p>There is essentially one trap in today&#8217;s puzzle hidden in the instruction <em>&#8230;&#8203; being careful to account for the infinite size of the images</em>: while in the test data, the algorithm starts with <code>.</code>, my (and I guess everyone else&#8217;s) puzzle input&#8217;s algorithm starts with <code>#</code>. Hence, after applying the algorithm once, all pixels extending forever in any direction are set. To handle this, I store the negative of an image in that case. All images produced by odd numbers of update steps will actually be negative images.</p>
</div>
<div class="sect4">
<h5 id="_parts_1_2_3"><a class="anchor" href="#_parts_1_2_3"></a><a class="link" href="#_parts_1_2_3">Parts 1 &amp; 2</a></h5>
<div class="paragraph">
<p>I store images in an <code>Image</code> structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// structure storing image data
///
/// * ``data`` is a list of all set pixels
/// * ``bbox = (x_min, x_max, y_min, y_max)`` is the bounding box of set pixels
///   with exclusive upper bounds
/// * ``neg`` is a flag indicating whether pixels are inverted (i.e., this is a
///   negative image)
#[derive(Debug, Clone)]
pub struct Image {
    pub data: Vec&lt;(isize, isize)&gt;,
    pub bbox: (isize, isize, isize, isize),
    pub neg: bool,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I use this to parse the input into an algorithm (vector of booleans) and an image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse content in algorithm (first line) and image (other non blank lines)
pub fn parse(content: &amp;str) -&gt; (Vec&lt;bool&gt;, Image) {
    let mut lines = content.lines();
    let algo = lines
        .next()
        .expect("No algo")
        .trim()
        .chars()
        .map(|c| c == '#')
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // if algo[0] is set, all pixels extendig in any direction are lit after the first step
    // to ensure a finite number of pixels is lit after an odd number of steps, the last element
    // of the algorithm must not be set
    assert!(
        !algo[0] || !algo[algo.len() - 1],
        "Algorithm will lit infinitely many pixels forever"
    );

    let mut data = Vec::new();
    let mut bbox = (isize::MAX, isize::MAX, isize::MIN, isize::MIN);
    let neg = false;
    for (y, line) in lines
        .map(|line| line.trim())
        .filter(|line| line.len() &gt; 0)
        .enumerate()
    {
        for (x, _) in line.chars().enumerate().filter(|(_, c)| c == &amp;'#') {
            data.push((x as isize, y as isize));
            bbox.0 = cmp::min(bbox.0, x as isize);
            bbox.1 = cmp::min(bbox.1, y as isize);
            bbox.2 = cmp::max(bbox.2, x as isize + 1);
            bbox.3 = cmp::max(bbox.3, y as isize + 1);
        }
    }

    (algo, Image { data, bbox, neg })
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main part of the solution is a function that performs single update steps (see <a href="#day20-til">Today I learned</a> for an explanation on why I create the intermediate <code>grid</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// perform single update step
///
/// create a new image; if ``algo[0]`` is set, the ``neg`` flag of the image will flip
pub fn update_step(algo: &amp;[bool], image: &amp;Image) -&gt; Image {
    let mut data = Vec::with_capacity(image.data.len() * 2);
    let mut bbox = (isize::MAX, isize::MAX, isize::MIN, isize::MIN);
    let neg = algo[0] ^ image.neg;

    // it is cheaper to put everything in a grid compared to looking up values repeatedly
    // in a set or map
    // make the grid big enough to not have to check out of bounds in loop later on
    let (x_mn, y_mn, x_mx, y_mx) = image.bbox;
    let x0 = x_mn - 2;
    let y0 = y_mn - 2;
    let w = (x_mx - x_mn) as usize + 4;
    let h = (y_mx - y_mn) as usize + 4;
    let mut grid = vec![false; w * h];
    for (x, y) in &amp;image.data {
        grid[(x - x0) as usize + w * (y - y0) as usize] = true;
    }

    for x in x_mn - 1..x_mx + 1 {
        for y in y_mn - 1..y_mx + 1 {
            let k = (x - x0) as usize + w * (y - y0) as usize;
            let mut idx = 0;
            for j in [
                k - w - 1,
                k - w,
                k - w + 1,
                k - 1,
                k,
                k + 1,
                k + w - 1,
                k + w,
                k + w + 1,
            ] {
                idx = idx &lt;&lt; 1 | (image.neg ^ grid[j]) as usize;
            }
            if neg ^ algo[idx] {
                data.push((x, y));
                bbox.0 = cmp::min(bbox.0, x);
                bbox.1 = cmp::min(bbox.1, y);
                bbox.2 = cmp::max(bbox.2, x + 1);
                bbox.3 = cmp::max(bbox.3, y + 1);
            }
        }
    }

    Image { data, bbox, neg }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is calculated as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn update_steps(algo: &amp;[bool], image: &amp;Image, steps: usize) -&gt; Image {
    assert!(steps &gt;= 1, "Cannot perform less than one update step");
    let mut image = update_step(&amp;algo, image);
    for _ in 1..steps {
        image = update_step(algo, &amp;image);
    }
    image
}

pub fn solution_1(algo: &amp;[bool], image: &amp;Image) -&gt; usize {
    update_steps(algo, image, 2).data.len()
}
pub fn solution_2(algo: &amp;[bool], image: &amp;Image) -&gt; usize {
    update_steps(algo, image, 50).data.len()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_19"><a class="anchor" href="#_tests_19"></a><a class="link" href="#_tests_19">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str =
        "..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##\
        #..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###\
        .######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#.\
        .#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#.....\
        .#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#..\
        ...####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.....\
        ..##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#\n\
        \
        #..#.\n\
        #....\n\
        ##..#\n\
        ..#..\n\
        ..###";

    #[test]
    fn test_parse() {
        let (algo, image) = parse(CONTENT);
        assert_eq!(512, algo.len());
        assert_eq!((0, 0, 5, 5), image.bbox);
        assert_eq!(
            Vec::from([
                (0, 0),
                (3, 0),
                (0, 1),
                (0, 2),
                (1, 2),
                (4, 2),
                (2, 3),
                (2, 4),
                (3, 4),
                (4, 4)
            ]),
            image.data
        );
        assert!(!image.neg);
    }

    #[test]
    fn test_update_steps() {
        let (algo, image) = parse(CONTENT);
        assert_eq!(35, update_steps(&amp;algo, &amp;image, 2).data.len());
        assert_eq!(3_351, update_steps(&amp;algo, &amp;image, 50).data.len());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="day20-til"><a class="anchor" href="#day20-til"></a><a class="link" href="#day20-til">Today I learned</a></h5>
<div class="paragraph">
<p>Today I learned a lot about performance.</p>
</div>
<div class="paragraph">
<p>In my first version, I stored the lit pixels of the image in a hash set with <code>HashSet::contains</code> calls in the nested loop in my <code>update_step</code> function. Building a <code>grid</code> for direct lookup and replacing the hash set by a vector reduced the runtime for my solution (both parts) from ~500ms to ~25ms by a factor of 20! Pretty impressive.</p>
</div>
<a id="day21" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_21_rust"><a class="anchor" href="#_day_21_rust"></a><a class="link" href="#_day_21_rust">Day 21: rust</a></h3>
<div class="sect3">
<h4 id="_day_21_dirac_dice"><a class="anchor" href="#_day_21_dirac_dice"></a><a class="link" href="#_day_21_dirac_dice">Day 21: Dirac Dice</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/21">AoC|2021|21</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_14"><a class="anchor" href="#_part_1_14"></a><a class="link" href="#_part_1_14">Part 1</a></h5>
<div class="paragraph">
<p>Part 1 is pretty straight forward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// play with a deterministic dice, winning threshold: 1000
///
/// return the looser's score times the number the dice was thrown
pub fn solution_1((mut p1, mut p2): (usize, usize)) -&gt; usize {
    let mut s1 = 0;
    let mut s2 = 0;

    let mut dice = 0;

    let mut t = true;
    while s1 &lt; 1000 &amp;&amp; s2 &lt; 1000 {
        if t {
            p1 = (p1 + 3 * dice + 6 - 1) % 10 + 1;
            s1 += p1;
        } else {
            p2 = (p2 + 3 * dice + 6 - 1) % 10 + 1;
            s2 += p2;
        }

        dice += 3;
        t = !t;
    }

    dice * cmp::min(s1, s2)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_14"><a class="anchor" href="#_part_2_14"></a><a class="link" href="#_part_2_14">Part 2</a></h5>
<div class="paragraph">
<p>For part 2, my first attempt was to use a depth first traversal through play states. I push play states with multiplicities on a stack.</p>
</div>
<div class="paragraph">
<p>Each state popped from the stack results in 7 new states for the seven different outcomes of throwing a 3-sided dice three times: (1 x 3, 3 x 4, 6 x 5, 7 x 6, 6 x 7, 3 x 8, 1 x 9).</p>
</div>
<div class="paragraph">
<p>If a state is a win for either player, the win counter is increased. Otherwise the new state with the new multiplicity is pushed to the stack.</p>
</div>
<div class="paragraph">
<p>I came up with the idea quite quickly. Still took some time to finish part 2 because of a stupid bug: I updated position and score for the 2nd, 3rd, &#8230;&#8203; outcome of throwing a dice not based on the current state but based on the 1st, 2nd, &#8230;&#8203; outcome of throwing a dice&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// 7 possible outcomes with three dice
///
/// * 3 - 1: (1 1 1)
/// * 4 - 3: (1 1 2) (1 2 1) (2 1 1)
/// * 5 - 6: (1 1 3) (1 2 2) (1 3 1) (2 1 2) (2 2 1) (3 1 1)
/// * 6 - 7: (1 2 3) (1 3 2) (2 1 3) (2 2 2) (2 3 1) (3 1 2) (3 2 1)
/// * 7 - 6: (1 3 3) (2 2 3) (2 3 2) (3 1 3) (3 2 2) (3 3 1)
/// * 8 - 3: (2 3 3) (3 2 3) (3 3 2)
/// * 9 - 1: (3 3 3)
pub const DICE_MULTS: [(usize, usize); 7] =
    [(3, 1), (4, 3), (5, 6), (6, 7), (7, 6), (8, 3), (9, 1)];

#[cfg(feature = "stack")]
/// play with dirac quantum dice (stack based)
///
/// return the number of universes won by the player who wins more often
pub fn solution_2((p1, p2): (usize, usize)) -&gt; usize {
    // push states with multiplicty on stack
    // since I push to the end and pop from the end, this is depth first search
    let mut stack = Vec::new();
    stack.push((p1, p2, 0, 0, true, 1));

    // win counts
    let mut w1 = 0;
    let mut w2 = 0;

    // while there are unprocessed states
    while let Some((p1, p2, s1, s2, t, mult)) = stack.pop() {
        // loop over dice outcomes with multiplicity
        for (v, n) in DICE_MULTS {
            if t {
                // player 1's turn
                // update position and score
                let p1_upd = (p1 + v - 1) % 10 + 1;
                let s1_upd = s1 + p1_upd;
                if s1_upd &gt;= 21 {
                    // win
                    w1 += n * mult;
                } else {
                    // continue to play later
                    stack.push((p1_upd, p2, s1_upd, s2, false, n * mult));
                }
            } else {
                // player 2's turn
                // update position and score
                let p2_upd = (p2 + v - 1) % 10 + 1;
                let s2_upd = s2 + p2_upd;
                if s2_upd &gt;= 21 {
                    // win
                    w2 += n * mult;
                } else {
                    // continue to play later
                    stack.push((p1, p2_upd, s1, s2_upd, true, n * mult));
                }
            }
        }
    }

    cmp::max(w1, w2)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looking at the solution a bit closer, I figured out, that there are a total of 88200 different play states possible (10 positions per player times 21 scores per player times 2 because for each positions / scores it might be player 1&#8217;s or player 2&#8217;s turn). Yet, my stack based solution processes ~17 million items from the stack, i.e., on average, each state is pushed to the stack more than 200 times. There seems to be potential for optimization.</p>
</div>
<div class="paragraph">
<p>I created a second solution which is based on a flat list of multiplicities for every possible state. I process each state, sorted by the sum of the scores of both players. Because the total score increases in every round played, I am sure that a state processed once will never occur again. Here is my second solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(not(feature = "stack"))]
/// play with dirac quantum dice (state list based)
///
/// return the number of universes won by the player who wins more often
pub fn solution_2((p1, p2): (usize, usize)) -&gt; usize {
    // index to state multiplicity list
    const F_IDX: fn(usize, usize, usize, usize, usize) -&gt; usize =
        |p1, p2, s1, s2, t| p1 + 10 * p2 + 100 * s1 + 2100 * s2 + 44100 * t;

    // state multiplicity list
    let mut mults = vec![0; 10 * 10 * 21 * 21 * 2];

    // insert at pos_1 - 1 and pos_2 - 1 because position is zero based internally
    mults[F_IDX(p1 - 1, p2 - 1, 0, 0, 0)] = 1;

    // win counts
    let mut w1 = 0;
    let mut w2 = 0;

    for sum in 0..=40 {
        for s1 in if sum &gt; 20 { sum - 20..=20 } else { 0..=sum } {
            let s2 = sum - s1;

            for p1 in 0..10 {
                for p2 in 0..10 {
                    let mult_1 = mults[F_IDX(p1, p2, s1, s2, 0)];
                    let mult_2 = mults[F_IDX(p1, p2, s1, s2, 1)];

                    if mult_1 == 0 &amp;&amp; mult_2 == 0 {
                        continue; // don't loop if no need
                    }

                    for (v, n) in DICE_MULTS {
                        let p1_upd = (p1 + v) % 10;
                        let s1_upd = s1 + p1_upd + 1;
                        if s1_upd &gt;= 21 {
                            w1 += mult_1 * n;
                        } else {
                            mults[F_IDX(p1_upd, p2, s1_upd, s2, 1)] += mult_1 * n;
                        }

                        let p2_upd = (p2 + v) % 10;
                        let s2_upd = s2 + p2_upd + 1;
                        if s2_upd &gt;= 21 {
                            w2 += mult_2 * n;
                        } else {
                            mults[F_IDX(p1, p2_upd, s1, s2_upd, 0)] += mult_2 * n;
                        }
                    }
                }
            }
        }
    }

    cmp::max(w1, w2)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quick runtime comparison:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stack based solution: ~450ms</p>
</li>
<li>
<p>List based solution: ~3ms</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>List based is faster by a factor 150!</p>
</div>
<div class="paragraph">
<p>Hence, list based is my default ;)</p>
</div>
<div class="paragraph">
<p>If you still want to run the stack based solution, you can do so with <code>cargo run --release --features stack</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_tests_20"><a class="anchor" href="#_tests_20"></a><a class="link" href="#_tests_20">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_play_deterministic() {
        assert_eq!(739_785, solution_1((4, 8)))
    }

    #[test]
    fn test_play_dirac() {
        assert_eq!(444_356_092_776_315, solution_2((4, 8)))
    }
}</code></pre>
</div>
</div>
<a id="day22" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_22_rust"><a class="anchor" href="#_day_22_rust"></a><a class="link" href="#_day_22_rust">Day 22: rust</a></h3>
<div class="sect3">
<h4 id="_day_22_reactor_reboot"><a class="anchor" href="#_day_22_reactor_reboot"></a><a class="link" href="#_day_22_reactor_reboot">Day 22: Reactor Reboot</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/22">AoC|2021|22</a>.</p>
</div>
<div class="paragraph">
<p>Wow. This one took a while. I implemented part one based on a list. Obviously, this does not work for part 2. So a new idea was required.</p>
</div>
<div class="sect4">
<h5 id="_solution_5"><a class="anchor" href="#_solution_5"></a><a class="link" href="#_solution_5">Solution</a></h5>
<div class="paragraph">
<p>I use a structure <code>Cuboid</code> with one key function for the solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    /// count(s_n in s) = count(s_n v s) - sum_i=1^n-1 count(s_i in (s_n v s))
    pub fn get_count_in(&amp;self, others: &amp;[Self]) -&gt; isize {
        if let Some(other) = others.last() {
            if let Some(i) = self.intersect(other, other.on) {
                let mut count = if i.on { i.count() } else { 0 };
                for k in 1..others.len() {
                    count -= i.get_count_in(&amp;others[..k]);
                }
                return count;
            }
        }

        0
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function recursively calculates the contribution of a previous reboot step restricted to the current rebbot step. By subtracting all the contributions from previous steps, it essentially undoes the previous steps restricted to the area affected by the current step before applying the current step.</p>
</div>
<div class="paragraph">
<p>The recursion is necessary, because previous steps will in general overlap. So without the recursion, these overlapping areas would be undone several times.</p>
</div>
<div class="paragraph">
<p>This is all it takes. With this the solution to both parts is calculated as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn get_on_count(cuboids: &amp;[Cuboid]) -&gt; usize {
    // println!("{:?}", cuboids);
    let mut count = 0;
    for k1 in 0..cuboids.len() {
        let c1 = cuboids[k1];
        // println!("{}) {:?}", k1, c1);
        count += if c1.on { c1.count() } else { 0 };
        for k in 0..=k1 {
            count -= c1.get_count_in(&amp;cuboids[..k]);
        }
    }

    count as usize
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For part 1, I restrict the cuboids to satisfy the given bounds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solution_1(cuboids: &amp;[Cuboid]) -&gt; usize {
    get_on_count(
        &amp;cuboids
            .iter()
            .filter_map(|c| c.clamp(-50, 50))
            .collect::&lt;Vec&lt;_&gt;&gt;(),
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And there is also a parse function, as usual:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn parse(content: &amp;str) -&gt; Vec&lt;Cuboid&gt; {
    let mut cuboids = Vec::new();
    for line in content
        .lines()
        .map(|line| line.trim())
        .filter(|line| line.len() &gt; 0)
    {
        let mut parts = line.split(' ');
        let on = parts.next() == Some("on");

        let mut parts = parts
            .next()
            .expect("No ranges")
            .split(',')
            .map(|part| part.split('=').skip(1).next().expect("No range"))
            .map(|part| {
                let mut parts = part.split("..");
                let from = parts
                    .next()
                    .expect("No lower bound")
                    .parse::&lt;isize&gt;()
                    .unwrap();
                let to = parts
                    .next()
                    .expect("No upper bound")
                    .parse::&lt;isize&gt;()
                    .unwrap();
                (from, to)
            });

        let (x_mn, x_mx) = parts.next().expect("No x range");
        let (y_mn, y_mx) = parts.next().expect("No y range");
        let (z_mn, z_mx) = parts.next().expect("No z range");

        cuboids.push(Cuboid {
            on,
            x_mn,
            x_mx,
            y_mn,
            y_mx,
            z_mn,
            z_mx,
        });
    }

    cuboids
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_cuboids_implementation"><a class="anchor" href="#_cuboids_implementation"></a><a class="link" href="#_cuboids_implementation">Cuboids Implementation</a></h5>
<div class="paragraph">
<p>Here is the complete implementation of the <code>Cuboid</code> structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[derive(PartialEq, Eq, Clone, Copy)]
pub struct Cuboid {
    on: bool,
    x_mn: isize,
    x_mx: isize,
    y_mn: isize,
    y_mx: isize,
    z_mn: isize,
    z_mx: isize,
}

impl fmt::Debug for Cuboid {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "{} x={}..{},y={}..{},z={}..{}",
            if self.on { "on" } else { "off" },
            self.x_mn,
            self.x_mx,
            self.y_mn,
            self.y_mx,
            self.z_mn,
            self.z_mx
        )
    }
}

impl Cuboid {
    pub fn intersect(&amp;self, other: &amp;Self, on: bool) -&gt; Option&lt;Self&gt; {
        let x_mn = cmp::max(self.x_mn, other.x_mn);
        let x_mx = cmp::min(self.x_mx, other.x_mx);
        let y_mn = cmp::max(self.y_mn, other.y_mn);
        let y_mx = cmp::min(self.y_mx, other.y_mx);
        let z_mn = cmp::max(self.z_mn, other.z_mn);
        let z_mx = cmp::min(self.z_mx, other.z_mx);

        if x_mx &gt;= x_mn &amp;&amp; y_mx &gt;= y_mn &amp;&amp; z_mx &gt;= z_mn {
            Some(Self {
                on,
                x_mn,
                x_mx,
                y_mn,
                y_mx,
                z_mn,
                z_mx,
            })
        } else {
            None
        }
    }

    /// count(s_n in s) = count(s_n v s) - sum_i=1^n-1 count(s_i in (s_n v s))
    pub fn get_count_in(&amp;self, others: &amp;[Self]) -&gt; isize {
        if let Some(other) = others.last() {
            if let Some(i) = self.intersect(other, other.on) {
                let mut count = if i.on { i.count() } else { 0 };
                for k in 1..others.len() {
                    count -= i.get_count_in(&amp;others[..k]);
                }
                return count;
            }
        }

        0
    }

    /// count the elements in this cuboid
    pub fn count(&amp;self) -&gt; isize {
        cmp::max(0, self.x_mx - self.x_mn + 1)
            * cmp::max(0, self.y_mx - self.y_mn + 1)
            * cmp::max(0, self.z_mx - self.z_mn + 1)
    }

    /// restrict all ranges to be contained in ``mn..=mx``
    /// if the resulting cuboid is empty, retun ``None``
    pub fn clamp(&amp;self, mn: isize, mx: isize) -&gt; Option&lt;Self&gt; {
        let c = Cuboid {
            on: self.on,
            x_mn: cmp::max(self.x_mn, mn),
            x_mx: cmp::min(self.x_mx, mx),
            y_mn: cmp::max(self.y_mn, mn),
            y_mx: cmp::min(self.y_mx, mx),
            z_mn: cmp::max(self.z_mn, mn),
            z_mx: cmp::min(self.z_mx, mx),
        };
        if c.count() &gt; 0 {
            Some(c)
        } else {
            None
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_21"><a class="anchor" href="#_tests_21"></a><a class="link" href="#_tests_21">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT_PARSE: &amp;str = "on x=10..12,y=10..12,z=10..12
        on x=11..13,y=11..13,z=11..13
        off x=9..11,y=9..11,z=9..11
        on x=10..10,y=10..10,z=10..10";
    const CUBOIDS_PARSE: &amp;[Cuboid] = &amp;[
        Cuboid {
            on: true,
            x_mn: 10,
            x_mx: 12,
            y_mn: 10,
            y_mx: 12,
            z_mn: 10,
            z_mx: 12,
        },
        Cuboid {
            on: true,
            x_mn: 11,
            x_mx: 13,
            y_mn: 11,
            y_mx: 13,
            z_mn: 11,
            z_mx: 13,
        },
        Cuboid {
            on: false,
            x_mn: 9,
            x_mx: 11,
            y_mn: 9,
            y_mx: 11,
            z_mn: 9,
            z_mx: 11,
        },
        Cuboid {
            on: true,
            x_mn: 10,
            x_mx: 10,
            y_mn: 10,
            y_mx: 10,
            z_mn: 10,
            z_mx: 10,
        },
    ];

    const CONTENT_1: &amp;str = "on x=-20..26,y=-36..17,z=-47..7
        on x=-20..33,y=-21..23,z=-26..28
        on x=-22..28,y=-29..23,z=-38..16
        on x=-46..7,y=-6..46,z=-50..-1
        on x=-49..1,y=-3..46,z=-24..28
        on x=2..47,y=-22..22,z=-23..27
        on x=-27..23,y=-28..26,z=-21..29
        on x=-39..5,y=-6..47,z=-3..44
        on x=-30..21,y=-8..43,z=-13..34
        on x=-22..26,y=-27..20,z=-29..19
        off x=-48..-32,y=26..41,z=-47..-37
        on x=-12..35,y=6..50,z=-50..-2
        off x=-48..-32,y=-32..-16,z=-15..-5
        on x=-18..26,y=-33..15,z=-7..46
        off x=-40..-22,y=-38..-28,z=23..41
        on x=-16..35,y=-41..10,z=-47..6
        off x=-32..-23,y=11..30,z=-14..3
        on x=-49..-5,y=-3..45,z=-29..18
        off x=18..30,y=-20..-8,z=-3..13
        on x=-41..9,y=-7..43,z=-33..15
        on x=-54112..-39298,y=-85059..-49293,z=-27449..7877
        on x=967..23432,y=45373..81175,z=27513..53682";

    const CONTENT_2: &amp;str = "on x=-5..47,y=-31..22,z=-19..33
        on x=-44..5,y=-27..21,z=-14..35
        on x=-49..-1,y=-11..42,z=-10..38
        on x=-20..34,y=-40..6,z=-44..1
        off x=26..39,y=40..50,z=-2..11
        on x=-41..5,y=-41..6,z=-36..8
        off x=-43..-33,y=-45..-28,z=7..25
        on x=-33..15,y=-32..19,z=-34..11
        off x=35..47,y=-46..-34,z=-11..5
        on x=-14..36,y=-6..44,z=-16..29
        on x=-57795..-6158,y=29564..72030,z=20435..90618
        on x=36731..105352,y=-21140..28532,z=16094..90401
        on x=30999..107136,y=-53464..15513,z=8553..71215
        on x=13528..83982,y=-99403..-27377,z=-24141..23996
        on x=-72682..-12347,y=18159..111354,z=7391..80950
        on x=-1060..80757,y=-65301..-20884,z=-103788..-16709
        on x=-83015..-9461,y=-72160..-8347,z=-81239..-26856
        on x=-52752..22273,y=-49450..9096,z=54442..119054
        on x=-29982..40483,y=-108474..-28371,z=-24328..38471
        on x=-4958..62750,y=40422..118853,z=-7672..65583
        on x=55694..108686,y=-43367..46958,z=-26781..48729
        on x=-98497..-18186,y=-63569..3412,z=1232..88485
        on x=-726..56291,y=-62629..13224,z=18033..85226
        on x=-110886..-34664,y=-81338..-8658,z=8914..63723
        on x=-55829..24974,y=-16897..54165,z=-121762..-28058
        on x=-65152..-11147,y=22489..91432,z=-58782..1780
        on x=-120100..-32970,y=-46592..27473,z=-11695..61039
        on x=-18631..37533,y=-124565..-50804,z=-35667..28308
        on x=-57817..18248,y=49321..117703,z=5745..55881
        on x=14781..98692,y=-1341..70827,z=15753..70151
        on x=-34419..55919,y=-19626..40991,z=39015..114138
        on x=-60785..11593,y=-56135..2999,z=-95368..-26915
        on x=-32178..58085,y=17647..101866,z=-91405..-8878
        on x=-53655..12091,y=50097..105568,z=-75335..-4862
        on x=-111166..-40997,y=-71714..2688,z=5609..50954
        on x=-16602..70118,y=-98693..-44401,z=5197..76897
        on x=16383..101554,y=4615..83635,z=-44907..18747
        off x=-95822..-15171,y=-19987..48940,z=10804..104439
        on x=-89813..-14614,y=16069..88491,z=-3297..45228
        on x=41075..99376,y=-20427..49978,z=-52012..13762
        on x=-21330..50085,y=-17944..62733,z=-112280..-30197
        on x=-16478..35915,y=36008..118594,z=-7885..47086
        off x=-98156..-27851,y=-49952..43171,z=-99005..-8456
        off x=2032..69770,y=-71013..4824,z=7471..94418
        on x=43670..120875,y=-42068..12382,z=-24787..38892
        off x=37514..111226,y=-45862..25743,z=-16714..54663
        off x=25699..97951,y=-30668..59918,z=-15349..69697
        off x=-44271..17935,y=-9516..60759,z=49131..112598
        on x=-61695..-5813,y=40978..94975,z=8655..80240
        off x=-101086..-9439,y=-7088..67543,z=33935..83858
        off x=18020..114017,y=-48931..32606,z=21474..89843
        off x=-77139..10506,y=-89994..-18797,z=-80..59318
        off x=8476..79288,y=-75520..11602,z=-96624..-24783
        on x=-47488..-1262,y=24338..100707,z=16292..72967
        off x=-84341..13987,y=2429..92914,z=-90671..-1318
        off x=-37810..49457,y=-71013..-7894,z=-105357..-13188
        off x=-27365..46395,y=31009..98017,z=15428..76570
        off x=-70369..-16548,y=22648..78696,z=-1892..86821
        on x=-53470..21291,y=-120233..-33476,z=-44150..38147
        off x=-93533..-4276,y=-16170..68771,z=-104985..-24507";

    #[test]
    fn test_parse() {
        assert_eq!(CUBOIDS_PARSE, parse(CONTENT_PARSE));
    }

    #[test]
    fn test_soluton_1() {
        assert_eq!(27, solution_1(&amp;CUBOIDS_PARSE[..1]));
        assert_eq!(27 + 19, solution_1(&amp;CUBOIDS_PARSE[..2]));

        let cuboids = parse(CONTENT_1);
        assert_eq!(590_784, solution_1(&amp;cuboids));
    }

    #[test]
    fn test_solution_2_simple() {
        assert_eq!(27, solution_2(&amp;CUBOIDS_PARSE[..1]));
        assert_eq!(27 + 19, solution_1(&amp;CUBOIDS_PARSE[..2]));
        assert_eq!(27 + 19 - 8, solution_1(&amp;CUBOIDS_PARSE[..3]));
        assert_eq!(27 + 19 - 8 + 1, solution_1(&amp;CUBOIDS_PARSE[..4]));
    }

    #[test]
    fn test_solution_1_2_compare() {
        let cuboids = parse(CONTENT_1);
        let cuboids = cuboids
            .iter()
            .filter_map(|c| c.clamp(-50, 50))
            .collect::&lt;Vec&lt;_&gt;&gt;();

        for k in 1..cuboids.len() {
            println!("\n===\n{:3}\n===", k);
            assert_eq!(
                solution_1(&amp;cuboids[0..k]),
                solution_2(&amp;cuboids[0..k]),
                "Failed at step {}",
                k
            );
        }
    }

    #[test]
    fn test_solution_2() {
        let cuboids = parse(CONTENT_2);
        assert_eq!(2_758_514_936_282_235, solution_2(&amp;cuboids));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2021 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>