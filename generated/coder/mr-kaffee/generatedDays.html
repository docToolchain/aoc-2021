<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2021: mr-kaffee</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2021/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2021/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2021.netlify.app/","doctoolchain.org/aoc-2021/");
          }
      </script>
<!-- /aoc-2021/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2021//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2021//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2021//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2021//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2021//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2021</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:aoc-2021.netlify.com">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_mr_kaffee">mr-kaffee</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_ruby">Day 00: ruby</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world">Day 00: Hello World</a>
<ul class="sectlevel4">
<li><a href="#_solution">Solution</a></li>
<li><a href="#_test">Test</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_00_rust">Day 00: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world_2">Day 00: Hello World</a>
<ul class="sectlevel4">
<li><a href="#_general_structure">General structure</a></li>
<li><a href="#_run_solutions">Run Solutions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_01_sonar_sweep">Day 01: Sonar Sweep</a>
<ul class="sectlevel4">
<li><a href="#_part_1">Part 1</a></li>
<li><a href="#_part_2">Part 2</a></li>
<li><a href="#_today_i_learned">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_ruby">Day 02: ruby</a>
<ul class="sectlevel3">
<li><a href="#_day_02_dive">Day 02: Dive!</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2">Part 1</a></li>
<li><a href="#_part_2_2">Part 2</a></li>
<li><a href="#_tests">Tests</a></li>
<li><a href="#_today_i_learned_2">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_02_dive_2">Day 02: Dive!</a>
<ul class="sectlevel4">
<li><a href="#_part_1_3">Part 1</a></li>
<li><a href="#_part_2_3">Part 2</a></li>
<li><a href="#_today_i_learned_3">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_03_binary_diagnostic">Day 03: Binary Diagnostic</a>
<ul class="sectlevel4">
<li><a href="#_part_1_4">Part 1</a></li>
<li><a href="#_part_2_4">Part 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_04_giant_squid">Day 04: Giant Squid</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2_2">Part 1 &amp; 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_05_hydrothermal_venture">Day 05: Hydrothermal Venture</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2_3">Part 1 &amp; 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
<li><a href="#_today_i_learned_4">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_06_lanternfish">Day 06: Lanternfish</a>
<ul class="sectlevel4">
<li><a href="#_parts_1_2">Parts 1 &amp; 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
<li><a href="#_some_more_thoughts">Some more thoughts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_07_the_treachery_of_whales">Day 07: The Treachery of Whales</a>
<ul class="sectlevel4">
<li><a href="#_part_1_5">Part 1</a></li>
<li><a href="#_part_2_5">Part 2</a></li>
<li><a href="#_tests_6">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_rust">Day 08: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_08_seven_segment_search">Day 08: Seven Segment Search</a>
<ul class="sectlevel4">
<li><a href="#_part_1_6">Part 1</a></li>
<li><a href="#_part_2_6">Part 2</a></li>
<li><a href="#_tests_7">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_rust">Day 09: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_09_smoke_basin">Day 09: Smoke Basin</a>
<ul class="sectlevel4">
<li><a href="#_part_1_7">Part 1</a></li>
<li><a href="#_part_2_7">Part 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
<li><a href="#_today_i_learned_5">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_rust">Day 10: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a>
<ul class="sectlevel4">
<li><a href="#_part_1_8">Part 1</a></li>
<li><a href="#_part_2_8">Part 2</a></li>
<li><a href="#_tests_9">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_rust">Day 11: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a>
<ul class="sectlevel4">
<li><a href="#_part_1_9">Part 1</a></li>
<li><a href="#_part_2_9">Part 2</a></li>
<li><a href="#_tests_10">Tests</a></li>
<li><a href="#_today_i_learned_6">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_mr_kaffee"><a class="anchor" href="#_mr_kaffee"></a><a class="link" href="#_mr_kaffee">mr-kaffee</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars0.githubusercontent.com/u/73745454?v=4" alt="73745454?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>mr-kaffee</strong><br>
Peter Wieland<br>
Github: <a href="https://github.com/mr-kaffee">mr-kaffee</a>,
Strava: <a href="https://www.strava.com/athletes/89256720">Peter Wieland</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a curious amateur coder (lots of Java, MATLAB, recently Rust), I like cycling on and off roads and much more &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><a href="https://www.zusammengegencorona.de/impfen/">Corona sucks - let&#8217;s stop it!</a></p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_ruby"><a class="anchor" href="#_day_00_ruby"></a><a class="link" href="#_day_00_ruby">Day 00: ruby</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world"><a class="anchor" href="#_day_00_hello_world"></a><a class="link" href="#_day_00_hello_world">Day 00: Hello World</a></h4>
<div class="paragraph">
<p>Maybe I&#8217;ll try out some <a href="https://www.ruby-lang.org/">Ruby</a> this year. At least a hello world is done ;)</p>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>The actual solution resides in <code>solution.rb</code></p>
</div>
<div class="paragraph">
<p>It will define classes, methods and similar to calculate the solution, e.g.,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def say_hello(name = "World")
  "Hello, #{name}!"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>And a section to run the actual solution and measure time, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">if __FILE__ == $0
  b = Benchmark.measure { puts say_hello }
  puts "Solved in #{b.real}s"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The part <code>if <em>FILE</em> == $0</code> is taken from <a href="https://www.ruby-lang.org/en/documentation/quickstart/4/">Ruby in Twenty Minutes</a></p>
</div>
<div class="paragraph">
<p>The solution is executed with <code>ruby solution.rb</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_test"><a class="anchor" href="#_test"></a><a class="link" href="#_test">Test</a></h5>
<div class="paragraph">
<p>To test my code, there will be a <code>solution_test.rb</code> file which defines a test class derived from <code>Test::Unit::TestCase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">class TestSolution &lt; Test::Unit::TestCase
  def test_say_hello
    assert_equal "Hello, World!", say_hello
    assert_equal "Hello, Eric Wastl!", say_hello("Eric Wastl")
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tests are executed with <code>ruby solution_test.rb</code></p>
</div>
<a id="day00" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_00_rust"><a class="anchor" href="#_day_00_rust"></a><a class="link" href="#_day_00_rust">Day 00: rust</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world_2"><a class="anchor" href="#_day_00_hello_world_2"></a><a class="link" href="#_day_00_hello_world_2">Day 00: Hello World</a></h4>
<div class="paragraph">
<p>I am still undecided what language to use this year.
I&#8217;ll start with <a href="https://www.rust-lang.org/">Rust</a>.</p>
</div>
<div class="sect4">
<h5 id="_general_structure"><a class="anchor" href="#_general_structure"></a><a class="link" href="#_general_structure">General structure</a></h5>
<div class="paragraph">
<p>Generally, my solutions will contain a <code>src/main.rs</code> file which reads inputs, calls the solution functions and measures time</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn read_input() -&gt; String {
    fs::read_to_string("input.txt").expect("Could not read from file")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn main() {
    let instant = Instant::now();
    write_output(&amp;read_input());
    println!("Done in {:?}", instant.elapsed());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The actual solution will be implemented in a <code>lib.rs</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Write string to console
///
/// # Examples
///
/// ```
/// // running documentation examples as tests is a great idea in general; in this specific case
/// // there might be little value in the code and test
/// let s = "Hello World!";
/// mr_kaffee_2021_00::write_output(&amp;s);
/// ```
pub fn write_output(s: &amp;str) {
    println!("{}", s);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>lib.rs</code> file also contains the tests in a separate submodule.
I will use this for test-driven development, e.g., based on the examples given in the puzzles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_write_output() {
        // very stupid test
        write_output("Hello World!");
    }
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_run_solutions"><a class="anchor" href="#_run_solutions"></a><a class="link" href="#_run_solutions">Run Solutions</a></h5>
<div class="paragraph">
<p>Run solution with <code>cargo run</code> (or <code>cargo run --release</code> to see the effect of compiler optimization)</p>
</div>
<div class="paragraph">
<p>Run tests with <code>cargo test</code></p>
</div>
<a id="day01" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_01_sonar_sweep"><a class="anchor" href="#_day_01_sonar_sweep"></a><a class="link" href="#_day_01_sonar_sweep">Day 01: Sonar Sweep</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/1">AoC|2021|01</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1"><a class="anchor" href="#_part_1"></a><a class="link" href="#_part_1">Part 1</a></h5>
<div class="paragraph">
<p>Parse the input</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse each line into a number
pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    content
        .lines()
        .into_iter()
        .map(|line| line.parse().expect("Could not parse line"))
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And count how often consecutive inputs increase (test is part of documentation)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count how often consecutive numbers increase
///
/// # Examples
/// ```
/// let data: Vec&lt;usize&gt; = vec![199, 200, 208, 210, 200, 207, 240, 269, 260, 263];
/// assert_eq!(7, mr_kaffee_2021_01::count_increase(&amp;data));
/// ```
pub fn count_increase(data: &amp;[usize]) -&gt; usize {
    data.iter()
        .zip(data[1..].iter())
        .filter(|(a, b)| b &gt; a)
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2"><a class="anchor" href="#_part_2"></a><a class="link" href="#_part_2">Part 2</a></h5>
<div class="paragraph">
<p>Create sliding sums over three consecutive numbers (again with test as part of documentation)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// calculate sliding sums over three elements
///
/// # Examples
///
/// ```
/// let data: Vec&lt;usize&gt; = vec![199, 200, 208, 210, 200, 207, 240, 269, 260, 263];
/// let sums: Vec&lt;usize&gt; = vec![607, 618, 618, 617, 647, 716, 769, 792];
/// assert_eq!(sums, mr_kaffee_2021_01::sliding_sums(&amp;data));
/// ```
pub fn sliding_sums(data: &amp;[usize]) -&gt; Vec&lt;usize&gt; {
    data.iter()
        .zip(data[1..].iter())
        .zip(data[2..].iter())
        .map(|((a, b), c)| a + b + c)
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and use function <code>count_increase</code> from part 1 again</p>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned"><a class="anchor" href="#_today_i_learned"></a><a class="link" href="#_today_i_learned">Today I learned</a></h5>
<div class="paragraph">
<p>The <code>zip</code> function on iterators is useful.</p>
</div>
<div class="paragraph">
<p>Later, looking at other solutions, I felt stupid: Obviously <code><code>a[k] + a[k + 1] + a[k + 2] &lt; a[k + 1] + a[k + 2] + a[k + 3]</code></code>
if and only if <code><code>a[k] &lt; a[k + 3]</code></code> and thus there is no need at all to calculate the sliding sums for part 2.</p>
</div>
<div class="paragraph">
<p>This is a generic solution with <code><code>offset = 1</code></code> for part 1 and <code><code>offset = 3</code></code> for part 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count how often numbers with distance `offset` increase
///
/// # Examples
/// ```
/// let data: Vec&lt;usize&gt; = vec![199, 200, 208, 210, 200, 207, 240, 269, 260, 263];
/// assert_eq!(7, mr_kaffee_2021_01::count_increase_with_offset(&amp;data, 1));
/// assert_eq!(5, mr_kaffee_2021_01::count_increase_with_offset(&amp;data, 3));
/// ```
pub fn count_increase_with_offset(data: &amp;[usize], offset: usize) -&gt; usize {
    data.iter()
        .zip(data[offset..].iter())
        .filter(|(a, b)| b &gt; a)
        .count()
}</code></pre>
</div>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_ruby"><a class="anchor" href="#_day_02_ruby"></a><a class="link" href="#_day_02_ruby">Day 02: ruby</a></h3>
<div class="sect3">
<h4 id="_day_02_dive"><a class="anchor" href="#_day_02_dive"></a><a class="link" href="#_day_02_dive">Day 02: Dive!</a></h4>
<div class="paragraph">
<p><a href="https://www.ruby-lang.org">Ruby</a> solution to <a href="https://adventofcode.com/2021/day/2">AoC|2021|02</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_2"><a class="anchor" href="#_part_1_2"></a><a class="link" href="#_part_1_2">Part 1</a></h5>
<div class="paragraph">
<p>Generic function to calculate the position.
Takes the input string, an initial value and a hash of lambdas updating the position</p>
</div>
<div class="paragraph">
<p>The function iterates through the lines of the <code>input</code>. Each <code>line</code> is split in the command part <code>cmd</code> and the value part <code>v</code> (single space as separator). The command is used to select a lambda from the <code>steps</code> hash which is then called with the accumulator <code>acc</code> and the value <code>v</code> to udpate the accumulator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def calc_position(input, init, steps)
  input.split("\n")
       .map { |line| line.split(' ') }
       .inject(init) { |acc, cmd| steps[cmd.first].call acc, cmd.last.to_i }
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>For part 1, this function is called as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def calc_position_1(input)
  calc_position(input, [0, 0], {
    'up' =&gt; -&gt;(acc, v) { [acc[0], acc[1] - v] },
    'down' =&gt; -&gt;(acc, v) { [acc[0], acc[1] + v] },
    'forward' =&gt; -&gt;(acc, v) { [acc[0] + v, acc[1]] }
  })
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_2"><a class="anchor" href="#_part_2_2"></a><a class="link" href="#_part_2_2">Part 2</a></h5>
<div class="paragraph">
<p>For part 2, the aim has to be considered as additional value and the update rules are changed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">def calc_position_2(input)
  calc_position(input, [0, 0, 0], {
    'up' =&gt; -&gt;(acc, v) { [acc[0], acc[1], acc[2] - v] },
    'down' =&gt; -&gt;(acc, v) { [acc[0], acc[1], acc[2] + v] },
    'forward' =&gt; -&gt;(acc, v) { [acc[0] + v, acc[1] + acc[2] * v, acc[2]] }
  })
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests"><a class="anchor" href="#_tests"></a><a class="link" href="#_tests">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-ruby" data-lang="ruby">class TestSolution &lt; Test::Unit::TestCase
  CONTENT = %(forward 5
down 5
forward 8
up 3
down 8
forward 2).freeze

  def test_calc_position_1
    assert_equal [15, 10], calc_position_1(CONTENT)
  end

  def test_calc_position_2
    assert_equal [15, 60, 10], calc_position_2(CONTENT)
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_2"><a class="anchor" href="#_today_i_learned_2"></a><a class="link" href="#_today_i_learned_2">Today I learned</a></h5>
<div class="paragraph">
<p>... that I don&#8217;t know how to set up VS Code for decent Ruby development :(</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_02_dive_2"><a class="anchor" href="#_day_02_dive_2"></a><a class="link" href="#_day_02_dive_2">Day 02: Dive!</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/2">AoC|2021|02</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_3"><a class="anchor" href="#_part_1_3"></a><a class="link" href="#_part_1_3">Part 1</a></h5>
<div class="paragraph">
<p>The most difficult part today was to parse the input. My rust knowledge obviously is slightly rusty&#8230;&#8203;
Eventually I created an enum with a <code>parse</code> function as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Command {
    Up(isize),
    Down(isize),
    Forward(isize),
}

impl Command {
    /// parse command
    ///
    /// # Examples
    /// ```
    /// # use mr_kaffee_2021_02::*;
    /// assert_eq!(Command::Up(5), Command::parse("up 5"));
    /// assert_eq!(Command::Down(6), Command::parse("down 6"));
    /// assert_eq!(Command::Forward(-2), Command::parse("forward -2"));
    /// ```
    ///
    /// ```should_panic
    /// # use mr_kaffee_2021_02::*;
    /// // this will panic since the first part is not a valid command
    /// let cmd = Command::parse("invalid-command 7");
    /// ```
    ///
    /// ```should_panic
    /// # use mr_kaffee_2021_02::*;
    /// // this will panic since the two parts are not separated by a single blank
    /// let cmd = Command::parse("up\t7");
    /// ```
    ///
    /// ```should_panic
    /// # use mr_kaffee_2021_02::*;
    /// // this will panic since the second part is not a number
    /// let cmd = Command::parse("down not-a-number");
    /// ```
    pub fn parse(line: &amp;str) -&gt; Self {
        let (cmd, v) = line.split_once(' ').expect("Invalid line");
        let v = v.parse().expect("Could not parse value");
        match cmd {
            "up" =&gt; Command::Up(v),
            "down" =&gt; Command::Down(v),
            "forward" =&gt; Command::Forward(v),
            _ =&gt; panic!("Unexpected command"),
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution then is done with a simple fold operation on an iterator accumulating depth (y) and horizontal position (x)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Calculate positions
///
/// # Example
/// ```
/// # use mr_kaffee_2021_02::*;
/// assert_eq!((5, 0), calc_position("forward 5"));
/// assert_eq!((0, 5), calc_position("down 5"));
/// assert_eq!((3, -5), calc_position("up 5\nforward 3"));
/// assert_eq!((0, 0), calc_position(""));
/// ```
pub fn calc_position(input: &amp;str) -&gt; (isize, isize) {
    input
        .lines()
        .map(|line| Command::parse(line))
        .fold((0, 0), |(x, y), cmd| match cmd {
            Command::Up(v) =&gt; (x, y - v),
            Command::Down(v) =&gt; (x, y + v),
            Command::Forward(v) =&gt; (x + v, y),
        })
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_3"><a class="anchor" href="#_part_2_3"></a><a class="link" href="#_part_2_3">Part 2</a></h5>
<div class="paragraph">
<p>The second part was an easy extension to the first part. Just add a third accumulator state for the aim (small trap: my horizontal position is called 'x' which is not the same as the 'X' in the puzzle description)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Calculate positions with aim
///
/// # Example
/// ```
/// # use mr_kaffee_2021_02::*;
/// assert_eq!((5, 0, 0), calc_position_with_aim("forward 5"));
/// assert_eq!((5, 0, 5), calc_position_with_aim("forward 5\ndown 5"));
/// assert_eq!((13, 40, 5), calc_position_with_aim("forward 5\ndown 5\nforward 8"));
/// ```
pub fn calc_position_with_aim(input: &amp;str) -&gt; (isize, isize, isize) {
    input
        .lines()
        .map(|line| Command::parse(line))
        .fold((0, 0, 0), |(x, y, aim), cmd| match cmd {
            Command::Up(v) =&gt; (x, y, aim - v),
            Command::Down(v) =&gt; (x, y, aim + v),
            Command::Forward(v) =&gt; (x + v, y + aim * v, aim),
        })
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_3"><a class="anchor" href="#_today_i_learned_3"></a><a class="link" href="#_today_i_learned_3">Today I learned</a></h5>
<div class="paragraph">
<p>Parsing simple inputs does not require regular expressions &amp; creating enums with parse functions leads to a bit more code but looks much prettier</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_03_binary_diagnostic"><a class="anchor" href="#_day_03_binary_diagnostic"></a><a class="link" href="#_day_03_binary_diagnostic">Day 03: Binary Diagnostic</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/3">AoC|2021|03</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_4"><a class="anchor" href="#_part_1_4"></a><a class="link" href="#_part_1_4">Part 1</a></h5>
<div class="paragraph">
<p>As always, first challenge is to parse the input. I decided to read the input into integers. That caused some headaches later on to get the bit ordering correct. After I realized that the line length in the example differs from the line length in the puzzle input, I also return the length from my parse function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse input into integers
/// return bit-length of values in addition
pub fn parse(input: &amp;str) -&gt; (Vec&lt;usize&gt;, usize) {
    let len = input
        .lines()
        .map(|line| line.len())
        .next()
        .expect("No lines");
    let values = input
        .lines()
        .map(|line| usize::from_str_radix(line, 2).expect("Could not parse line"))
        .collect();
    (values, len)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Part 1 is then solved with the help of a function that counts for every position, how often the bit is set in the input. Another function then calculates epsilon by setting all the bits in the positions where most of the input values have bits set and gamma as the inverse</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Count how often bits are set in the values.
///
/// returns vector of counts with first element indicating how often least significant
/// bit is set and last element indicating how often most significant bit is set
pub fn count_all_ones(values: &amp;[usize], len: usize) -&gt; Vec&lt;usize&gt; {
    values.iter().fold(vec![0; len], |counts, value| {
        counts
            .iter()
            .enumerate()
            .map(|(k, one)| *one + ((*value &gt;&gt; k) &amp; 1))
            .collect()
    })
}

/// calculate the gamma and epsilon values
///
/// gamma is the value of all the most common bits
/// epsilon is the value of all the least common bits
///
/// returns ``(gamma, epsilon, gamma * epsilon)``
pub fn calc_gamma_epsilon(values: &amp;[usize], len: usize) -&gt; (usize, usize, usize) {
    let counts = count_all_ones(values, len);
    let gamma = (0..len).fold(0, |gamma, bit| {
        gamma + (((2 * counts[bit] &gt;= values.len()) as usize) &lt;&lt; bit)
    });
    let epsilon = !gamma &amp; ((1 &lt;&lt; len) - 1);
    (gamma, epsilon, gamma * epsilon)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_4"><a class="anchor" href="#_part_2_4"></a><a class="link" href="#_part_2_4">Part 2</a></h5>
<div class="paragraph">
<p>As the puzzle states, part 2 is the trickier one.</p>
</div>
<div class="paragraph">
<p>I wrote a filter function to reduce the list of values step by step until only one is left. Whether oxygen or co2 ratings are calculated is controlled with a <code><code>invert</code></code> flag. The filter function uses a new <code>count_ones</code> function that only counts the specific bit we are interested in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Count how often specific bit is set in the values.
pub fn count_ones(values: &amp;[usize], bit: usize) -&gt; usize {
    values
        .iter()
        .fold(0, |count, value| count + ((value &gt;&gt; bit) &amp; 1))
}

/// filter out all the values whos given bit is not equal to the most common
/// bit in that position.
///
/// If invert is true, do the opposite and keep all the values whos given bit
/// is not equal to the most common bit in that position.
pub fn filter(values: Vec&lt;usize&gt;, bit: usize, invert: bool) -&gt; Vec&lt;usize&gt; {
    // determin expected value (xor with invert)
    let exp = ((2 * count_ones(&amp;values, bit) &gt;= values.len()) ^ invert) as usize;
    values
        .into_iter()
        .filter(|value| (*value &gt;&gt; bit) &amp; 1 == exp)
        .collect()
}

/// calc oxygen (``invert = false``) or co2 (``invert = true``) ratings
pub fn calc_rating(values: &amp;[usize], len: usize, invert: bool) -&gt; usize {
    let mut values = values.to_vec();
    let mut bit = Some(len - 1);
    while values.len() &gt; 1 &amp;&amp; bit.is_some() {
        values = filter(values, bit.unwrap(), invert);
        bit = match bit {
            Some(v) if v &gt; 0 =&gt; Some(v - 1),
            _ =&gt; None,
        };
    }
    *values.first().expect("No value left")
}

/// calc oxygen and co2 ratings
///
/// returns ``(oxygen, co2, oxygen * co2)``
pub fn calc_ratings(vals: &amp;[usize], len: usize) -&gt; (usize, usize, usize) {
    let oxygen = calc_rating(vals, len, false);
    let co2 = calc_rating(vals, len, true);
    (oxygen, co2, oxygen * co2)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_2"><a class="anchor" href="#_tests_2"></a><a class="link" href="#_tests_2">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010";

    const EXP_VALUES: &amp;'static [usize] = &amp;[
        0b00100, 0b11110, 0b10110, 0b10111, 0b10101, 0b01111, 0b00111, 0b11100, 0b10000, 0b11001,
        0b00010, 0b01010,
    ];

    const EXP_LEN: usize = 5;

    #[test]
    fn test_parse() {
        let (vals, len) = parse(CONTENT);
        assert_eq!(EXP_LEN, len);
        assert_eq!(EXP_VALUES, vals);
    }

    #[test]
    fn test_count_all_ones() {
        assert_eq!(vec![5, 7, 8, 5, 7], count_all_ones(EXP_VALUES, EXP_LEN));
    }

    #[test]
    fn test_calc_gamma_epsilon() {
        assert_eq!((22, 9, 22 * 9), calc_gamma_epsilon(EXP_VALUES, EXP_LEN));
    }

    #[test]
    fn test_filter() {
        let values = filter(EXP_VALUES.to_vec(), EXP_LEN - 1, false);
        assert_eq!(
            vec![0b11110, 0b10110, 0b10111, 0b10101, 0b11100, 0b10000, 0b11001],
            values
        );

        let values = filter(EXP_VALUES.to_vec(), EXP_LEN - 1, true);
        assert_eq!(vec![0b00100, 0b01111, 0b00111, 0b00010, 0b01010], values);
    }

    #[test]
    fn test_calc_rating() {
        let (values, len) = parse(CONTENT);
        assert_eq!(23, calc_rating(&amp;values, len, false));
        assert_eq!(10, calc_rating(&amp;values, len, true));
    }

    #[test]
    fn test_calc_ratings() {
        let (values, len) = parse(CONTENT);
        assert_eq!((23, 10, 230), calc_ratings(&amp;values, len));
    }
}</code></pre>
</div>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_04_giant_squid"><a class="anchor" href="#_day_04_giant_squid"></a><a class="link" href="#_day_04_giant_squid">Day 04: Giant Squid</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/4">AoC|2021|04</a>.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s play Bingo (I don&#8217;t remember when I last did&#8230;&#8203;)</p>
</div>
<div class="sect4">
<h5 id="_part_1_2_2"><a class="anchor" href="#_part_1_2_2"></a><a class="link" href="#_part_1_2_2">Part 1 &amp; 2</a></h5>
<div class="paragraph">
<p>After I solved part 1 today, there was very little to add for part 2. Hence, there is only one solution for both parts.</p>
</div>
<div class="paragraph">
<p>I created a <code>struct</code> for a bingo board with a function <code>new</code> to create new boards, <code>apply_draws</code> to apply draws until a row or a column is complete, and a function <code>get_score</code> to calculate the final score:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// structure for a bingo board with ``data`` containing numbers, ``marked`` containing
/// flags which numbers have been drawn, ``draws_count`` holding the count af draws
/// (including draws that did not match), ``last`` holding the last number drawn, and
/// ``bingo`` is a flag indicating whether the board has at least one row or column completely
/// marked
pub struct Board {
    data: Vec&lt;usize&gt;,
    marked: Vec&lt;bool&gt;,
    count: usize,
    last: Option&lt;usize&gt;,
    bingo: bool,
}

impl Board {
    /// dimension of the boad
    pub const N: usize = 5;

    /// crate new board from data vector
    pub fn new(data: Vec&lt;usize&gt;) -&gt; Self {
        if data.len() != Self::N * Self::N {
            panic!("Illegal data length: {}", data.len());
        }
        Board {
            data,
            marked: vec![false; Self::N * Self::N],
            count: 0,
            last: None,
            bingo: false,
        }
    }

    /// apply draws to board, stops applying draws if a row or column is entirely marked
    pub fn apply_draws(&amp;mut self, draws: &amp;[usize]) {
        if self.bingo {
            return;
        }

        for draw in draws {
            self.count += 1;
            self.last = Some(*draw);
            if let Some((idx, _)) = self.data.iter().enumerate().find(|(_, v)| *v == draw) {
                self.marked[idx] = true;

                let x0 = idx % Self::N;
                let y0 = idx / Self::N;

                if (0..5).all(|x| self.marked[x + Self::N * y0])
                    || (0..5).all(|y| self.marked[x0 + Self::N * y])
                {
                    self.bingo = true;
                    return;
                }
            }
        }
    }

    /// get score (sum of numbers not marked multiplied by last number drawn)
    pub fn get_score(&amp;self) -&gt; usize {
        if !self.bingo {
            panic!("Board not solved.");
        }

        self.data
            .iter()
            .zip(self.marked.iter())
            .filter(|(_, marked)| !*marked)
            .map(|(v, _)| v)
            .sum::&lt;usize&gt;()
            * self.last.expect("No draws")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, I created a function which parses the input to a vector of boards and a vector of numbers drawn</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn parse(input: &amp;str) -&gt; (Vec&lt;Board&gt;, Vec&lt;usize&gt;) {
    let mut lines = input.lines();

    // parse drawn numbers
    let draws = lines
        .next()
        .expect("No draws")
        .split(',')
        .map(|part| part.parse().expect("Could not parse number"))
        .collect();

    // parse boards
    let mut boards = Vec::new();
    let mut data = Vec::with_capacity(Board::N * Board::N);
    loop {
        let (eof, line) = lines.next().map(|line| (false, line)).unwrap_or((true, ""));
        if line.trim().len() == 0 &amp;&amp; data.len() &gt; 0 {
            // block complete
            boards.push(Board::new(data));
            data = Vec::with_capacity(Board::N * Board::N);
        } else {
            // add data to block
            line.split_whitespace()
                .map(|v| v.parse().expect("Could not parse number"))
                .for_each(|v| data.push(v));
        }

        if eof {
            // no more lines
            return (boards, draws);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we are ready to play bingo. I play all the boards one by one and then look for the one which wins first and the one which wins last and return their scores</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// play bingo
///
/// returns scores of winning and loosing board
pub fn play&lt;'a&gt;(boards: &amp;'a mut [Board], draws: &amp;[usize]) -&gt; (usize, usize) {
    // boards that wins first and board that wins last with draw index
    let mut winner: Option&lt;&amp;Board&gt; = None;
    let mut looser: Option&lt;&amp;Board&gt; = None;
    for board in boards {
        board.apply_draws(&amp;draws);

        winner = winner
            .filter(|winner| board.count &gt;= winner.count)
            .or(Some(board));
        looser = looser
            .filter(|looser| board.count &lt;= looser.count)
            .or(Some(board));
    }

    // unwrap results
    (
        winner.expect("No winner").get_score(),
        looser.expect("No looser").get_score(),
    )
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_3"><a class="anchor" href="#_tests_3"></a><a class="link" href="#_tests_3">Tests</a></h5>
<div class="paragraph">
<p>I kind of did TDD ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1

22 13 17 11  0
 8  2 23  4 24
21  9 14 16  7
 6 10  3 18  5
 1 12 20 15 19

 3 15  0  2 22
 9 18 13 17  5
19  8  7 25 23
20 11 10 24  4
14 21 16 12  6

14 21 17 24  4
10 16 15  9 19
18  8 23 26 20
22 11 13  6  5
 2  0 12  3  7";

    const EXP_DRAWS: &amp;'static [usize] = &amp;[
        7, 4, 9, 5, 11, 17, 23, 2, 0, 14, 21, 24, 10, 16, 13, 6, 15, 25, 12, 22, 18, 20, 8, 19, 3,
        26, 1,
    ];

    const DATA_0: &amp;'static [usize] = &amp;[
        22, 13, 17, 11, 0, 8, 2, 23, 4, 24, 21, 9, 14, 16, 7, 6, 10, 3, 18, 5, 1, 12, 20, 15, 19,
    ];

    #[test]
    fn test_board_new() {
        let board = Board::new(DATA_0.to_owned());
        assert_eq!(DATA_0, board.data);
        assert_eq!(vec![false; Board::N * Board::N], board.marked);
        assert_eq!(false, board.bingo);
        assert_eq!(0, board.count);
        assert_eq!(None, board.last);
    }

    #[test]
    fn test_parse() {
        let (boards, draws) = parse(CONTENT);
        assert_eq!(EXP_DRAWS, draws);
        assert_eq!(3, boards.len());
        assert_eq!(DATA_0, boards[0].data);
    }

    #[test]
    #[should_panic]
    fn test_get_score_panics() {
        let (boards, _) = parse(CONTENT);
        // this fails since no bingo yet
        boards[0].get_score();
    }

    #[test]
    fn test_board_apply_draws() {
        let (mut boards, draws) = parse(CONTENT);

        // 15th number (24) wins for board at index 2
        boards[1].apply_draws(&amp;draws);
        assert_eq!(15, boards[1].count);
        assert_eq!(Some(13), boards[1].last);
        assert!(boards[1].bingo);

        // 12th number (13) wins for board at index 2
        boards[2].apply_draws(&amp;draws);
        assert_eq!(12, boards[2].count);
        assert_eq!(Some(24), boards[2].last);
        assert!(boards[2].bingo);
    }

    #[test]
    fn test_play() {
        let (mut boards, draws) = parse(CONTENT);
        assert_eq!((4512, 1924), play(&amp;mut boards, &amp;draws));
    }
}</code></pre>
</div>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_05_hydrothermal_venture"><a class="anchor" href="#_day_05_hydrothermal_venture"></a><a class="link" href="#_day_05_hydrothermal_venture">Day 05: Hydrothermal Venture</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/5">AoC|2021|05</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_2_3"><a class="anchor" href="#_part_1_2_3"></a><a class="link" href="#_part_1_2_3">Part 1 &amp; 2</a></h5>
<div class="paragraph">
<p>I played around a little bit how to best represent lines. Eventually, I decided to simply represent them as tuples <code><code>(x1, y1, x2, y2)</code></code>. When parsing the inputs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse lines ``"x1,y1 -&gt; x2,y2"`` to tuples ``(x1, y1, x2, y2)``
pub fn parse(content: &amp;str) -&gt; Vec&lt;(isize, isize, isize, isize)&gt; {
    content
        .lines()
        .map(|line| {
            let mut parts = line.split(" -&gt; ");
            let mut xy1 = parts.next().expect("No first point").split(',');
            let x1 = xy1
                .next()
                .expect("No x1")
                .parse()
                .expect("Could not parse x1");
            let y1 = xy1
                .next()
                .expect("No y1")
                .parse()
                .expect("Could not parse y1");
            let mut xy2 = parts.next().expect("NO second point").split(',');
            let x2 = xy2
                .next()
                .expect("No x2")
                .parse()
                .expect("Could not parse x2");
            let y2 = xy2
                .next()
                .expect("No y2")
                .parse()
                .expect("Could not parse y2");

            (x1, y1, x2, y2)
        })
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I initially decided to count vents in a flat list representing the relevant part of the ocean&#8217;s ground. To identify that relevant part, I have a function to determine the bounding box of all lines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get bounding box over lines
///
/// returns ``(x_min, y_min, x_max, y_max)`` so that all points ``(x, y)`` on
/// any line satisfy ``x_min &lt;= x &lt; x_max`` and ``y_min &lt;= y &lt; y_max``
pub fn get_bbox(lines: &amp;[(isize, isize, isize, isize)]) -&gt; (isize, isize, isize, isize) {
    lines.iter().fold(
        (isize::MAX, isize::MAX, isize::MIN, isize::MIN),
        |(x_min, y_min, x_max, y_max), (x1, y1, x2, y2)| {
            (
                cmp::min(cmp::min(x_min, *x1), *x2),
                cmp::min(cmp::min(y_min, *y1), *y2),
                cmp::max(cmp::max(x_max, *x1 + 1), *x2 + 1),
                cmp::max(cmp::max(y_max, *y1 + 1), *y2 + 1),
            )
        },
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Later on, I realized that a lot of other solutions used hash maps to keep the counters. So I wanted to try that as well and see the runtime impact. I made my solution generic using a trait <code>VentsCount</code> and implementing it for <code>HashMap</code> directly and for vectors using a struct <code>VecVentsCount</code> with a bit of extra information on the bounding box.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// to allow using the same code with counts stored in a vector or in a hash map, the interface is modeled as a trait
pub trait VentsCount {
    /// increment count at given coordinate
    fn increment(&amp;mut self, coord: (isize, isize));
    /// count number of coordinates with count &gt; 1
    fn count_dangerous(&amp;self) -&gt; usize;
}

impl VentsCount for HashMap&lt;(isize, isize), usize&gt; {
    fn increment(&amp;mut self, coord: (isize, isize)) {
        // get entry, create and initialize with value 0 if not yet present
        let count = self.entry(coord).or_insert(0);
        // increment
        *count += 1;
    }

    fn count_dangerous(&amp;self) -&gt; usize {
        self.values().filter(|count| **count &gt; 1).count()
    }
}

/// structure to count vents based on a vector
pub struct VecVentsCount {
    counts: Vec&lt;usize&gt;,
    width: isize,
    x_min: isize,
    y_min: isize,
}

impl VecVentsCount {
    /// create new ``VecVentsCount`` for bounding box
    pub fn new((x_min, y_min, x_max, y_max): (isize, isize, isize, isize)) -&gt; Self {
        let width = x_max - x_min;
        let counts = vec![0usize; (width * (y_max - y_min)) as usize];
        VecVentsCount {
            counts,
            width,
            x_min,
            y_min,
        }
    }
}

impl VentsCount for VecVentsCount {
    fn increment(&amp;mut self, (x, y): (isize, isize)) {
        self.counts[(x - self.x_min + self.width * (y - self.y_min)) as usize] += 1;
    }

    fn count_dangerous(&amp;self) -&gt; usize {
        self.counts.iter().filter(|count| **count &gt; 1).count()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is then build by iterating over all lines and for each line iterating over all points it contains and increment a counter for the coordinate of that point. Then count all coordinates which belong to more than one line (have counter value greater than 1).</p>
</div>
<div class="paragraph">
<p>To iterate over the points, I calculate deltas <code>dx</code> and <code>dy</code> that define the difference in the x and y coordinate from one point to the next. They can be one of 0, 1, or -1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// this function uses the struct [VecVentsCount] by default. This behavior can be changed to using ``HashMap`` based
/// counting using the feature ``hash_counters``
pub fn count_overlaps(lines: &amp;[(isize, isize, isize, isize)], incl_diagonal: bool) -&gt; usize {
    let mut counts: Box&lt;dyn VentsCount&gt; = if cfg!(feature = "hash_counters") {
        Box::new(HashMap::new())
    } else {
        Box::new(VecVentsCount::new(get_bbox(lines)))
    };

    for (x1, y1, x2, y2) in lines {
        if incl_diagonal || x1 == x2 || y1 == y2 {
            let dx = match x1.cmp(&amp;x2) {
                Ordering::Equal =&gt; 0,
                Ordering::Greater =&gt; -1,
                Ordering::Less =&gt; 1,
            };
            let dy = match y1.cmp(&amp;y2) {
                Ordering::Equal =&gt; 0,
                Ordering::Greater =&gt; -1,
                Ordering::Less =&gt; 1,
            };
            let len = cmp::max((x2 - x1) * dx, (y2 - y1) * dy) + 1;
            for k in 0..len {
                counts.increment((x1 + k * dx, y1 + k * dy));
            }
        }
    }

    counts.count_dangerous()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whether or not to include diagonal lines is controlled with a flag <code><code>include_diagonal</code></code> which is set to <code><code>false</code></code> for part 1 and <code><code>true</code></code> for part 2.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tests_4"><a class="anchor" href="#_tests_4"></a><a class="link" href="#_tests_4">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "0,9 -&gt; 5,9
8,0 -&gt; 0,8
9,4 -&gt; 3,4
2,2 -&gt; 2,1
7,0 -&gt; 7,4
6,4 -&gt; 2,0
0,9 -&gt; 2,9
3,4 -&gt; 1,4
0,0 -&gt; 8,8
5,5 -&gt; 8,2";

    const LINES: &amp;'static [(isize, isize, isize, isize)] = &amp;[
        (0, 9, 5, 9),
        (8, 0, 0, 8),
        (9, 4, 3, 4),
        (2, 2, 2, 1),
        (7, 0, 7, 4),
        (6, 4, 2, 0),
        (0, 9, 2, 9),
        (3, 4, 1, 4),
        (0, 0, 8, 8),
        (5, 5, 8, 2),
    ];

    #[test]
    fn test_parse() {
        assert_eq!(LINES, parse(CONTENT));
    }

    #[test]
    fn test_get_bbox() {
        assert_eq!((0, 0, 10, 10), get_bbox(LINES));
    }

    #[test]
    fn test_count_overlaps_straight() {
        assert_eq!(5, count_overlaps(LINES, false));
    }

    #[test]
    fn test_count_overlaps() {
        assert_eq!(12, count_overlaps(LINES, true));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_4"><a class="anchor" href="#_today_i_learned_4"></a><a class="link" href="#_today_i_learned_4">Today I learned</a></h5>
<div class="paragraph">
<p>A range is empty, if the upper bound is less than the lower bound.</p>
</div>
<div class="paragraph">
<p>It is not easy to write functions in rust that return iterators, since the actual type of the iterator depends on how it is constructed. Implementing an iterator on your own is not always worth the effort.</p>
</div>
<div class="paragraph">
<p>Sometimes, it is a good idea to use signed types even if all the results are positive. This allows to deal with negative increments much more directly.</p>
</div>
<div class="paragraph">
<p>Hash map based counting may come with a runtime penalty. In today&#8217;s puzzle, vector based counting performs three to four times faster.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_06_lanternfish"><a class="anchor" href="#_day_06_lanternfish"></a><a class="link" href="#_day_06_lanternfish">Day 06: Lanternfish</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/6">AoC|2021|06</a>.</p>
</div>
<div class="sect4">
<h5 id="_parts_1_2"><a class="anchor" href="#_parts_1_2"></a><a class="link" href="#_parts_1_2">Parts 1 &amp; 2</a></h5>
<div class="paragraph">
<p>The key is to not keep a list of fishes but a list of timer values.</p>
</div>
<div class="paragraph">
<p>Parsing the input is done as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse fishes
///
/// returns an vector of the number of fishes per given timer value
///
/// ```
/// # use mr_kaffee_2021_06::*;
/// assert_eq!(vec![0, 1, 1, 2, 1, 0, 0, 0, 0], parse("3,4,3,1,2"));
/// ```
pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    let mut fishes = vec![0; 9];

    for age in content.trim().split(',') {
        fishes[age.parse::&lt;usize&gt;().expect("Could not parse fish")] += 1;
    }

    fishes
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simulations are done with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// simulate a given number of days
///
/// the timer values of all fishes are decreased by one. If the timer value is 0,
/// it is reset to 6 and the same amount of fishes with time value 8 is added.
pub fn simulate(mut fishes: Vec&lt;usize&gt;, days: usize) -&gt; Vec&lt;usize&gt; {
    for _ in 0..days {
        let new_fishes = fishes[0];
        for k in 1..fishes.len() {
            fishes[k - 1] = fishes[k];
        }
        fishes[6] += new_fishes;
        fishes[8] = new_fishes;
    }
    fishes
}

/// simulate given number of rounds and return sum
pub fn simulate_and_count(mut fishes: Vec&lt;usize&gt;, days: usize) -&gt; usize {
    fishes = simulate(fishes, days);
    fishes.iter().sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_5"><a class="anchor" href="#_tests_5"></a><a class="link" href="#_tests_5">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const DATA: &amp;'static [usize] = &amp;[0, 1, 1, 2, 1, 0, 0, 0, 0];

    #[test]
    fn test_simulate() {
        let mut fishes = DATA.to_vec();
        fishes = simulate(fishes, 1);
        assert_eq!(fishes, parse("2,3,2,0,1"));
        fishes = simulate(fishes, 1);
        assert_eq!(fishes, parse("1,2,1,6,0,8"));
        fishes = simulate(fishes, 1);
        assert_eq!(fishes, parse("0,1,0,5,6,7,8"));
    }

    #[test]
    fn test_simulate_and_count() {
        assert_eq!(5934, simulate_and_count(DATA.to_vec(), 80));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_some_more_thoughts"><a class="anchor" href="#_some_more_thoughts"></a><a class="link" href="#_some_more_thoughts">Some more thoughts</a></h5>
<div class="paragraph">
<p>I was thinking to create an explicit solution (in memory of my time at <a href="https://www.ist.uni-stuttgart.de/">University Stuttgart</a>). Fish growth is governed by the discrte time ODE</p>
</div>
<div class="literalblock">
<div class="content">
<pre>timers[k + 1] = A timers[k]
count[k] = C timers[k]</pre>
</div>
</div>
<div class="paragraph">
<p>with the matrices</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    | 0 1 0 0 0 0 0 0 0 |
    | 0 0 1 0 0 0 0 0 0 |
    | 0 0 0 1 0 0 0 0 0 |
    | 0 0 0 0 1 0 0 0 0 |
A = | 0 0 0 0 0 1 0 0 0 |
    | 0 0 0 0 0 0 1 0 0 |
    | 1 0 0 0 0 0 0 1 0 |
    | 0 0 0 0 0 0 0 0 1 |
    | 1 0 0 0 0 0 0 0 0 |</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>C = ( 1 1 1 1 1 1 1 1 1 )</pre>
</div>
</div>
<div class="paragraph">
<p>The characteristic equation of A is</p>
</div>
<div class="literalblock">
<div class="content">
<pre>z^9 - z^2 - 1 = 0</pre>
</div>
</div>
<div class="paragraph">
<p>which <a href="https://maxima.sourceforge.io/">Maxima</a> is not able to solve :( - so no explicit solution that I would be able to come up with</p>
</div>
<div class="paragraph">
<p>For a big number of rounds, it might be interesting to calculate powers of the above matrix using <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">exponentiation by squaring</a>, but for 256 rounds, a direct approach is certainly more efficient.</p>
</div>
<div class="paragraph">
<p>I might not have a direct soluton for an arbitrary number of rounds, but a direct solution for 80 and 256 rounds can still be given as</p>
</div>
<div class="literalblock">
<div class="content">
<pre>count[80] = ( 1421 1401 1191 1154 1034 950 905 779 768 ) * timers[0]
count[256] = ( 6703087164 6206821033 5617089148 5217223242 4726100874 4368232009 3989468462 3649885552 3369186778 ) * timers[0]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">const CA_80: &amp;'static [usize] = &amp;[1421, 1401, 1191, 1154, 1034, 950, 905, 779, 768];
const CA_256: &amp;'static [usize] = &amp;[
    6703087164, 6206821033, 5617089148, 5217223242, 4726100874, 4368232009, 3989468462, 3649885552,
    3369186778,
];

pub fn solve_direct(fishes: &amp;[usize], days: usize) -&gt; usize {
    fishes
        .iter()
        .zip(
            match days {
                80 =&gt; CA_80,
                256 =&gt; CA_256,
                _ =&gt; panic!("No direct solution for {} days", days),
            }
            .iter(),
        )
        .map(|(counter, factor)| counter * factor)
        .sum()
}

#[cfg(test)]
mod direct_solution_test {
    use super::*;

    const INPUT: &amp;str = "4,1,1,4,1,2,1,4,1,3,4,4,1,5,5,1,3,1,1,1,4,4,3,1,5,3,1,2,5,1,1,5,\
1,1,4,1,1,1,1,2,1,5,3,4,4,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,5,1,1,1,4,1,2,3,5,1,2,2,4,1,4,4,4,\
1,2,5,1,2,1,1,1,1,1,1,4,1,1,4,3,4,2,1,3,1,1,1,3,5,5,4,3,4,1,5,1,1,1,2,2,1,3,1,2,4,1,1,3,3,\
1,3,3,1,1,3,1,5,1,1,3,1,1,1,5,4,1,1,1,1,4,1,1,3,5,4,3,1,1,5,4,1,1,2,5,4,2,1,4,1,1,1,1,3,1,\
1,1,1,4,1,1,1,1,2,4,1,1,1,1,3,1,1,5,1,1,1,1,1,1,4,2,1,3,1,1,1,2,4,2,3,1,4,1,2,1,4,2,1,4,4,\
1,5,1,1,4,4,1,2,2,1,1,1,1,1,1,1,1,1,1,1,4,5,4,1,3,1,3,1,1,1,5,3,5,5,2,2,1,4,1,4,2,1,4,1,2,\
1,1,2,1,1,5,4,2,1,1,1,2,4,1,1,1,1,2,1,1,5,1,1,2,2,5,1,1,1,1,1,2,4,2,3,1,2,1,5,4,5,1,4";

    #[test]
    #[should_panic]
    fn test_direct_fails() {
        solve_direct(&amp;parse(INPUT), 56);
    }

    #[test]
    fn test_direct_80() {
        let fishes = parse(INPUT);
        let sol_direct = solve_direct(&amp;fishes, 80);
        let sol_classic = simulate_and_count(fishes, 80);
        assert_eq!(sol_classic, sol_direct);
    }

    #[test]
    fn test_direct_256() {
        let fishes = parse(INPUT);
        let sol_direct = solve_direct(&amp;fishes, 256);
        let sol_classic = simulate_and_count(fishes, 256);
        assert_eq!(sol_classic, sol_direct);
    }
}</code></pre>
</div>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_07_the_treachery_of_whales"><a class="anchor" href="#_day_07_the_treachery_of_whales"></a><a class="link" href="#_day_07_the_treachery_of_whales">Day 07: The Treachery of Whales</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/7">AoC|2021|07</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_5"><a class="anchor" href="#_part_1_5"></a><a class="link" href="#_part_1_5">Part 1</a></h5>
<div class="paragraph">
<p>Parse input into a vector of numbers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    content
        .trim()
        .split(',')
        .map(|v| v.parse().expect("Could not parse"))
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a function that calculates the fuel need for a given alignment position (after refactoring for part 2, this contains a cost function - mapping distance to cost - as argument; for part 1, this is just the identity)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn get_fuel(crabs: &amp;[usize], position: usize, cost: fn(usize) -&gt; usize) -&gt; usize {
    crabs
        .iter()
        .map(|crab| {
            cost(if crab &gt; &amp;position {
                crab - position
            } else {
                position - crab
            })
        })
        .sum()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For optimization, I did not even think about for something more clever than linear search.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn get_optimal_positions_fuel(crabs: &amp;[usize], cost: fn(usize) -&gt; usize) -&gt; usize {
    let pos_min = *crabs.iter().min().expect("No min");
    let pos_max = *crabs.iter().max().expect("No max");
    (pos_min..=pos_max)
        .map(|position| get_fuel(crabs, position, cost))
        .min()
        .expect("No min")
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_5"><a class="anchor" href="#_part_2_5"></a><a class="link" href="#_part_2_5">Part 2</a></h5>
<div class="paragraph">
<p>For part two I just use a different cost function: <code>COST_LINEAR</code> solves part 1, <code>COST_INCREASING</code> solves part 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub const COST_LINEAR: fn(usize) -&gt; usize = |distance| distance;
pub const COST_INCREASING: fn(usize) -&gt; usize = |distance| distance * (distance + 1) / 2;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_6"><a class="anchor" href="#_tests_6"></a><a class="link" href="#_tests_6">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "16,1,2,0,4,2,7,1,2,14";
    const DATA: &amp;'static [usize] = &amp;[16, 1, 2, 0, 4, 2, 7, 1, 2, 14];

    #[test]
    fn test_parse() {
        assert_eq!(DATA, parse(CONTENT));
    }

    #[test]
    fn test_get_fuel() {
        assert_eq!(37, get_fuel(DATA, 2, COST_LINEAR));
        assert_eq!(41, get_fuel(DATA, 1, COST_LINEAR));
        assert_eq!(39, get_fuel(DATA, 3, COST_LINEAR));
    }

    #[test]
    fn test_get_optimal_positions_fuel() {
        assert_eq!(37, get_optimal_positions_fuel(DATA, COST_LINEAR));
    }

    #[test]
    fn test_get_optimal_positions_fuel_2() {
        assert_eq!(168, get_optimal_positions_fuel(DATA, COST_INCREASING));
    }
}</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_rust"><a class="anchor" href="#_day_08_rust"></a><a class="link" href="#_day_08_rust">Day 08: rust</a></h3>
<div class="sect3">
<h4 id="_day_08_seven_segment_search"><a class="anchor" href="#_day_08_seven_segment_search"></a><a class="link" href="#_day_08_seven_segment_search">Day 08: Seven Segment Search</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/8">AoC|2021|08</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_6"><a class="anchor" href="#_part_1_6"></a><a class="link" href="#_part_1_6">Part 1</a></h5>
<div class="paragraph">
<p>For part 1, the most difficult part for me was to parse the input. In the current version, I parse the unique patterns and outputs to integers, where bits <code>0</code> to <code>6</code> correspond to wires <code>a</code> to <code>g</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// return a vector of tuples, each containing a vector of unique patterns and a vector of outputs
///
/// each pattern / output is represented by an integer whos bits indicate the state of segments a (bit 0) to g (bit 6)
pub fn parse(content: &amp;str) -&gt; Vec&lt;(Vec&lt;usize&gt;, Vec&lt;usize&gt;)&gt; {
    content
        .lines()
        .map(|line| {
            line.split(" | ") // separate patterns from outputs
                .map(|part| {
                    part.split_ascii_whitespace() // separate individual patterns
                        .map(|pattern| {
                            // convert pattern to usize
                            pattern
                                .chars()
                                .fold(0, |bits, c| bits | 1 &lt;&lt; (c as usize - 'a' as usize))
                        })
                        .collect::&lt;Vec&lt;_&gt;&gt;() // patterns / outputs as usize
                })
                .collect::&lt;VecDeque&lt;_&gt;&gt;() // VecDeque with one element for patterns and one for outputs
        })
        .map(|mut parts| (parts.pop_front().unwrap(), parts.pop_front().unwrap()))
        .collect()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Counting the unique outputs is simple</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// count unique ouput values (1 - 2 bits set, 7 - 3 bits set, 4 - 4 bits set, 8 - 7 bits set) in all outputs
pub fn solution_1(displays: &amp;[(Vec&lt;usize&gt;, Vec&lt;usize&gt;)]) -&gt; usize {
    displays
        .iter()
        .map(|(_, outputs)| {
            outputs
                .iter()
                .filter(|output| [2, 3, 4, 7].contains(&amp;output.count_ones()))
                .count()
        })
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_6"><a class="anchor" href="#_part_2_6"></a><a class="link" href="#_part_2_6">Part 2</a></h5>
<div class="paragraph">
<p>For part 2 I did not really have a good idea and tried around for a while. What I came up with is a map of wires to candidate segments. I iterate over all unique patterns and exclude candidate segments for each wire.</p>
</div>
<div class="paragraph">
<p>For patterns with 2, 3, or 4 wires, the 2, 3, or 4 corresponding segments are known.</p>
</div>
<div class="paragraph">
<p>For patterns with 5 or 6 wires, the unused wires correspond to one of 4 or 3 segments, respectively.</p>
</div>
<div class="paragraph">
<p>Once all patterns processed, the map is further reduced by removing segments which are the only candidate left for one wire from the candidates of all other wires.</p>
</div>
<div class="paragraph">
<p>That was enough in my case to end up with a unique mapping.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// sum over decoded outputs
pub fn solution_2(displays: &amp;[(Vec&lt;usize&gt;, Vec&lt;usize&gt;)]) -&gt; usize {
    let f = if cfg!(feature = "rjplog_solution") {
        // alternative decoder if feature "rjplog_solution" is chosen
        self::decode_alt
    } else {
        self::decode
    };

    displays
        .iter()
        .map(|(patterns, outputs)| f(patterns, outputs))
        .sum()
}

/// determine wiring by unique batterns and decode output
///
/// # Example
/// ```
/// # use mr_kaffee_2021_08::*;
/// let content =
///     "acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf";
/// let displays = parse(content);
/// let (patterns, outputs) = &amp;displays[0];
/// assert_eq!(5353, decode(patterns, outputs));
/// ```
pub fn decode(patterns: &amp;[usize], outputs: &amp;[usize]) -&gt; usize {
    // map is a vector of 7 integers, one for each segment
    // each row represents a wire in a display (a = 0 to g = 6).
    // Each bit in the entry represents a segment, the wire actually controls (a = 0 to g = 6)
    let mut map: Vec&lt;usize&gt; = vec![(1 &lt;&lt; 7) - 1; 7];

    // 1 -&gt; _ _ c _ _ f _ -&gt; set bits match 0b0100100
    // 7 -&gt; a _ c _ _ f _ -&gt; set bits match 0b0100101
    // 4 -&gt; _ b c d _ f _ -&gt; set bits match 0b0101110
    // 2 -&gt; a _ c d e _ g
    // 3 -&gt; a _ c d _ f g
    // 5 -&gt; a b _ d _ f g -&gt; unset bits match 0b0110110
    // 0 -&gt; a b c _ e f g
    // 6 -&gt; a b _ d e f g
    // 9 -&gt; a b c d _ f g -&gt; unset bits match 0b0011100
    let masks = HashMap::from([
        (2, (0b0100100, !0b0100100)),
        (3, (0b0100101, !0b0100101)),
        (4, (0b0101110, !0b0101110)),
        (5, (0b1111111, 0b0110110)),
        (6, (0b1111111, 0b0011100)),
    ]);

    // for each pattern, reduce map by impossible bits
    for pattern in patterns {
        if let Some((p, n)) = masks.get(&amp;pattern.count_ones()) {
            for wire in 0..7 {
                map[wire] &amp;= if (pattern &gt;&gt; wire) &amp; 1 == 1 { p } else { n };
            }
        }
    }

    // reduce map
    // if a row contains only one bit set, this bit is removed from every other row
    for wire_1 in 0..7 {
        if map[wire_1].count_ones() == 1 {
            for wire_2 in (0..7).filter(|wire_2| *wire_2 != wire_1) {
                map[wire_2] &amp;= !map[wire_1];
            }
        }
    }

    // determine digits and fold to output
    outputs
        .iter()
        .map(|output| {
            // map wires to segments
            (0..7)
                .filter(|wire| (output &gt;&gt; wire) &amp; 1 == 1)
                .fold(0, |digit, wire| digit | map[wire])
        })
        .fold(0, |result, digit| {
            // calculate output from digits
            10 * result
                + match digit {
                    // map digit patterns to decimal digit
                    0b1110111 =&gt; 0,
                    0b0100100 =&gt; 1,
                    0b1011101 =&gt; 2,
                    0b1101101 =&gt; 3,
                    0b0101110 =&gt; 4,
                    0b1101011 =&gt; 5,
                    0b1111011 =&gt; 6,
                    0b0100101 =&gt; 7,
                    0b1111111 =&gt; 8,
                    0b1101111 =&gt; 9,
                    _ =&gt; panic!("Invalid digit: {}", digit),
                }
        })
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_alternative_solution"><a class="anchor" href="#_alternative_solution"></a><a class="link" href="#_alternative_solution">Alternative Solution</a></h6>
<div class="paragraph">
<p>I looked at the solution by <a href="https://github.com/RJPlog">RJPlog</a> later, which is actually much simpler than mine. Here is a Rust version of his decode idea.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// decode output (solution idea by https://github.com/RJPlog[RJPlog])
///
/// # Example
/// ```
/// # use mr_kaffee_2021_08::*;
/// let content =
///     "acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf";
/// let displays = parse(content);
/// let (patterns, outputs) = &amp;displays[0];
/// assert_eq!(5353, decode(patterns, outputs));
/// ```
pub fn decode_alt(patterns: &amp;[usize], outputs: &amp;[usize]) -&gt; usize {
    let mut map: Vec&lt;usize&gt; = vec![0; 10];
    for pattern in patterns {
        // unique segment counts
        // 1 -&gt; _ _ c _ _ f _  2 segments
        // 7 -&gt; a _ c _ _ f _  3 segments
        // 4 -&gt; _ b c d _ f _  4 segments
        // 8 -&gt; a b c d e f g  7 segments
        match pattern.count_ones() {
            2 =&gt; map[1] = *pattern,
            3 =&gt; map[7] = *pattern,
            4 =&gt; map[4] = *pattern,
            7 =&gt; map[8] = *pattern,
            _ =&gt; {} // nothing here
        }
    }
    for pattern in patterns.iter().filter(|pattern| pattern.count_ones() == 5) {
        // 2 -&gt; a _ c d e _ g
        // 3 -&gt; a _ c d _ f g
        // 5 -&gt; a b _ d _ f g
        if pattern &amp; map[1] == map[1] {
            // c | f is only contained in segments for 3
            map[3] = *pattern;
        } else if pattern &amp; (map[4] &amp; !map[1]) == (map[4] &amp; !map[1]) {
            // b | c | d | f &amp; !(c | f) = b | d is only contained in segments for 5
            map[5] = *pattern;
        } else {
            // if it is neither 3 nor 5, it must be 2
            map[2] = *pattern;
        }
    }
    for pattern in patterns.iter().filter(|pattern| pattern.count_ones() == 6) {
        // 0 -&gt; a b c _ e f g
        // 6 -&gt; a b _ d e f g
        // 9 -&gt; a b c d _ f g
        if pattern &amp; map[3] == map[3] {
            // a | c | d | f | g is only contained in the segments for 9
            map[9] = *pattern;
        } else if pattern &amp; map[5] == map[5] {
            // a | b | d | f | g is contained in the segments for 9 (already handled) and 6
            map[6] = *pattern;
        } else {
            // if it is neither 9 nor 6, it must be 0
            map[0] = *pattern;
        }
    }

    outputs
        .iter()
        .map(|output| map.iter().position(|pattern| output == pattern).unwrap())
        .fold(0, |result, digit| 10 * result + digit)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the alternative solution with <code>cargo run --release --features rjplog_solution</code></p>
</div>
<div class="paragraph">
<p>Not only is this solution simpler but it also runs faster. With compiler optimizations turned on, my original part 2 solves in about 1ms, the alternative solution takes about 0.1ms.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_7"><a class="anchor" href="#_tests_7"></a><a class="link" href="#_tests_7">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str =
        "be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce";

    #[test]
    fn test_solution_1() {
        let displays = parse(CONTENT);
        assert_eq!(26, solution_1(&amp;displays));
    }

    #[test]
    fn test_solution_2() {
        let data = parse(CONTENT);
        let sol = solution_2(&amp;data);
        assert_eq!(61229, sol);
    }
}</code></pre>
</div>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_rust"><a class="anchor" href="#_day_09_rust"></a><a class="link" href="#_day_09_rust">Day 09: rust</a></h3>
<div class="sect3">
<h4 id="_day_09_smoke_basin"><a class="anchor" href="#_day_09_smoke_basin"></a><a class="link" href="#_day_09_smoke_basin">Day 09: Smoke Basin</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/9">AoC|2021|09</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_7"><a class="anchor" href="#_part_1_7"></a><a class="link" href="#_part_1_7">Part 1</a></h5>
<div class="paragraph">
<p>I parse the input into a flat list and return the width of the grid in addition</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get width of grid and numbers as flat vector
///
/// ```
/// # use mr_kaffee_2021_09::*;
/// assert_eq!((1, vec![0,1]), parse("0\n1"));
/// ```
pub fn parse(content: &amp;str) -&gt; (usize, Vec&lt;usize&gt;) {
    let w = content.lines().next().expect("No lines").len();
    let grid = content
        .chars()
        .filter(|c| c.is_ascii_digit())
        .map(|c| (c as usize - '0' as usize))
        .collect();
    (w, grid)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Part one is about finding the low points. This is quite straightforward.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// find all elements for which all adjacents have higher values, sum their values incremented by 1
pub fn solution_1(w: usize, grid: &amp;[usize]) -&gt; usize {
    (0..grid.len())
        .map(|idx| (idx % w, idx / w))
        .filter(|(x, y)| {
            (*x == 0 || grid[x - 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*x == w - 1 || grid[x + 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*y == 0 || grid[x + w * (y - 1)] &gt; grid[x + w * y])
                &amp;&amp; (*y == grid.len() / w - 1 || grid[x + w * (y + 1)] &gt; grid[x + w * y])
        })
        .fold(0, |sum, (x, y)| sum + grid[x + w * y] + 1)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_7"><a class="anchor" href="#_part_2_7"></a><a class="link" href="#_part_2_7">Part 2</a></h5>
<div class="paragraph">
<p>Finally a puzzle where a breadth-first-traversal could be used (there might be easier approaches&#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p><span class="line-through">I did not read the instructions well and thought that adjacent coordinates only belong to a basin if their value was heigher than the neighbor&#8217;s value. My tests helped me to sort that out and understand that I only have to look for coordinates with value <code>9</code> that delimit the basins.</span></p>
</div>
<div class="paragraph">
<p>Actually, the problem was that in my test case I did not start from the low point <code>(1, 0)</code> but a neighbor <code>(0, 0)</code>. Looking only for numbers with higher values would work when starting from the low point, but it is not necessary. Only looking for nines is fine and allows to start from anywhere in the basin.</p>
</div>
<div class="paragraph">
<p>The depth first traversal is put in its own function <code>get_basin_size</code> for readability ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get the basin sizes of the basins the given coordinates belong to with a breadth first traversal
pub fn get_basin_size(w: usize, grid: &amp;[usize], x: usize, y: usize) -&gt; usize {
    let mut unknown = vec![true; grid.len()];
    let mut queue = VecDeque::new();

    unknown[x + w * y] = false;
    queue.push_back((x as isize, y as isize));
    let mut count = 0;

    let h = (grid.len() / w) as isize;
    let w = w as isize;

    // breadth first traversal
    while let Some((x, y)) = queue.pop_front() {
        count += 1;

        for (x_a, y_a) in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)] {
            if ((0..w).contains(&amp;x_a) &amp;&amp; (0..h).contains(&amp;y_a))
                &amp;&amp; unknown[(x_a + w * y_a) as usize]
                &amp;&amp; grid[(x_a + w * y_a) as usize] != 9
            {
                // if adjacent is within grid, is not yet seen and has a value != 9, mark known and add to queue
                unknown[(x_a + w * y_a) as usize] = false;
                queue.push_back((x_a, y_a));
            }
        }
    }

    count
}

/// get the product of the sizes of the (at most) three biggest basins
pub fn solution_2(w: usize, grid: &amp;[usize]) -&gt; usize {
    // determine low points and calculate basin sizes for those
    let mut basins = (0..grid.len())
        .map(|idx| (idx % w, idx / w))
        .filter(|(x, y)| {
            (*x == 0 || grid[x - 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*x == w - 1 || grid[x + 1 + w * y] &gt; grid[x + w * y])
                &amp;&amp; (*y == 0 || grid[x + w * (y - 1)] &gt; grid[x + w * y])
                &amp;&amp; (*y == grid.len() / w - 1 || grid[x + w * (y + 1)] &gt; grid[x + w * y])
        })
        .map(|(x, y)| get_basin_size(w, grid, x, y))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // sort basin sizes
    basins.sort_unstable();

    // product over the last three elements
    basins.iter().rev().take(3).product()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_8"><a class="anchor" href="#_tests_8"></a><a class="link" href="#_tests_8">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "2199943210\n3987894921\n9856789892\n8767896789\n9899965678";
    const W: usize = 10;
    const GRID: &amp;'static [usize] = &amp;[
        2, 1, 9, 9, 9, 4, 3, 2, 1, 0, 3, 9, 8, 7, 8, 9, 4, 9, 2, 1, 9, 8, 5, 6, 7, 8, 9, 8, 9, 2,
        8, 7, 6, 7, 8, 9, 6, 7, 8, 9, 9, 8, 9, 9, 9, 6, 5, 6, 7, 8,
    ];

    #[test]
    fn test_parse() {
        assert_eq!((W, GRID.to_vec()), parse(CONTENT));
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(15, solution_1(W, GRID));
    }

    #[test]
    fn test_get_basin_size() {
        for (exp, (x, y)) in [(3, (1, 0)), (9, (9, 0)), (14, (2, 2)), (9, (6, 4))] {
            assert_eq!(exp, get_basin_size(W, GRID, x, y));
        }
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(1_134, solution_2(W, GRID));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_5"><a class="anchor" href="#_today_i_learned_5"></a><a class="link" href="#_today_i_learned_5">Today I learned</a></h5>
<div class="paragraph">
<p>Read the puzzle description carefully (ha, not really a new learning) and continue to test (I think we had that before).</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_rust"><a class="anchor" href="#_day_10_rust"></a><a class="link" href="#_day_10_rust">Day 10: rust</a></h3>
<div class="sect3">
<h4 id="_day_10_syntax_scoring"><a class="anchor" href="#_day_10_syntax_scoring"></a><a class="link" href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/10">AoC|2021|10</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_8"><a class="anchor" href="#_part_1_8"></a><a class="link" href="#_part_1_8">Part 1</a></h5>
<div class="paragraph">
<p>Solution idea is to parse the characters one by one. If they are open delimiters, push the corresponding closing delimiter to a queue. If they are closing delimites, pop values from the queue and compare them to current character.</p>
</div>
<div class="paragraph">
<p>If a comparison fails, an illegal character is found and its score is returned. Then the sum over the scores is taken.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// return illegal char's score if any in as ``Some`` value, otherwise ``None``
pub fn find_illegal_char(line: &amp;str) -&gt; Option&lt;usize&gt; {
    let mut queue = VecDeque::new();
    for c in line.chars() {
        match c {
            '(' =&gt; queue.push_back(')'),
            '[' =&gt; queue.push_back(']'),
            '{' =&gt; queue.push_back('}'),
            '&lt;' =&gt; queue.push_back('&gt;'),
            ')' if c != queue.pop_back().unwrap() =&gt; return Some(3),
            ']' if c != queue.pop_back().unwrap() =&gt; return Some(57),
            '}' if c != queue.pop_back().unwrap() =&gt; return Some(1_197),
            '&gt;' if c != queue.pop_back().unwrap() =&gt; return Some(25_137),
            _ =&gt; {} // nothing here
        }
    }
    None
}

/// Calculate sum of scores of illegal chars
pub fn solution_1(lines: &amp;[String]) -&gt; usize {
    lines
        .iter()
        .filter_map(|line| find_illegal_char(line))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_8"><a class="anchor" href="#_part_2_8"></a><a class="link" href="#_part_2_8">Part 2</a></h5>
<div class="paragraph">
<p>Same idea as for part 1. Now discard lines where comparisons fail. What remains in the queue once a line is processed are the characters required to repair the line. This time, I push/pop at the front, so that I can iterate over the remaining queue from first to last character.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// get the repair score if the line is incomplete as a ``Some`` value, otherwise return ``None``
pub fn get_repair_score(line: &amp;str) -&gt; Option&lt;usize&gt; {
    let mut queue = VecDeque::new();
    for c in line.chars() {
        match c {
            '(' =&gt; queue.push_front(')'),
            '[' =&gt; queue.push_front(']'),
            '{' =&gt; queue.push_front('}'),
            '&lt;' =&gt; queue.push_front('&gt;'),
            ')' | '&gt;' | '}' | ']' if c != queue.pop_front().unwrap() =&gt; return None,
            _ =&gt; {} // nothing here
        }
    }

    Some(queue.iter().fold(0, |score, c| {
        score * 5
            + match c {
                ')' =&gt; 1,
                ']' =&gt; 2,
                '}' =&gt; 3,
                '&gt;' =&gt; 4,
                _ =&gt; unreachable!(),
            }
    }))
}

/// get the middle repair score
pub fn solution_2(lines: &amp;[String]) -&gt; usize {
    let mut scores = lines
        .iter()
        .filter_map(|line| get_repair_score(line))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    scores.sort();
    scores[scores.len() / 2]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_9"><a class="anchor" href="#_tests_9"></a><a class="link" href="#_tests_9">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "[({(&lt;(())[]&gt;[[{[]{&lt;()&lt;&gt;&gt;
[(()[&lt;&gt;])]({[&lt;{&lt;&lt;[]&gt;&gt;(
{([(&lt;{}[&lt;&gt;[]}&gt;{[]{[(&lt;()&gt;
(((({&lt;&gt;}&lt;{&lt;{&lt;&gt;}{[]{[]{}
[[&lt;[([]))&lt;([[{}[[()]]]
[{[{({}]{}}([{[{{{}}([]
{&lt;[[]]&gt;}&lt;{[{[{[]{()[[[]
[&lt;(&lt;(&lt;(&lt;{}))&gt;&lt;([]([]()
&lt;{([([[(&lt;&gt;()){}]&gt;(&lt;&lt;{{
&lt;{([{{}}[&lt;[[[&lt;&gt;{}]]]&gt;[]]";

    #[test]
    fn test_find_illegal_char() {
        let lines = parse(CONTENT);
        assert_eq!(
            vec![
                None,
                None,
                Some(1197),
                None,
                Some(3),
                Some(57),
                None,
                Some(3),
                Some(25137),
                None
            ],
            lines
                .iter()
                .map(|line| find_illegal_char(line))
                .collect::&lt;Vec&lt;_&gt;&gt;()
        );
    }

    #[test]
    fn test_solution_1() {
        let lines = parse(CONTENT);
        assert_eq!(26_397, solution_1(&amp;lines));
    }

    #[test]
    fn test_get_repair_score() {
        let lines = parse(CONTENT);
        assert_eq!(
            vec![
                Some(288957),
                Some(5566),
                None,
                Some(1480781),
                None,
                None,
                Some(995444),
                None,
                None,
                Some(294)
            ],
            lines
                .iter()
                .map(|line| get_repair_score(line))
                .collect::&lt;Vec&lt;_&gt;&gt;()
        );
    }

    #[test]
    fn test_solution_2() {
        let lines = parse(CONTENT);
        assert_eq!(288_957, solution_2(&amp;lines));
    }
}</code></pre>
</div>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_rust"><a class="anchor" href="#_day_11_rust"></a><a class="link" href="#_day_11_rust">Day 11: rust</a></h3>
<div class="sect3">
<h4 id="_day_11_dumbo_octopus"><a class="anchor" href="#_day_11_dumbo_octopus"></a><a class="link" href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2021/day/11">AoC|2021|11</a>.</p>
</div>
<div class="sect4">
<h5 id="_part_1_9"><a class="anchor" href="#_part_1_9"></a><a class="link" href="#_part_1_9">Part 1</a></h5>
<div class="paragraph">
<p>Parse the input into a flat list of integers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// parse energy levels
///
/// # Panics
/// if number of energy levels is not 10 x 10 = 100
pub fn parse(content: &amp;str) -&gt; Vec&lt;usize&gt; {
    let energies = content
        .chars()
        .filter(|c| c.is_ascii_digit())
        .map(|c| c as usize - '0' as usize)
        .collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(
        100,
        energies.len(),
        "Bad length: expected 100, found {}",
        energies.len()
    );
    energies
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In each update step, first increment all energy levels and reset them to 0 if they exceed 9. All indices for reset entries (octopus flashed) are added to a stack.</p>
</div>
<div class="paragraph">
<p>Then do a depth first traversal (breadth first would work just as well):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>pop elements off the stack while it is not empty</p>
</li>
<li>
<p>loop through all adjacents skipping adjecents which have already flashed (energy level already reset to 0)</p>
</li>
<li>
<p>increment adjacent&#8217;s energy level</p>
</li>
<li>
<p>if energy level exceeds 9, reset and add index to stack</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// do an update step on the energy levels
/// return the count of flashes in that step
pub fn step(energies: &amp;mut [usize]) -&gt; usize {
    // flashing stack
    let mut stack = Vec::new();

    // increase all elements by one
    for k in 0..energies.len() {
        energies[k] = (energies[k] + 1) % 10;
        if energies[k] == 0 {
            // flashed -&gt; add to stack
            stack.push(((k % 10) as isize, (k / 10) as isize));
        }
    }

    // depth first traversal to determine all flashes
    let mut flash_count = 0;
    while let Some((x, y)) = stack.pop() {
        flash_count += 1;

        // loop over adjacent entries
        for (x_a, y_a) in [
            (x + 1, y),
            (x + 1, y + 1),
            (x, y + 1),
            (x - 1, y + 1),
            (x - 1, y),
            (x - 1, y - 1),
            (x, y - 1),
            (x + 1, y - 1),
        ] {
            if x_a &lt; 0 || x_a &gt;= 10 || y_a &lt; 0 || y_a &gt;= 10 {
                // out of bounds
                continue;
            }

            // flat index
            let k_a = (x_a + 10 * y_a) as usize;
            if energies[k_a] == 0 {
                // already flashed
                continue;
            }

            // not flashed yet, increment
            energies[k_a] = (energies[k_a] + 1) % 10;
            if energies[k_a] == 0 {
                // flashed -&gt; add to stack
                stack.push((x_a, y_a));
            }
        }
    }

    flash_count
}

/// perform 100 update steps and return total count of flashes
pub fn solution_1(energies: &amp;[usize]) -&gt; usize {
    // work on my own copy of the grid
    let mut energies = energies.to_owned();
    (0..100).map(|_| step(&amp;mut energies)).sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_9"><a class="anchor" href="#_part_2_9"></a><a class="link" href="#_part_2_9">Part 2</a></h5>
<div class="paragraph">
<p>Perform update steps until all 100 octopuses flash at the same time. Could have re-used the updated grid from part 1, but the solution is fast enough to re-do the first 100 steps ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// perform update steps until all octopuses flash at the same time
/// return the first step when this occurs.
pub fn solution_2(energies: &amp;[usize]) -&gt; usize {
    // work on my own copy of the grid
    let mut energies = energies.to_owned();
    let mut rounds = 1; // one based counting
    while step(&amp;mut energies) &lt; 100 {
        rounds += 1;
    }
    rounds
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_10"><a class="anchor" href="#_tests_10"></a><a class="link" href="#_tests_10">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = "5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526";

    const ENERGIES: &amp;'static [usize] = &amp;[
        5, 4, 8, 3, 1, 4, 3, 2, 2, 3, 2, 7, 4, 5, 8, 5, 4, 7, 1, 1, 5, 2, 6, 4, 5, 5, 6, 1, 7, 3,
        6, 1, 4, 1, 3, 3, 6, 1, 4, 6, 6, 3, 5, 7, 3, 8, 5, 4, 7, 8, 4, 1, 6, 7, 5, 2, 4, 6, 4, 5,
        2, 1, 7, 6, 8, 4, 1, 7, 2, 1, 6, 8, 8, 2, 8, 8, 1, 1, 3, 4, 4, 8, 4, 6, 8, 4, 8, 5, 5, 4,
        5, 2, 8, 3, 7, 5, 1, 5, 2, 6,
    ];

    const CONTENT_1: &amp;str = "6594254334
3856965822
6375667284
7252447257
7468496589
5278635756
3287952832
7993992245
5957959665
6394862637";

    const CONTENT_2: &amp;str = "8807476555
5089087054
8597889608
8485769600
8700908800
6600088989
6800005943
0000007456
9000000876
8700006848";

    const CONTENT_10: &amp;str = "0481112976
0031112009
0041112504
0081111406
0099111306
0093511233
0442361130
5532252350
0532250600
0032240000";

    #[test]
    fn test_parse() {
        assert_eq!(ENERGIES, parse(CONTENT));
    }

    #[test]
    fn test_step() {
        let mut energies = parse(CONTENT);
        let energies_1 = parse(CONTENT_1);
        let energies_2 = parse(CONTENT_2);
        let energies_10 = parse(CONTENT_10);

        let mut cnt = 0;

        // one step
        cnt += step(&amp;mut energies);
        assert_eq!(0, cnt);
        assert_eq!(energies_1, energies);

        // another step
        cnt += step(&amp;mut energies);
        assert_eq!(35, cnt);
        assert_eq!(energies_2, energies);

        // 8 more steps
        for _ in 2..10 {
            cnt += step(&amp;mut energies);
        }
        assert_eq!(204, cnt);
        assert_eq!(energies_10, energies);
    }

    #[test]
    fn test_solution_1() {
        assert_eq!(1656, solution_1(&amp;parse(CONTENT)));
    }

    #[test]
    fn test_solution_2() {
        assert_eq!(195, solution_2(&amp;parse(CONTENT)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_6"><a class="anchor" href="#_today_i_learned_6"></a><a class="link" href="#_today_i_learned_6">Today I learned</a></h5>
<div class="paragraph">
<p>In depth first traversal (as well as in breadth first traversal), be careful to not add elements to the stack (or queue) multiple times. In my first approach, I only reset the energy levels in when they were popped from the queue. Thus entries could get modified while there indices were in the queue already and indices could be added multiple times. Took a while to sort that out.</p>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2021 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>