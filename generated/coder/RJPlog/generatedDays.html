<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2021: RJPlog</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2021/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2021/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2021.netlify.app/","doctoolchain.org/aoc-2021/");
          }
      </script>
<!-- /aoc-2021/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2021//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2021//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2021//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2021//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2021//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2021</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:aoc-2021.netlify.com">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_rjplog">RJPlog</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_kotlin">Day 00: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_00_getting_started">Day 00: Getting started</a></li>
</ul>
</li>
<li><a href="#_day_01_kotlin">Day 01: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_1_sonar_sweep">Day 1: Sonar Sweep</a>
<ul class="sectlevel4">
<li><a href="#_first_star">First Star</a></li>
<li><a href="#_second_star">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_kotlin">Day 02: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_2_dive">Day 2: Dive</a>
<ul class="sectlevel4">
<li><a href="#_first_star_2">First Star</a></li>
<li><a href="#_second_star_2">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_kotlin">Day 03: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_3_binary_diagnostic">Day 3: Binary Diagnostic</a>
<ul class="sectlevel4">
<li><a href="#_first_star_3">First Star</a></li>
<li><a href="#_second_star_3">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_kotlin">Day 04: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_4_giant_squid">Day 4: Giant Squid</a>
<ul class="sectlevel4">
<li><a href="#_today_i_learned">Today I learned</a></li>
<li><a href="#_first_star_4">First Star</a></li>
<li><a href="#_second_star_4">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_kotlin">Day 05: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_5_hydrothermal_venture">Day 5: Hydrothermal Venture</a>
<ul class="sectlevel4">
<li><a href="#_first_star_5">First Star</a></li>
<li><a href="#_second_star_5">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_kotlin">Day 06: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_6_lanternfish">Day 6: Lanternfish</a>
<ul class="sectlevel4">
<li><a href="#_first_star_6">First Star</a></li>
<li><a href="#_second_star_6">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_kotlin">Day 07: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_7_the_treachery_of_whales">Day 7: The Treachery of Whales</a>
<ul class="sectlevel4">
<li><a href="#_first_star_7">First Star</a></li>
<li><a href="#_second_star_7">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_kotlin">Day 08: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_8_seven_segment_search">Day 8: Seven Segment Search</a>
<ul class="sectlevel4">
<li><a href="#_first_star_8">First Star</a></li>
<li><a href="#_second_star_8">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_kotlin">Day 09: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_9_smoke_basin">Day 9: Smoke Basin</a>
<ul class="sectlevel4">
<li><a href="#_first_star_9">First Star</a></li>
<li><a href="#_second_star_9">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_kotlin">Day 10: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a>
<ul class="sectlevel4">
<li><a href="#_today_i_learned_2">Today I learned</a></li>
<li><a href="#_first_star_10">First Star</a></li>
<li><a href="#_second_star_10">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_kotlin">Day 11: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a>
<ul class="sectlevel4">
<li><a href="#_first_star_11">First Star</a></li>
<li><a href="#_second_star_11">Second Star</a></li>
<li><a href="#_add_on">Add On</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_12_kotlin">Day 12: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_12_passage_pathing">Day 12: Passage Pathing</a>
<ul class="sectlevel4">
<li><a href="#_first_star_12">First Star</a></li>
<li><a href="#_second_star_12">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_13_kotlin">Day 13: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_13_transparent_origami">Day 13: Transparent Origami</a>
<ul class="sectlevel4">
<li><a href="#_first_star_13">First Star</a></li>
<li><a href="#_second_star_13">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_14_kotlin">Day 14: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_14_extended_polymerization">Day 14: Extended Polymerization</a>
<ul class="sectlevel4">
<li><a href="#_first_star_14">First Star</a></li>
<li><a href="#_second_star_14">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_17_kotlin">Day 17: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_17_tick_shot">Day 17: Tick Shot</a>
<ul class="sectlevel4">
<li><a href="#_first_star_15">First Star</a></li>
<li><a href="#_second_star_15">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_18_kotlin">Day 18: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_18_snailfish">Day 18: Snailfish</a>
<ul class="sectlevel4">
<li><a href="#_first_star_16">First Star</a></li>
<li><a href="#_second_star_16">Second Star</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_20_kotlin">Day 20: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_day_20_trench_map">Day 20: Trench Map</a>
<ul class="sectlevel4">
<li><a href="#_first_star_17">First Star</a></li>
<li><a href="#_second_star_17">Second Star</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_rjplog"><a class="anchor" href="#_rjplog"></a><a class="link" href="#_rjplog">RJPlog</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/44948239?v=4" alt="44948239?v=4"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>RJPlog</strong><br>
<span class="icon"><i class="fa fa-github"></i></span>: <a href="https://github.com/RJPlog">RJPlog</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>Nothing here yet. Update your profile at <a href="https://github.com/docToolchain/aoc-2021/blob/master/profiles/RJPlog.adoc">/profiles/RJPlog.adoc</a></p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_kotlin"><a class="anchor" href="#_day_00_kotlin"></a><a class="link" href="#_day_00_kotlin">Day 00: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_00_getting_started"><a class="anchor" href="#_day_00_getting_started"></a><a class="link" href="#_day_00_getting_started">Day 00: Getting started</a></h4>
<div class="paragraph">
<p>As in the past years I will get more into kotlin. Here in gitpod solutions will run with kotlin script.</p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2100.kts</em> in the command line.</p>
</div>
<div class="paragraph">
<p>Read the input file is done via a function call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun read(): String {
    var result: String = ""
    File("day2100_puzzle_input.txt").forEachLine {
        result = it
    }
    return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output is printed in main:app-name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">//main (args: Arrary&lt;String&gt;) {
    var solution_1 = read()
    println(" I like $solution_1")
//}</code></pre>
</div>
</div>
<a id="day01" />
</div>
</div>
<div class="sect2">
<h3 id="_day_01_kotlin"><a class="anchor" href="#_day_01_kotlin"></a><a class="link" href="#_day_01_kotlin">Day 01: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_1_sonar_sweep"><a class="anchor" href="#_day_1_sonar_sweep"></a><a class="link" href="#_day_1_sonar_sweep">Day 1: Sonar Sweep</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/1" class="bare">https://adventofcode.com/2021/day/1</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2101_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star"><a class="anchor" href="#_first_star"></a><a class="link" href="#_first_star">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Inside function <em>sonar_sweep</em> the puzzle input will be read into a list. Afterwards within a loop each value is compared to it&#8217;s previous value. If the current value is higher than the previous, the variable <em>result</em> is increased. After finishing the loop, <em>result</em> is returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun sonar_sweep(): Int {

	var result: Int = 0
	var samples = mutableListOf&lt;Int&gt;()

	File("day2101_puzzle_input.txt").forEachLine {
		samples.add(it.toInt())
	}

	for (i in 1..samples.size-1) {
		if (samples[i] &gt; samples[i-1]){
			result++
		}
	}
	return result
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star"><a class="anchor" href="#_second_star"></a><a class="link" href="#_second_star">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Inside function <em>sonar_sweep_noise</em> the puzzle input will be read into a list as in solution for part 1. Afterwards within a loop a variable <em>prev_sum</em> and <em>curr_sum</em> is calculated out of the last and current 3 samples. Both are compared, if the current value is higher than the previous, the variable <em>result</em> is increased. After finishing the loop, <em>result</em> is returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun sonar_sweep_noise(): Int {

	var result: Int = 0
	var samples = mutableListOf&lt;Int&gt;()

	File("day2101_puzzle_input.txt").forEachLine {
		samples.add(it.toInt())
	}

	for (i in 1..samples.size-1-2) {

		var prev_sum: Int = samples[i-1]+samples[i]+ samples[i+1]
		var cur_sum: Int = samples[i]+samples[i+1]+ samples[i+2]

		if (cur_sum &gt; prev_sum){
			result++
		}
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("**************************")
	println("--- Day 1: Sonar Sweep ---")
	println("**************************")
	println("Solution for part1")
	println("   $solution1 are larger than the previous measurement ")
	println()
// print solution for part 2
	println("**************************")
	println("Solution for part2")
	println("   $solution2 sums are larger than the previous measurement")
	println()</code></pre>
</div>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_kotlin"><a class="anchor" href="#_day_02_kotlin"></a><a class="link" href="#_day_02_kotlin">Day 02: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_2_dive"><a class="anchor" href="#_day_2_dive"></a><a class="link" href="#_day_2_dive">Day 2: Dive</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/2" class="bare">https://adventofcode.com/2021/day/2</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2102_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_2"><a class="anchor" href="#_first_star_2"></a><a class="link" href="#_first_star_2">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Inside function <em>dive</em> the puzzle input will be read line by line and split into the instruction part <em>instruction[0]</em> and the value <em>instruction[1]</em>. The varibles <em>depth</em> and <em>horizontal</em> are increased or decreased within a if/else instruction according to their instructions. After going through the complete input file <em>depth</em> multiplied by <em>horizontal</em> is returned</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun dive_1(): Int {

	var depth: Int = 0
	var horizontal: Int = 0

	File("day2102_puzzle_input.txt").forEachLine {

		var instruction = it.split(' ')

		if (instruction[0].equals("forward")) {
			horizontal = horizontal + instruction[1].toInt()
		} else if (instruction[0].equals("down")) {
			depth = depth + instruction[1].toInt()
		} else if (instruction[0].equals("up")) {
			depth = depth - instruction[1].toInt()
		}
	}
	return depth*horizontal
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_2"><a class="anchor" href="#_second_star_2"></a><a class="link" href="#_second_star_2">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Inside function <em>dive_2</em> the puzzle input will be read line by line and split into the instruction part <em>instruction[0]</em> and the value <em>instruction[1]</em>. The varibles <em>depth</em>, <em>horizontal</em> and <em>aim</em> are increased or decreased within a if/else instruction according to their instructions. After going through the complete input file <em>depth</em> multiplied by <em>horizontal</em> is returned</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun dive_2(): Int {

	var depth: Int = 0
	var horizontal: Int = 0
	var aim: Int = 0

	File("day2102_puzzle_input.txt").forEachLine {

		var instruction = it.split(' ')

		if (instruction[0].equals("forward")) {
			horizontal = horizontal + instruction[1].toInt()
			depth = depth + aim * instruction[1].toInt()
		} else if (instruction[0].equals("down")) {
			aim = aim + instruction[1].toInt()
		} else if (instruction[0].equals("up")) {
			aim = aim - instruction[1].toInt()
		}
	}
	return depth*horizontal
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("*******************")
	println("--- Day 2: Dive ---")
	println("*******************")
	println("Solution for part1")
	println("   $solution1 is your final horizontal position multiplied by final depth ")
	println()
// print solution for part 2
	println("**************************")
	println("Solution for part2")
	println("   $solution2 is your final horizontal position multiplied by final depth")
	println()</code></pre>
</div>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_kotlin"><a class="anchor" href="#_day_03_kotlin"></a><a class="link" href="#_day_03_kotlin">Day 03: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_3_binary_diagnostic"><a class="anchor" href="#_day_3_binary_diagnostic"></a><a class="link" href="#_day_3_binary_diagnostic">Day 3: Binary Diagnostic</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/3" class="bare">https://adventofcode.com/2021/day/3</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2103_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_3"><a class="anchor" href="#_first_star_3"></a><a class="link" href="#_first_star_3">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Inside function <em>diagnostic_power</em> the puzzle input will be read line by line and within a loop over all elements of the string a counter for each position will be increased, if the string contains a Â´1Â´ at this position. Afterwards there are strings for gamma and epsilon set up and converted to dezimal integers. The result of the multiplication of gamma and epsilon is returned as solution for part one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun diagnostic_power(): Int {
	var count = mutableListOf(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
	var reports: Int = 0

	// search for most common bit
	File("day2103_puzzle_input.txt").forEachLine {
		reports += 1
		for (i in 0..it.length - 1) {
			if (it[i].equals('1')) {
				count[i] = count[i] + 1
			}
		}
	}

	// calculate gamma and epsilon rate out of most common bit list
	var gamma: String = ""
	var epsilon: String = ""
	count.forEach {
		if (it &gt; reports - it) {
			gamma = gamma + "1"
			epsilon = epsilon + "0"
		} else {
			gamma = gamma + "0"
			epsilon = epsilon + "1"
		}
	}

	// return power consumption
	return gamma.toInt(2) * epsilon.toInt(2)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_3"><a class="anchor" href="#_second_star_3"></a><a class="link" href="#_second_star_3">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Inside function <em>diagnostic_life</em> the puzzle input will be read into a list for O2 and one for CO2. Then we  start splitting the O2 list postition by position only keeping the part with the most common bit until there is only one entry left. Same is done for the CO2 list, only difference is, that only the list with the least common bit is kept. Both remaining entries are converted to dezimal integer and the result of the multiplication is returned as solution for part two:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun diagnostic_life(): Int {
	val list = mutableListOf&lt;String&gt;()
	val list_co2 = mutableListOf&lt;String&gt;()
	var pos: Int = 0

	// setup lists for O2 and CO2 ratings
	File("day2103_puzzle_input.txt").forEachLine {
		list.add(it)
		list_co2.add(it)
	}

	// determine O2 generator rating
	while (list.size &gt; 1) {
		var (first, second) = list.partition { it[pos].equals('1') }
		if (first.size &gt;= second.size) {
			list.clear()
			first.forEach {
				list.add(it)
			}
		} else {
			list.clear()
			second.forEach {
				list.add(it)
			}
		}
		pos += 1
	}

	// determine CO2 scrubber rating
	pos = 0

	while (list_co2.size &gt; 1) {
		var (first, second) = list_co2.partition { it[pos].equals('1') }
		if (first.size &gt;= second.size) {
			list_co2.clear()
			second.forEach {
				list_co2.add(it)
			}
		} else {
			list_co2.clear()
			first.forEach {
				list_co2.add(it)
			}
		}
		pos += 1
	}

	// return life supporting rate
	return list[0].toInt(2) * list_co2[0].toInt(2)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("********************************")
	println("--- Day 3: Binary Diagnostic ---")
	println("********************************")
	println("Solution for part1")
	println("   $solution1 is your power consumption ")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   $solution2 is your life supporting rate")
	println()</code></pre>
</div>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_kotlin"><a class="anchor" href="#_day_04_kotlin"></a><a class="link" href="#_day_04_kotlin">Day 04: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_4_giant_squid"><a class="anchor" href="#_day_4_giant_squid"></a><a class="link" href="#_day_4_giant_squid">Day 4: Giant Squid</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/4" class="bare">https://adventofcode.com/2021/day/4</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2104_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_today_i_learned"><a class="anchor" href="#_today_i_learned"></a><a class="link" href="#_today_i_learned">Today I learned</a></h5>
<div class="paragraph">
<p>I never worked with classes, but today&#8217;s puzzle seemed to be a good start for learning something about it. At the beginning I had some difficulties to transfer the boards to the class, whenever I read in the next board also the last classes' boards where cleaned. I solved it by introducing a second list which I made unmutable, I guess there are better solutions but for the start it worked out to solve the today&#8217;s puzzle.</p>
</div>
</div>
<div class="sect4">
<h5 id="_first_star_4"><a class="anchor" href="#_first_star_4"></a><a class="link" href="#_first_star_4">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>I created a class representing a bingo card with individual numbers and a method <em>next_number</em>. Evoking this method will mark all numbers matching the given number, evaluate, if already a row or column is complete and calculate the final score:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">class bingo(field: List&lt;Int&gt;) {
	// this class should represent a single bingo board. The board is initialized with it's individual numbers
	var field = field
	var fieldProgress = field.toMutableList()
	var win: Boolean = false
	var finalScore: Int = 0

	// this method is used to print the board
	fun print_board() {
		println("-- Board --")
		for (j in 0..4) {
			for (i in 0..4) {
				print("${fieldProgress[i + j * 5]} ")
			}
			println()
		}
		println()
	}

	// this method is used every time a new number is given, to check if bingo is complete and to calculate the final score
	fun nextNumber(Number: Int) {
		var currentNumber: Int = Number
		var sumOfUnmarkedNumbers: Int = 0

		// mark positions which have already fitted
		for (i in 0..fieldProgress.size - 1) {
			if (fieldProgress[i] == currentNumber) {
				fieldProgress[i] = -1
			}
		}

		// check if one row is complete - set win - claculate final score
		if (fieldProgress[0] + fieldProgress[1] + fieldProgress[2] + fieldProgress[3] + fieldProgress[4] == -5 ||
			fieldProgress[5] + fieldProgress[6] + fieldProgress[7] + fieldProgress[8] + fieldProgress[9] == -5 ||
			fieldProgress[10] + fieldProgress[11] + fieldProgress[12] + fieldProgress[13] + fieldProgress[14] == -5 ||
			fieldProgress[15] + fieldProgress[16] + fieldProgress[17] + fieldProgress[18] + fieldProgress[19] == -5 ||
			fieldProgress[20] + fieldProgress[21] + fieldProgress[22] + fieldProgress[23] + fieldProgress[24] == -5 ||
			fieldProgress[0] + fieldProgress[5] + fieldProgress[10] + fieldProgress[15] + fieldProgress[20] == -5 ||
			fieldProgress[1] + fieldProgress[6] + fieldProgress[11] + fieldProgress[16] + fieldProgress[21] == -5 ||
			fieldProgress[2] + fieldProgress[7] + fieldProgress[12] + fieldProgress[17] + fieldProgress[22] == -5 ||
			fieldProgress[3] + fieldProgress[8] + fieldProgress[13] + fieldProgress[18] + fieldProgress[23] == -5 ||
			fieldProgress[4] + fieldProgress[9] + fieldProgress[14] + fieldProgress[19] + fieldProgress[24] == -5
		) {
			win = true
			fieldProgress.forEach {
				if (it != -1) {
					sumOfUnmarkedNumbers = sumOfUnmarkedNumbers + it
				}
			}
			finalScore = currentNumber * sumOfUnmarkedNumbers
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start, the puzzle input will be read. All numbers are added to a list, for all boards a new bingo class is added to second list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// setup for reading puzzle input
	var numbers = mutableListOf&lt;Int&gt;()
	var card = mutableListOf&lt;Int&gt;()
	var cardboard = listOf&lt;Int&gt;()
	var fields = mutableListOf&lt;bingo&gt;()

	File("day2104_puzzle_input.txt").forEachLine {
		if (it.length &gt; 15) {
			var instruction = it.split(",")
			instruction.forEach { numbers.add(it.toInt()) }
		} else if (it.length &gt; 2) {
			var line: String = ""
			if (it[0].equals(' ')) {
				line = it.drop(1)
			} else {
				line = it
			}
			var instruction = line.replace("  ", " ").replace("  ", " ").split(" ")
			for (i in instruction) {
				card.add(i.toInt())
			}
		} else if (it.length &lt; 2 &amp;&amp; card.size &gt; 10) {
			cardboard = card.toList()
			fields.add(bingo(cardboard))
			card.clear()
		}
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After the preparation, two nested loop&#8217;s run over each number and each board until the first board wins, and the final score is printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// start game
	// loop through numbers until gameend, then printout final score
	var currentNumber: Int
	var outOfGame = mutableListOf&lt;Int&gt;()
	var winningScores = mutableListOf&lt;Int&gt;()

	loop@ for (i in 0..numbers.size - 1) {
		currentNumber = numbers[i]

		var xx: Int = 0
		for (j in fields) {//fields.forEach {
			if (!outOfGame.contains(xx)) {
				j.nextNumber(currentNumber)
				if (j.win) {
					outOfGame.add(xx)
					winningScores.add(j.finalScore)
					if (outOfGame.size == fields.size) {
						break@loop
					}
				}
			}
			xx += 1
		}
	}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_4"><a class="anchor" href="#_second_star_4"></a><a class="link" href="#_second_star_4">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Instead stopping after the first win, all wins are added to a list, a board which has already a complete row or column is exluded for the ongoning game. The last element of the win list is the solution for number two.</p>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("**************************")
	println("--- Day 4: Giant Squid ---")
	println("**************************")
	println("Solution for part1")
	println("   ${winningScores[0]} will your final score be if you choose that board")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   ${winningScores[winningScores.size-1]} would be the final score")
	println()</code></pre>
</div>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_kotlin"><a class="anchor" href="#_day_05_kotlin"></a><a class="link" href="#_day_05_kotlin">Day 05: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_5_hydrothermal_venture"><a class="anchor" href="#_day_5_hydrothermal_venture"></a><a class="link" href="#_day_5_hydrothermal_venture">Day 5: Hydrothermal Venture</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/5" class="bare">https://adventofcode.com/2021/day/5</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2105_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_5"><a class="anchor" href="#_first_star_5"></a><a class="link" href="#_first_star_5">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>I created a class function reading file input and separating coordinates. Then for each horizontal and vertical lines a map entry is created with value 1 or if already existing, increased by one. The function returns the number of all map entries higher than one. The function has one parameter which is by default 0, that means the evaluation of diagonal lines will be skipped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun lines(solution: Int = 0): Int {
	var ground = mutableMapOf&lt;Pair&lt;Int, Int&gt;, Int&gt;()
	var result: Int = 0

	File("day2105_puzzle_input.txt").forEachLine {
		var instruction = it.split(" -&gt; ")
		var pos1 = instruction[0].split(",")
		var pos2 = instruction[1].split(",")
		var x1: Int = pos1[0].toInt()
		var y1: Int = pos1[1].toInt()
		var x2: Int = pos2[0].toInt()
		var y2: Int = pos2[1].toInt()

		if (x1 == x2) {
			for (i in minOf(y1, y2)..maxOf(y1, y2)) {
				if (ground.contains(Pair(x1, i))) {
					ground.put(Pair(x1, i), ground.getValue(Pair(x1, i)) + 1)
				} else {
					ground.put(Pair(x1, i), 1)
				}
			}

		} else if (y1 == y2) {
			for (i in minOf(x1, x2)..maxOf(x1, x2)) {
				if (ground.contains(Pair(i, y1))) {
					ground.put(Pair(i, y1), ground.getValue(Pair(i, y1)) + 1)
				} else {
					ground.put(Pair(i, y1), 1)
				}
			}
		} else {
		// tag::lines2[]
		if (solution &gt; 0) {
				for (j in 0..(maxOf(x1, x2)-minOf(x1, x2))) {
					if (x2 &gt; x1 &amp;&amp; y2 &gt; y1 ) {
						if (ground.contains(Pair(j + minOf(x1, x2), j + minOf(y1, y2)))) {
							ground.put(
								Pair(j + minOf(x1, x2) , j + minOf(y1, y2)),
								ground.getValue(Pair(j + minOf(x1, x2), j + minOf(y1, y2))) + 1
							)
						} else {
							ground.put(Pair(j + minOf(x1, x2), j + minOf(y1, y2)), 1)
						}
					} else if (x2 &lt; x1 &amp;&amp; y2 &gt; y1) {
						if (ground.contains(Pair( maxOf(x1, x2) - j, minOf(y1,y2)+j))) {
							ground.put(
								Pair(maxOf(x1, x2) - j, minOf(y1, y2)+j),
								ground.getValue(Pair(maxOf(x1, x2) - j, minOf(y1, y2) + j)) + 1
							)
						} else {
							ground.put(Pair(maxOf(x1, x2) - j, minOf(y1, y2) +j), 1)
						}
					} else if (x2 &gt; x1 &amp;&amp; y2 &lt; y1) {
						if (ground.contains(Pair(j + minOf(x1, x2), maxOf(y1, y2) - j))) {
							ground.put(
								Pair(j + minOf(x1, x2) , maxOf(y1, y2) - j),
								ground.getValue(Pair(j + minOf(x1, x2), maxOf(y1, y2)-j)) + 1
							)
						} else {
							ground.put(Pair(j + minOf(x1, x2), maxOf(y1, y2)-j), 1)
						}
					} else if (x2 &lt; x1 &amp;&amp; y2 &lt; y1) {
						if (ground.contains(Pair(maxOf(x1, x2) - j, maxOf(y1, y2) - j))) {
							ground.put(
								Pair(maxOf(x1, x2) - j , maxOf(y1, y2) - j),
								ground.getValue(Pair(maxOf(x1, x2) - j, maxOf(y1, y2)-j)) + 1
							)
						} else {
							ground.put(Pair(maxOf(x1, x2) - j, maxOf(y1, y2)-j), 1)
						}
					}
				}
			}
		}
	}

	for ((key, value) in ground) {
		if (value &gt; 1) {
			result += 1
		}
	}

	return result
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_5"><a class="anchor" href="#_second_star_5"></a><a class="link" href="#_second_star_5">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>By invokeing the function with a parameter higher than 0 the diagonal lines will also be taken into account.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin"></code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("***********************************")
	println("--- Day 5: Hydrothermal Venture ---")
	println("***********************************")
	println("Solution for part1")
	println("   At $solution1 points at least two lines overlap ")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   At $solution2 points at least two lines overlap")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_kotlin"><a class="anchor" href="#_day_06_kotlin"></a><a class="link" href="#_day_06_kotlin">Day 06: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_6_lanternfish"><a class="anchor" href="#_day_6_lanternfish"></a><a class="link" href="#_day_6_lanternfish">Day 6: Lanternfish</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/6" class="bare">https://adventofcode.com/2021/day/6</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2106_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_6"><a class="anchor" href="#_first_star_6"></a><a class="link" href="#_first_star_6">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Within the function <em>laternfish()</em> the puzzle input is read into a list, each fish has one entry. Day by day the entry is either reduced by one or reset to 6 and a new entry added wiht value 8.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun laternfish(day: Int): Int {
	var population = mutableListOf&lt;Int&gt;()

	File("day2106_puzzle_input.txt").forEachLine {
		var instruction = it.split(",")
		instruction.forEach {
			population.add(it.toInt())
		}
	}

	for (i in 1..day) {
		for (x in 0..population.size - 1) {
			if (population[x] == 0) {
				population.add(8)
				population[x] = 6
			} else {
				population[x] -= 1
			}
		}
	}
	return population.size
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_6"><a class="anchor" href="#_second_star_6"></a><a class="link" href="#_second_star_6">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Just to increase days did not work, so I had to find a different solution. Finaly I went with a map, see <em>fun laternfish2()</em>. The keys are the reproducing days 0-8, the values the number of fishes. Every day this map is updated. At the end the sum over all values is calculated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun laternfish2(day: Long): Long {
	var result: Long = 0
	var population = mutableMapOf&lt;Int, Long&gt;()
	var new_population = mutableMapOf&lt;Int, Long&gt;()

	for (i in 0..8) {
		population.put(i, 0)
		new_population.put(i, 0)
	}

	File("day2106_puzzle_input.txt").forEachLine {
		var instruction = it.split(",")
		instruction.forEach {
			population.put(it.toInt(), population.getValue(it.toInt()) + 1)
		}
	}

	for (i in 1..day) {
		new_population.put(0, population.getValue(1))
		new_population.put(1, population.getValue(2))
		new_population.put(2, population.getValue(3))
		new_population.put(3, population.getValue(4))
		new_population.put(4, population.getValue(5))
		new_population.put(5, population.getValue(6))
		new_population.put(6, population.getValue(7) + population.getValue(0))
		new_population.put(7, population.getValue(8))
		new_population.put(8, population.getValue(0))

		for (j in 0..8) {
			population.put(j, new_population.getValue(j))
		}
	}

	for ((key, value) in population) {
		result = result + value
	}

	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("**************************")
	println("--- Day 6: Lanternfish ---")
	println("**************************")
	println("Solution for part1")
	println("   $solution1 laternfish would be there after 80 days")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   $solution2 laternfish would be there after 80 days")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_kotlin"><a class="anchor" href="#_day_07_kotlin"></a><a class="link" href="#_day_07_kotlin">Day 07: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_7_the_treachery_of_whales"><a class="anchor" href="#_day_7_the_treachery_of_whales"></a><a class="link" href="#_day_7_the_treachery_of_whales">Day 7: The Treachery of Whales</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/7" class="bare">https://adventofcode.com/2021/day/7</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2107_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_7"><a class="anchor" href="#_first_star_7"></a><a class="link" href="#_first_star_7">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>After reading the puzzle input and placing it in a list, I went through all possible positions and calculated the fuel amount. For each position the fuel amount is compared and the minimum kept as solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin"></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_7"><a class="anchor" href="#_second_star_7"></a><a class="link" href="#_second_star_7">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Same procedure as in part 1, only some adder for the calculation of the consumed fuel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin"></code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("**************************************")
	println("--- Day 7: The Treachery of Whales ---")
	println("**************************************")
	println("Solution for part1")
	println("   $minPos fuel must they spend to align to that position?")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   $minPos2 fuel must they spend to align to that position?")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_kotlin"><a class="anchor" href="#_day_08_kotlin"></a><a class="link" href="#_day_08_kotlin">Day 08: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_8_seven_segment_search"><a class="anchor" href="#_day_8_seven_segment_search"></a><a class="link" href="#_day_8_seven_segment_search">Day 8: Seven Segment Search</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/8" class="bare">https://adventofcode.com/2021/day/8</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2108_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_8"><a class="anchor" href="#_first_star_8"></a><a class="link" href="#_first_star_8">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Frist part is just spliting in put lines and searching for values 2, 4, 3, 7 and counting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// part 1
	var solution1: Int = 0

	File("day2108_puzzle_input.txt").forEachLine {
		var instruction = it.split(" | ")
		var output = instruction[1].split(" ")
		output.forEach {
			if (it.length == 2 || it.length == 4 || it.length == 3 || it.length == 7) {
				solution1 += 1
			}
		}
	}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_8"><a class="anchor" href="#_second_star_8"></a><a class="link" href="#_second_star_8">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Here I had several difficulties to sort samples out. I don&#8217;t think that this is a good example for learning, anyway it provides a correct result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// part 2
	var solution2: Int = 0
	var mapTable = mutableListOf&lt;String&gt;()
	for (i in 0..9) {
		mapTable.add("")
	}
	File("day2108_puzzle_input.txt").forEachLine {
		var instruction = it.split(" | ")
		var inp = instruction[0].split(" ")

		// sort all input values alphabetically
		var input = mutableListOf&lt;String&gt;()
		inp.forEach {
			input.add(it.toCharArray().sorted().joinToString(""))
		}

		// assigning 1, 4, 7, 8
		input.forEach {
			if (it.length == 2) {
				mapTable[1] = it
			} else if (it.length == 4) {
				mapTable[4] = it
			} else if (it.length == 3) {
				mapTable[7] = it
			} else if (it.length == 7) {
				mapTable[8] = it
			}
		}
		// assigning 5
		input.forEach {
			var help: String = ""
			mapTable[4].forEach {
				if (!mapTable[1].contains(it)) {
					help = help + it
				}
			}
			if (it.length == 5) {
				if (it.toList().containsAll(mapTable[1].toList())) {     // if it contains 1 --&gt; 3
					mapTable.set(3, it)
				} else if (it.toList().containsAll(help.toList())) {     // if it contains 4 --&gt;5
					mapTable.set(5, it)
				} else {                                                  // else --&gt; 2
					mapTable.set(2, it)
				}
			}
		}
		// assigning 6
		input.forEach {
			if (it.length == 6) {
				if (it.toList().containsAll(mapTable[3].toList())) {   		// if it contains 3 --&gt; 9
					mapTable.set(9, it)
				} else if (it.toList().containsAll(mapTable[5].toList())) {  // if it contains 5 --&gt; 9
					mapTable.set(6, it) // if it containns 4 --&gt; 9
				} else {
					mapTable.set(0, it)
				}
			}
		}

		var out = instruction[1].split(" ")
		// sort all input values alphabetically
		var output = mutableListOf&lt;String&gt;()
		out.forEach {
			output.add(it.toCharArray().sorted().joinToString(""))
		}
		solution2 =
			solution2 + mapTable.indexOf(output[0]) * 1000 + mapTable.indexOf(output[1]) * 100 + mapTable.indexOf(output[2]) * 10 + mapTable.indexOf(output[3])
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("***********************************")
	println("--- Day 8: Seven Segment Search ---")
	println("***********************************")
	println("Solution for part1")
	println("   $solution1 times do digits 1, 4, 7, or 8 appear")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   You get $solution2 if you add up all of the output values")
	println()</code></pre>
</div>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_kotlin"><a class="anchor" href="#_day_09_kotlin"></a><a class="link" href="#_day_09_kotlin">Day 09: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_9_smoke_basin"><a class="anchor" href="#_day_9_smoke_basin"></a><a class="link" href="#_day_9_smoke_basin">Day 9: Smoke Basin</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/9" class="bare">https://adventofcode.com/2021/day/9</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2109_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_9"><a class="anchor" href="#_first_star_9"></a><a class="link" href="#_first_star_9">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>For the first part I read in the puzzle input and added a frame outside, one line with '9' on each side. For evalation of risk level, I went through the map and checked, if the adjacent tiles are higher or lower. If all are lower, you found a sink and added it to the result (+1)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var solution1: Int = 0
	var solution2: Int
	var solution2_results = mutableListOf&lt;Int&gt;()
	var heightmap = mutableListOf&lt;Int&gt;()
	var width: Int = 0
	var height: Int = 0

	// read puzzle input to evaluate width and height of grid
	File("day2109_puzzle_input.txt").forEachLine {
		width = it.length
		height += 1
	}

	// add a frame to grid, makes following evaluations easier, you don't have to check if value is out of grid at borders
	width = width + 2
	height = height + 2
	for (i in 0..width - 1) {
		heightmap.add(9)
	}

	// read puzzle input into list
	File("day2109_puzzle_input.txt").forEachLine {
		heightmap.add(9)
		it.forEach {
			heightmap.add(it.toString().toInt())
		}
		heightmap.add(9)
	}
	for (i in 0..width - 1) {
		heightmap.add(9)
	}

	// check for sinks and add up risk level, for each sink start fun smokeBasin to get size of basin
	for (y in 1..height - 2) {
		for (x in 1..width - 2) {
			if (heightmap[x + y * width] &lt; heightmap[(x - 1) + (y) * width] &amp;&amp; heightmap[x + y * width] &lt; heightmap[(x + 1) + (y) * width] &amp;&amp; heightmap[x + y * width] &lt; heightmap[(x) + (y + 1) * width] &amp;&amp; heightmap[x + y * width] &lt; heightmap[(x) + (y - 1) * width]) {
				solution1 = solution1 + heightmap[x + y * width] + 1
				solution2_results.add(smokeBasin(x, y, heightmap, width, height))
			}
		}
	}

	// sort list to find highest 3
	solution2_results.sort()
	solution2 = solution2_results[solution2_results.size-1] * solution2_results[solution2_results.size-2] * solution2_results[solution2_results.size-3]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_9"><a class="anchor" href="#_second_star_9"></a><a class="link" href="#_second_star_9">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>The second part is nested into part one, whenever a sink is identified, a function is called, which evaluates the size of the basin arround. All basins are stored into a list, the result is calculated by multiplication of the three largest.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun smokeBasin(input1: Int, input2: Int, input3: List&lt;Int&gt;, input4: Int, input5: Int): Int {
	var xpos = input1
	var ypos = input2
	var map = mutableListOf&lt;Char&gt;()
	var width = input4
	var height = input5
	var result: Int = 1

	input3.forEach {
		map.add((it + 48).toChar())
	}
	map.set(xpos + ypos * width, 'x')

	var searchEnd: Boolean = false
	while (!searchEnd) {
		searchEnd = true
		for (y in 1..height - 2) {
			for (x in 1..width - 2) {
				if (map[x + y * width].isDigit()) { // check if digit (no evaluation for already placed 'x')
					if (map[x + y * width].toString().toInt() &lt; 9 &amp;&amp; map[(x - 1) + (y) * width] == 'x') {
						result = result + 1
						map.set(x + y * width, 'x')
						searchEnd = false
					} else if (map[x + y * width].toString().toInt() &lt; 9 &amp;&amp; map[(x + 1) + (y) * width] == 'x') {
						result = result + 1
						map.set(x + y * width, 'x')
						searchEnd = false
					} else if (map[x + y * width].toString().toInt() &lt; 9 &amp;&amp; map[(x) + (y - 1) * width] == 'x') {
						result = result + 1
						map.set(x + y * width, 'x')
						searchEnd = false
					} else if (map[x + y * width].toString().toInt() &lt; 9 &amp;&amp; map[(x) + (y + 1) * width] == 'x') {
						result = result + 1
						map.set(x + y * width, 'x')
						searchEnd = false
					}

				} // if digit
			} //end for x
		} // end for y
	} // searchEnd
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("**************************")
	println("--- Day 9: Smoke Basin ---")
	println("**************************")
	println("Solution for part1")
	println("   $solution1 is the sum of the risk levels of all low points on your heightmap")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   You get $solution2 if you add up all of the output values")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_kotlin"><a class="anchor" href="#_day_10_kotlin"></a><a class="link" href="#_day_10_kotlin">Day 10: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_10_syntax_scoring"><a class="anchor" href="#_day_10_syntax_scoring"></a><a class="link" href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/10" class="bare">https://adventofcode.com/2021/day/10</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2110_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_today_i_learned_2"><a class="anchor" href="#_today_i_learned_2"></a><a class="link" href="#_today_i_learned_2">Today I learned</a></h5>
<div class="paragraph">
<p>The conditions for the if construction got longer and longer, which was not comfortable to edit and to read. So I started to try to solve it with lambda operations, since Peter already animated me some days ago to investigate in this. I guess the result is more readable, and it was also more easy to edit and check for typos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_first_star_10"><a class="anchor" href="#_first_star_10"></a><a class="link" href="#_first_star_10">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Each line will be stripped iterative of legal pairs of chunks until no legal pair is found any more. Then the remaining string is checked, if a wrong closing is in, which means it is a corrupt line and will be part of result calculation or otherwise put in a list already for part 2 (added after revealing part2)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	File("day2110_puzzle_input.txt").forEachLine {
		var instruction = it
		var searchEnd: Boolean = false
		var pattern0 = arrayOf("()", "[]", "{}", "&lt;&gt;")
		var pattern1 = arrayOf("[)", "{)", "&lt;)")
		var pattern2 = arrayOf("(]", "{]", "&lt;]")
		var pattern3 = arrayOf("(}", "[}", "&lt;}")
		var pattern4 = arrayOf("(&gt;", "[&gt;", "{&gt;")

		// remove iterative all legal pairs of chunks in string
		while (!searchEnd) {
			if (pattern0.any { instruction.contains(it) }) {
				//if (instruction.contains("()") || instruction.contains("&lt;&gt;") || instruction.contains("[]") || instruction.contains("{}")) {
				instruction = instruction.replace("()", "")
				instruction = instruction.replace("[]", "")
				instruction = instruction.replace("{}", "")
				instruction = instruction.replace("&lt;&gt;", "")
			} else {
				searchEnd = true
			}
		}
		// determine if there is a wrong closing character in remaining string
		if (pattern1.any { instruction.contains(it) }) {
			points.put(3, points.getValue(3) + 1)
		} else if (pattern2.any { instruction.contains(it) }) {
			points.put(57, points.getValue(57) + 1)
		} else if (pattern3.any { instruction.contains(it) }) {
			points.put(1197, points.getValue(1197) + 1)
		} else if (pattern4.any { instruction.contains(it) }) {
			points.put(25137, points.getValue(25137) + 1)
		} else {
			// add all correct lines to a list, revert them already for later calculation of score for part2
			correctInstructions.add(instruction.reversed())
		}
	}

	solution1 = 3*points.getValue(3) + 57*points.getValue(57) + 1197*points.getValue(1197) + 25137*points.getValue(25137)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_10"><a class="anchor" href="#_second_star_10"></a><a class="link" href="#_second_star_10">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>For each incomplete but correct line the total score algorithm is applied and the value put to a list. The middle value of the list is the result asked for.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// evaluate total score for all incomplete but not corrupted lines
	correctInstructions.forEach {
		var totalScore: Long = 0
		it.forEach {
			if (it.equals('(')) {
				totalScore = totalScore * 5 + 1
			} else if (it.equals('[')) {
				totalScore = totalScore * 5 + 2
			} else if (it.equals('{')) {
				totalScore = totalScore * 5 + 3
			} else if (it.equals('&lt;')) {
				totalScore = totalScore * 5 + 4
			}
		}
		scoresSolution2.add(totalScore)
	}

	scoresSolution2.sort()
	solution2 = scoresSolution2[scoresSolution2.size / 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("******************************")
	println("--- Day 10: Syntax Scoring ---")
	println("******************************")
	println("Solution for part1")
	println("   $solution1 is the total syntax error score for those errors")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   $solution2 is the middle score")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_kotlin"><a class="anchor" href="#_day_11_kotlin"></a><a class="link" href="#_day_11_kotlin">Day 11: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_11_dumbo_octopus"><a class="anchor" href="#_day_11_dumbo_octopus"></a><a class="link" href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/11" class="bare">https://adventofcode.com/2021/day/11</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2111_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_11"><a class="anchor" href="#_first_star_11"></a><a class="link" href="#_first_star_11">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>The puzzle input will be read into a array as integers. Then the rules are applied.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First: Increase each octopus by one. To show that a octopus is ready to flash (&gt;9), I choosed to just set it to 100, at this time I already started counting.</p>
</li>
<li>
<p>Second: Iterative go through all of the tiles and if it is an octopus readiy to flash, increase all adjacent tiles</p>
</li>
<li>
<p>Third: Set all flashed tiles to zero.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After 100 rounds the flash counter will be reported.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var solution1: Int = 0
	var solution2: Int = 0
	var dumboField = Array(10) { Array(10) { 0 } }
	var countFlash: Int = 0
	var greaterNine: Boolean
	var n: Int = 1
	var stepPartTwo: Int
	var allDumboFlash = false

	// read puzzle input in array
	var j: Int = 0
	File("day2111_puzzle_input.txt").forEachLine {
		for (i in 0..it.length - 1) {
			dumboField[i][j] = it[i].toString().toInt()
		}
		j += 1
	}

	// run for at least 100 steps or until all dumbo's flash at same time
	while (!allDumboFlash || n &lt; 101) {
		greaterNine = false

		// first step: increase every tile by 1
		for (y in 0..9) {
			for (x in 0..9) {
				dumboField[x][y] = dumboField[x][y] + 1
				if (dumboField[x][y] &gt; 9) {
					greaterNine = true
				}
			}
		}

		// second step: if tile &gt; 9, flash and increase energy level of nighbours until no tile &gt; 9
		while (greaterNine) {  // loop while grid.contains 9
			greaterNine = false

			// go through field and search &gt; nine
			for (y in 0..9) {
				for (x in 0..9) {
					if (dumboField[x][y] &gt; 9 &amp;&amp; dumboField[x][y] &lt; 100) {
						// set field to burst (= 100), increase burstcount solution1 +=
						dumboField[x][y] = 100
						// count number of bursts
						countFlash += 1
						// now increase adjacent tiles
						for (dy in -1..1) {
							for (dx in -1..1) {
								if (!(dx == 0 &amp;&amp; dy == 0)) {
									// if in grid increase adjacent tiles
									if ((y + dy) &gt;= 0 &amp;&amp; (y + dy) &lt;= 9 &amp;&amp; (x + dx) &gt;= 0 &amp;&amp; (x + dx) &lt;= 9) {
										if (dumboField[x + dx][y + dy] &lt; 100) {
											dumboField[x + dx][y + dy] = dumboField[x + dx][y + dy] + 1
										}
										if (dumboField[x + dx][y + dy] &gt; 9) {
											greaterNine = true
										}
									}
								}
							}
						}
					}
				}
			}
		}    // loop greaterNine end

		// 100 turns --&gt; solution for part1
		if (n == 100) {
			solution1 = countFlash
		}

		// third step: set all tiles flashed in current turn to zero
		stepPartTwo = 0
		for (y in 0..9) {
			for (x in 0..9) {
				if (dumboField[x][y] == 100) {
					dumboField[x][y] = 0
					stepPartTwo += 1

					// check if all dumbos flashed at same time --&gt; solution for part2
					if (stepPartTwo == 100) {
						solution2 = n
						allDumboFlash = true
					}
				}
			}
		}
		n += 1
	}  // end loop allDumboFlash</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_11"><a class="anchor" href="#_second_star_11"></a><a class="link" href="#_second_star_11">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>This is integrated in the solution for part one, when applying the third rule, setting all flashed tiles to zero, also a counter is implemented. If the counter is 100, then the solution for part 2 is reached.</p>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("*****************************")
	println("--- Day 11: Dumbo Octopus ---")
	println("*****************************")
	println("Solution for part1")
	println("   $solution1 total flashes are there after 100 steps")
	println()
// print solution for part 2
	println("*********************************")
	println("Solution for part2")
	println("   $solution2 is the first step during which all octopuses flash")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_add_on"><a class="anchor" href="#_add_on"></a><a class="link" href="#_add_on">Add On</a></h5>
<div class="paragraph">
<p>After some discussion with Peter about using lists or arrays I created a verson based on a list and one on an array. Both are running 1000 times and the execution time is measured. I run it several times, but there was not realy a valuable result reachable, one time the array version was faster, one time the list. My expectation would have been, that the array version is faster.</p>
</div>
<a id="day12" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_12_kotlin"><a class="anchor" href="#_day_12_kotlin"></a><a class="link" href="#_day_12_kotlin">Day 12: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_12_passage_pathing"><a class="anchor" href="#_day_12_passage_pathing"></a><a class="link" href="#_day_12_passage_pathing">Day 12: Passage Pathing</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/12" class="bare">https://adventofcode.com/2021/day/12</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2112_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_12"><a class="anchor" href="#_first_star_12"></a><a class="link" href="#_first_star_12">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>All possible pathes are build up step by step, each new path is checked if following the rule. As an extension for part 2 the 'followPath' function has an input paramter which is able to switch to a new rule. All path which came to an end are stored in a separate list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun followPath(input1: Int): Int {
	var segments = mutableListOf&lt;Pair&lt;String, String&gt;&gt;()
	var searchPath = mutableListOf&lt;String&gt;()
	var searchPathNew = mutableListOf&lt;String&gt;()
	var validPath = mutableListOf&lt;String&gt;()
	var searchEnd: Boolean = false
	var currentPath: String
	var newCurrentPath: String
	var ruleCheckPassed: Boolean = false

	File("day2112_puzzle_input.txt").forEachLine {
		var instruction = it.split("-")
		if (instruction[0] == "start") {
			searchPath.add(instruction[0] + "," + instruction[1])
		} else if (instruction[1] == "start") {
			searchPath.add(instruction[1] + "," + instruction[0])
		} else {
			segments.add(Pair(instruction[0], instruction[1]))
		}
	}

	while (!searchEnd) {

		searchEnd = true

		searchPath.forEach {
			currentPath = it
			var instruction = it.split(",")
			var lastSegment = instruction[instruction.size - 1]

			segments.forEach {
				if (lastSegment == it.first) {
					newCurrentPath = currentPath + "," + it.second
					if (it.second == "end") {
						//if (!validPath.contains(newCurrentPath)) {
							validPath.add(newCurrentPath)
						//}
					} else {
						if (input1 == 1) {
							ruleCheckPassed = !(it.second.toLowerCase() == it.second &amp;&amp; currentPath.contains(it.second))
						} else if (input1 == 2) {
							ruleCheckPassed = ruleCheck2(newCurrentPath.drop(6))
						}
						if (ruleCheckPassed) {
							searchPathNew.add(newCurrentPath)
							searchEnd = false
						}
					}
				} else if (lastSegment == it.second) {
					newCurrentPath = currentPath + "," + it.first
					if (it.first == "end") {
						//if (!validPath.contains(newCurrentPath)) {
							validPath.add(newCurrentPath)
						//}
					} else {
						// check rule
						if (input1 == 1) {
							ruleCheckPassed = !(it.first.toLowerCase() == it.first &amp;&amp; currentPath.contains(it.first))
						} else if (input1 == 2) {
							// rule for part 2
							ruleCheckPassed = ruleCheck2(newCurrentPath.drop(6))
						}
						if (ruleCheckPassed) {
							searchPathNew.add(newCurrentPath)
							searchEnd = false
						}
					}
				}
			}
		}
		searchPath.clear()
		searchPath.addAll(searchPathNew)
		searchPathNew.clear()
	}
	return validPath.size
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_12"><a class="anchor" href="#_second_star_12"></a><a class="link" href="#_second_star_12">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Solution for this part is integrated in function 'followPath' by just choosing an other rule to be applied. Since the rule does need some lines of code, I separated it into a new function 'ruleCheck2'</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun ruleCheck2(input1: String): Boolean {

	var count = mutableMapOf&lt;String, Int&gt;()
	var instruction = input1.split(",")

	instruction.forEach {
		if (it.toLowerCase() == it) {
			if (count.containsKey(it)) {
				count.put(it, count.getValue(it) + 1)
				if (count.getValue(it) &gt; 2) {
					return false
				}
			} else {
				count.put(it, 1)
			}
		}
	}
	var sum: Int = 0
	for ((key, value) in count.entries) {
		sum = sum + value
	}
	if (sum &gt; count.size + 1) {
		return false
	}
	return true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("*******************************")
	println("--- Day 12: Passage Pathing ---")
	println("*******************************")
	println("Solution for part1")
	println("   $solution1 paths through this cave system are there that visit small caves at most once")
	println()
// print solution for part 2
	println("*******************************")
	println("Solution for part2")
	println("   $solution2 how many paths through this cave system are there")
	println()
// end::output[]
//}</code></pre>
</div>
</div>
<a id="day13" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_13_kotlin"><a class="anchor" href="#_day_13_kotlin"></a><a class="link" href="#_day_13_kotlin">Day 13: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_13_transparent_origami"><a class="anchor" href="#_day_13_transparent_origami"></a><a class="link" href="#_day_13_transparent_origami">Day 13: Transparent Origami</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/13" class="bare">https://adventofcode.com/2021/day/13</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2113_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_13"><a class="anchor" href="#_first_star_13"></a><a class="link" href="#_first_star_13">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>First the width and the height of the samples is identified. Then a list is set up for a grid, all points which are not included in the samples are marked with ".", all samples are marked with "#".</p>
</div>
<div class="paragraph">
<p>Then the rules for folding are applied, after each folding step the grid is reduced and width or height are adapted. After the first fold the number of marked dots is caluclated for the solution of part 1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// go trough each fold instruction
	var firstInstruction : Boolean = true
	foldInstruction.forEach {
		var instruction = it.split("=")
		if (instruction[0] == "y") {
			// do the folding
			for (y in instruction[1].toInt()..height - 1) {
				for (x in 0..width - 1) {
					if (markedPoints[x + y * width] == "#") {
						markedPoints[x + (instruction[1].toInt() - (y - instruction[1].toInt())) * width] =
							markedPoints[x + y * width]
					}
				}
			}
			// create new list
			height = instruction[1].toInt()
			for (y in 0..height - 1) {
				for (x in 0..width - 1) {
					newMarkedPoints.add(markedPoints[x + y * width])
				}
			}
			// exchange lists
			markedPoints.clear()
			markedPoints.addAll(newMarkedPoints)
			newMarkedPoints.clear()

		} else if (instruction[0] == "x") {
			// do the folding
			for (y in 0..height - 1) {
				for (x in instruction[1].toInt()..width - 1) {
					if (markedPoints[x + y * width] == "#") {
						markedPoints[(instruction[1].toInt() - (x - instruction[1].toInt())) + y * width] =
							markedPoints[x + y * width]
					}
				}
			}
			// create new list
			for (y in 0..height - 1) {
				for (x in 0..instruction[1].toInt() - 1) {
					newMarkedPoints.add(markedPoints[x + y * width])
				}
			}
			width = instruction[1].toInt()
			// exchange lists
			markedPoints.clear()
			markedPoints.addAll(newMarkedPoints)
			newMarkedPoints.clear()
		}
		if (firstInstruction) {
				solution1 = markedPoints.count() { it == "#" }
			firstInstruction = false
		}
	}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_13"><a class="anchor" href="#_second_star_13"></a><a class="link" href="#_second_star_13">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Instead of conting all dots after first fold, folding will continue over all instructions and the resulting grid is printed out.</p>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("***********************************")
	println("--- Day 13: Transparent Origami ---")
	println("***********************************")
	println("Solution for part1")
	println("   $solution1 dots are visible after completing just the first fold instruction on your transparent paper")
	println()
// print solution for part 2
	println("***********************************")
	println("Solution for part2")
	for (y in 0..height - 1) {
		for (x in 0..width - 1) {
			print(markedPoints[x + y * width])
		}
		println()
	}
	println("   do you use to activate the infrared thermal imaging camera system")
	println()</code></pre>
</div>
</div>
<a id="day14" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_14_kotlin"><a class="anchor" href="#_day_14_kotlin"></a><a class="link" href="#_day_14_kotlin">Day 14: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_14_extended_polymerization"><a class="anchor" href="#_day_14_extended_polymerization"></a><a class="link" href="#_day_14_extended_polymerization">Day 14: Extended Polymerization</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/14" class="bare">https://adventofcode.com/2021/day/14</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2114_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_14"><a class="anchor" href="#_first_star_14"></a><a class="link" href="#_first_star_14">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>fun poly() will read puzzle input. For each pair of letters in the initial template the rule is applied by building up a new string. After repeating this 10 times, count the occurency of all letters and return max - min.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun poly(input1: Int): Int {
	var rules = mutableMapOf&lt;String, String&gt;()
	var polyTemp: String = ""

	File("day2114_puzzle_input.txt").forEachLine {
		if (it != "") {
			if (!it.contains("-&gt;")) {
				polyTemp = it
			} else {
				var instruction = it.split(" -&gt; ")
				rules.put(instruction[0], instruction[1])
			}
		}
	}


	//iterate input1 number of steps and create new string with replacement of each pair with given rules
	var newPolyTemp: String = polyTemp.take(1)

	for (i in 1..input1) {
		for (j in 0..polyTemp.length - 2) {
			if (rules.containsKey(polyTemp.subSequence(j, j + 2).toString())) {
				newPolyTemp = newPolyTemp + rules.getValue(polyTemp.subSequence(j, j + 2).toString()) + polyTemp[j + 1]
			} else
				newPolyTemp = newPolyTemp + polyTemp[j + 1]
		}
		polyTemp = newPolyTemp
		newPolyTemp = polyTemp.take(1)
	}

	// count elements and determine max and min value
	var countMap = mutableMapOf&lt;Char, Int&gt;()
	polyTemp.forEach {
		if (countMap.contains(it)) {
			countMap.set(it, countMap.getValue(it) + 1)
		} else {
			countMap.put(it, 1)
		}
	}

	var max: Int = 0
	var min: Int = 10000
	countMap.forEach {
		if (it.value &gt; max) {
			max = it.value
		} else if (it.value &lt; min) {
			min = it.value
		}
	}
	return max - min
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_14"><a class="anchor" href="#_second_star_14"></a><a class="link" href="#_second_star_14">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>In theory, same function could work, but it takes much to long. So there is fun polyAdv(), each combination of a pair of letters will be stored with it&#8217;s number of occurency and for the next round with applying the rules new pairs are generated. After repeating this 40 times,  count the occurency of all letters and return max - min.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">fun polyAdv(input1: Int): Long {

	var rules = mutableMapOf&lt;String, String&gt;()
	var polyTemp: String = ""

	File("day2114_puzzle_input.txt").forEachLine {
		if (it != "") {
			if (!it.contains("-&gt;")) {
				polyTemp = it
			} else {
				var instruction = it.split(" -&gt; ")
				rules.put(instruction[0], instruction[1])
			}
		}
	}

	//setup Map with subSequences and counter for occurency
	var polyPairs = mutableMapOf&lt;String, Long&gt;()
	var newPolyPairs = mutableMapOf&lt;String, Long&gt;()

	polyPairs.put(polyTemp.takeLast(1), 1)
	for (j in 0..polyTemp.length - 2) {
		if (polyPairs.containsKey(polyTemp.subSequence(j, j + 2).toString())) {
			polyPairs.set(
				polyTemp.subSequence(j, j + 2).toString(),
				polyPairs.getValue(polyTemp.subSequence(j, j + 2).toString()) + 1
			)
		} else {
			polyPairs.put(polyTemp.subSequence(j, j + 2).toString(), 1)
		}
	}

	// iterate input1 number of steps and determine, how many new sequences will be created for the current step
	for (i in 1..input1) {
		polyPairs.forEach {
			if (rules.contains(it.key)) {

				var new1 = it.key.take(1) + rules.getValue(it.key)
				var new2 = rules.getValue(it.key) + it.key.takeLast(1)

				if (newPolyPairs.containsKey(new1)) {
					newPolyPairs.put(
						new1,
						newPolyPairs.getValue(new1) + it.value
					)
				} else {
					newPolyPairs.put(new1, it.value)
				}
				if (newPolyPairs.containsKey(new2)) {
					newPolyPairs.put(new2, newPolyPairs.getValue(new2) + it.value)
				} else {
					newPolyPairs.put(new2, it.value)
				}
			} else {
				newPolyPairs.put(it.key, it.value)
			}
		}
		polyPairs.clear()
		polyPairs.putAll(newPolyPairs)
		newPolyPairs.clear()
	}

	// count elements and determine max and min value
	var countMap = mutableMapOf&lt;String, Long&gt;()

	for ((key, value) in polyPairs) {
		if (countMap.contains(key.take(1))) {
			countMap.set(key.take(1), countMap.getValue(key.take(1)) + value)
		} else {
			countMap.put(key.take(1), value)
		}
	}

	var max: Long = countMap.getValue(polyTemp.take(1))
	var min: Long = countMap.getValue(polyTemp.take(1))

	countMap.forEach {
		if (it.value &gt; max) {
			max = it.value
		} else if (it.value &lt; min) {
			min = it.value
		}
	}

	return (max - min)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("****************************************")
	println("--- Day  14: Extended Polymerization ---")
	println("****************************************")
	println("Solution for part1")
	println("   $solution1 you get if you take the quantity of the most common element and subtract the quantity of the least common element")
	println()
// print solution for part 2
	println("*******************************")
	println("Solution for part2")
	println("   $solution2 you get if you take the quantity of the most common element and subtract the quantity of the least common element")
	println()</code></pre>
</div>
</div>
<a id="day17" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_17_kotlin"><a class="anchor" href="#_day_17_kotlin"></a><a class="link" href="#_day_17_kotlin">Day 17: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_17_tick_shot"><a class="anchor" href="#_day_17_tick_shot"></a><a class="link" href="#_day_17_tick_shot">Day 17: Tick Shot</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/17" class="bare">https://adventofcode.com/2021/day/17</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2117_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_15"><a class="anchor" href="#_first_star_15"></a><a class="link" href="#_first_star_15">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>First of all, read the puzzle input and determine target area.</p>
</div>
<div class="paragraph">
<p>The trajectory can be separated in x part and y part. So first all possible x velocites, which are able to reach target area, are calculated and stored into a list <em>validXvel</em>. The range can be reduced to 1 (0 and negative will never reach) to xmax (&gt; xmax will overshoot already in first step).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// if x is  &gt; xmax, initial window will be missed already after the first step.
	// find possible x velocities which are able to reach target window
	for (i in 1..xmax) {
		xvel = i
		while (true) {
			xpos = xpos + xvel
			xvel = maxOf(xvel - 1, 0)
			if (xpos &gt;= xmin &amp;&amp; xpos &lt;= xmax) {
				validXvel.add(i)
				break
			} else if (xpos &gt; xmax) {
				break
			} else if (xvel == 0) {
				break
			}
		}
		xpos = 0
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The minimum x velocity will need the most steps, so that is also the velocity which will enable to reach highest y position. In the first version therefore all possible y velocities for only the smalles x velocity where calculated and the highest position reached is kept as result for part one.</p>
</div>
<div class="paragraph">
<p>As a modification for part 2 all possible y velocities are not only calculated for the smallest x velocity, but for all possible x velocities. The sum of all possible x and y velocities is added up as a result for part2.
Similar to narrowing the range of x velocities, y velocities can be narrowed from ymin (lower will already undershot in first step) to -ymin (asssuming a target area lower then 0 level and that a probe crossing zero will always have reached absolute value of starting velocity and therefore also definitly undershoot)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var ypos: Int = 0
	var yvel: Int
	var validYvel = mutableListOf&lt;Int&gt;()
	var reachedYMax: Int = 0
	var reachedYMaxOverall: Int = 0
	var numberOfInit: Int = 0

	validXvel.forEach {
		xvel = it

		// if starts lower ymin, target will already be missed with first step. If y &gt; abs(ymin), target will also be missed
		for (i in ymin..-ymin) {
			yvel = i
			while (true) {
				xpos = xpos + xvel
				xvel = maxOf(xvel - 1, 0)
				ypos = ypos + yvel
				yvel = yvel - 1

				if (ypos &gt; reachedYMax) {
					reachedYMax = ypos
				}

				if (ypos &gt;= ymin &amp;&amp; ypos &lt;= ymax &amp;&amp; xpos &gt;= xmin &amp;&amp; xpos &lt;= xmax) {
					validYvel.add(i)
					if (reachedYMax &gt; reachedYMaxOverall) {
						reachedYMaxOverall = reachedYMax
					}
					break
				} else if (ypos &lt; ymin) {
					break
				}
			}
			xpos = 0
			xvel = it
			ypos = 0
			reachedYMax = 0
		}
		numberOfInit = numberOfInit + validYvel.size
		validYvel.clear()
	}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_15"><a class="anchor" href="#_second_star_15"></a><a class="link" href="#_second_star_15">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>See description above.</p>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("*************************")
	println("--- Day 17: Tick Shot ---")
	println("*************************")
	println("Solution for part1")
	println("   $reachedYMaxOverall is the highest y position it reaches on this trajectory")
	println()
// print solution for part 2
	println("*************************")
	println("Solution for part2")
	println("   $numberOfInit many distinct initial velocity values cause the probe to be within the target area after any step")
	println()</code></pre>
</div>
</div>
<a id="day18" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_18_kotlin"><a class="anchor" href="#_day_18_kotlin"></a><a class="link" href="#_day_18_kotlin">Day 18: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_18_snailfish"><a class="anchor" href="#_day_18_snailfish"></a><a class="link" href="#_day_18_snailfish">Day 18: Snailfish</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/18" class="bare">https://adventofcode.com/2021/day/18</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2118_1.kts</em> in the command line or _kotlin day218_2.kts</p>
</div>
<div class="sect4">
<h5 id="_first_star_16"><a class="anchor" href="#_first_star_16"></a><a class="link" href="#_first_star_16">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>General idea is to create to lists for each snailfish number, one contains all values, the second one contains the level. The level is created by counting the input string&#8217;s brackets, an opening bracket will increase the level, an closing bracket will decrease. As soon as a digit is regcognised in the string, the value and the level are stored in the corresponding lists. When adding a second snailfish number, it is added to the lists and afterwards the level of all entries is increased.</p>
</div>
<div class="paragraph">
<p>After that within a while loop the reduction is started following the rules, manipulating entries of both lists. After all values are added, the magnitude is calculated</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var snailFishNumber = mutableListOf&lt;Int&gt;()
	var snailFishNumLev = mutableListOf&lt;Int&gt;()
	var levelCount: Int = 0
	var startAddition: Boolean = false

	File("day2118_puzzle_input.txt").forEachLine {
		it.forEach {
			if (it == '[') {
				levelCount += 1
			} else if (it == ']') {
				levelCount -= 1
			} else if (it.isDigit()) {
				snailFishNumber.add(it.toString().toInt())
				snailFishNumLev.add(levelCount)
			}
		}

		if (startAddition) {
			// values are now added, therefore Level has to  be increased by one
			for (i in 0..snailFishNumLev.size - 1) {
				snailFishNumLev[i] += 1
			}

			//  reduce snail fish number
			var nestInProg: Boolean = true
			var j: Int = 0
			while (nestInProg) {// while ....
				j += 1
				var nested = snailFishNumLev.indexOf(5)
				var greater: Int = -1
				for (i in 0..snailFishNumber.size - 1) {
					if (snailFishNumber[i] &gt; 9) {
						greater = i
						break
					}
				}

				if (nested &gt; -1) {
					if (nested == 0) {
						snailFishNumber[nested + 2] = snailFishNumber[nested + 2] + snailFishNumber[nested + 1]
						snailFishNumber[nested + 1] = 0
						snailFishNumLev[nested + 1] -= 1
						snailFishNumber.removeAt(0)
						snailFishNumLev.removeAt(0)
					} else if (nested == snailFishNumber.size - 2) {
						snailFishNumber[nested - 1] = snailFishNumber[nested - 1] + snailFishNumber[nested]
						snailFishNumber[nested] = 0
						snailFishNumLev[nested] -= 1
						snailFishNumber.removeAt(nested + 1)
						snailFishNumLev.removeAt(nested + 1)
					} else {
						snailFishNumber[nested - 1] = snailFishNumber[nested - 1] + snailFishNumber[nested]
						snailFishNumber[nested + 2] = snailFishNumber[nested + 2] + snailFishNumber[nested + 1]
						snailFishNumber[nested + 1] = 0
						snailFishNumLev[nested + 1] -= 1
						snailFishNumber.removeAt(nested)
						snailFishNumLev.removeAt(nested)
					}

				} else if (greater &gt; -1) {
					var value = snailFishNumber[greater]
					snailFishNumber[greater] = value / 2
					snailFishNumber.add(greater + 1, value / 2 + value % 2)
					snailFishNumLev[greater] = snailFishNumLev[greater] + 1
					snailFishNumLev.add(greater, snailFishNumLev[greater])
				} else if (nested == -1 &amp;&amp; greater == -1) {
					nestInProg = false
				}

			}// end while
		}
		startAddition = true
	}

	println(snailFishNumLev)
	println(snailFishNumber)
	println()

	// calculate magnitude
	while(snailFishNumLev.contains(4)) {
		var lowLev = snailFishNumLev.indexOf(4)
		snailFishNumber[lowLev] = snailFishNumber[lowLev]*3 + snailFishNumber[lowLev+1]*2
		snailFishNumLev[lowLev]	= snailFishNumLev[lowLev]- 1
		snailFishNumber.removeAt(lowLev + 1)
		snailFishNumLev.removeAt(lowLev + 1)
	}
	while(snailFishNumLev.contains(3)) {
		var lowLev = snailFishNumLev.indexOf(3)
		snailFishNumber[lowLev] = snailFishNumber[lowLev]*3 + snailFishNumber[lowLev+1]*2
		snailFishNumLev[lowLev]	= snailFishNumLev[lowLev]- 1
		snailFishNumber.removeAt(lowLev + 1)
		snailFishNumLev.removeAt(lowLev + 1)
	}
	while(snailFishNumLev.contains(2)) {
		var lowLev = snailFishNumLev.indexOf(2)
		snailFishNumber[lowLev] = snailFishNumber[lowLev]*3 + snailFishNumber[lowLev+1]*2
		snailFishNumLev[lowLev]	= snailFishNumLev[lowLev]- 1
		snailFishNumber.removeAt(lowLev + 1)
		snailFishNumLev.removeAt(lowLev + 1)
	}
	while(snailFishNumber.size &gt; 1) {
		snailFishNumber[0] = snailFishNumber[0]*3 + snailFishNumber[1]*2

		snailFishNumber.removeAt(1)
	}

	println("magnitude: $snailFishNumber")
	println()


solution1 = snailFishNumber[0]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_16"><a class="anchor" href="#_second_star_16"></a><a class="link" href="#_second_star_16">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Here only some modifications are necessary to run through all possible combinations of values to add, meanwhile the largest value is keept.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var snailFishNumber = mutableListOf&lt;Int&gt;()
	var snailFishNumLev = mutableListOf&lt;Int&gt;()
	var levelCount: Int = 0
	var startAddition: Boolean = false

	File("day2118_puzzle_input.txt").forEachLine {
		it.forEach {
			if (it == '[') {
				levelCount += 1
			} else if (it == ']') {
				levelCount -= 1
			} else if (it.isDigit()) {
				snailFishNumber.add(it.toString().toInt())
				snailFishNumLev.add(levelCount)
			}
		}

		if (startAddition) {
			// values are now added, therefore Level has to  be increased by one
			for (i in 0..snailFishNumLev.size - 1) {
				snailFishNumLev[i] += 1
			}

			//  reduce snail fish number
			var nestInProg: Boolean = true
			var j: Int = 0
			while (nestInProg) {// while ....
				j += 1
				var nested = snailFishNumLev.indexOf(5)
				var greater: Int = -1
				for (i in 0..snailFishNumber.size - 1) {
					if (snailFishNumber[i] &gt; 9) {
						greater = i
						break
					}
				}

				if (nested &gt; -1) {
					if (nested == 0) {
						snailFishNumber[nested + 2] = snailFishNumber[nested + 2] + snailFishNumber[nested + 1]
						snailFishNumber[nested + 1] = 0
						snailFishNumLev[nested + 1] -= 1
						snailFishNumber.removeAt(0)
						snailFishNumLev.removeAt(0)
					} else if (nested == snailFishNumber.size - 2) {
						snailFishNumber[nested - 1] = snailFishNumber[nested - 1] + snailFishNumber[nested]
						snailFishNumber[nested] = 0
						snailFishNumLev[nested] -= 1
						snailFishNumber.removeAt(nested + 1)
						snailFishNumLev.removeAt(nested + 1)
					} else {
						snailFishNumber[nested - 1] = snailFishNumber[nested - 1] + snailFishNumber[nested]
						snailFishNumber[nested + 2] = snailFishNumber[nested + 2] + snailFishNumber[nested + 1]
						snailFishNumber[nested + 1] = 0
						snailFishNumLev[nested + 1] -= 1
						snailFishNumber.removeAt(nested)
						snailFishNumLev.removeAt(nested)
					}

				} else if (greater &gt; -1) {
					var value = snailFishNumber[greater]
					snailFishNumber[greater] = value / 2
					snailFishNumber.add(greater + 1, value / 2 + value % 2)
					snailFishNumLev[greater] = snailFishNumLev[greater] + 1
					snailFishNumLev.add(greater, snailFishNumLev[greater])
				} else if (nested == -1 &amp;&amp; greater == -1) {
					nestInProg = false
				}

			}// end while
		}
		startAddition = true
	}

	println(snailFishNumLev)
	println(snailFishNumber)
	println()

	// calculate magnitude
	while(snailFishNumLev.contains(4)) {
		var lowLev = snailFishNumLev.indexOf(4)
		snailFishNumber[lowLev] = snailFishNumber[lowLev]*3 + snailFishNumber[lowLev+1]*2
		snailFishNumLev[lowLev]	= snailFishNumLev[lowLev]- 1
		snailFishNumber.removeAt(lowLev + 1)
		snailFishNumLev.removeAt(lowLev + 1)
	}
	while(snailFishNumLev.contains(3)) {
		var lowLev = snailFishNumLev.indexOf(3)
		snailFishNumber[lowLev] = snailFishNumber[lowLev]*3 + snailFishNumber[lowLev+1]*2
		snailFishNumLev[lowLev]	= snailFishNumLev[lowLev]- 1
		snailFishNumber.removeAt(lowLev + 1)
		snailFishNumLev.removeAt(lowLev + 1)
	}
	while(snailFishNumLev.contains(2)) {
		var lowLev = snailFishNumLev.indexOf(2)
		snailFishNumber[lowLev] = snailFishNumber[lowLev]*3 + snailFishNumber[lowLev+1]*2
		snailFishNumLev[lowLev]	= snailFishNumLev[lowLev]- 1
		snailFishNumber.removeAt(lowLev + 1)
		snailFishNumLev.removeAt(lowLev + 1)
	}
	while(snailFishNumber.size &gt; 1) {
		snailFishNumber[0] = snailFishNumber[0]*3 + snailFishNumber[1]*2

		snailFishNumber.removeAt(1)
	}

	println("magnitude: $snailFishNumber")
	println()


solution1 = snailFishNumber[0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">// print solution for part 1
	println("**************************")
	println("--- Day 18: Snailfish  ---")
	println("**************************")
	println("Solution for part1")
	println("   $solution1 ")
	println()
// print solution for part 2
	println("**************************")
	println("Solution for part2")
	println("   $solution2 ")
	println()</code></pre>
</div>
</div>
<a id="day20" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_20_kotlin"><a class="anchor" href="#_day_20_kotlin"></a><a class="link" href="#_day_20_kotlin">Day 20: kotlin</a></h3>
<div class="sect3">
<h4 id="_day_20_trench_map"><a class="anchor" href="#_day_20_trench_map"></a><a class="link" href="#_day_20_trench_map">Day 20: Trench Map</a></h4>
<div class="paragraph">
<p>This solution is written in Kotlin.</p>
</div>
<div class="paragraph">
<p>The original puzzle can be found at <a href="https://adventofcode.com/2021/day/20" class="bare">https://adventofcode.com/2021/day/20</a></p>
</div>
<div class="paragraph">
<p>For execution enter <em>kotlin day2120_1_2.kts</em> in the command line.</p>
</div>
<div class="sect4">
<h5 id="_first_star_17"><a class="anchor" href="#_first_star_17"></a><a class="link" href="#_first_star_17">First Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>First of all puzzle input is read into <em>enhAlg</em> string for the ruleset and <em>inputImage</em> map for the first image</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var width: Int = 0
	var height: Int = 0

	var enhAlg: String = ""

	var inputImage = mutableMapOf&lt;Pair&lt;Int, Int&gt;, Int&gt;()


	File("day2120_puzzle_input.txt").forEachLine {
		if (it.length == 512) {
			enhAlg = it
		} else if (it.length != 0) {
			width = it.length
			for (x in 0..it.length - 1) {
				var light: Int
				if (it[x].toString() == ".") {
					light = 0
				} else {
					light = 1
				}
				inputImage.put(Pair(x, height), light)
			}
			height = height + 1
		}
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After reading puzzle input, the enhancement algorithm is applied n times. After each time the lights which are on are conunted and at n == 2 solution for part 1 is available.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var outputImage = mutableMapOf&lt;Pair&lt;Int, Int&gt;, Int&gt;()

	for (n in 1..50) {
		// iterate over input
		var numLights = 0
		for (y in 0 - 5 - n..height - 1 + n + 5) {
			for (x in 0 - 5 - n..width - 1 + n + 5) {

				var xpos = x
				var ypos = y
				var index: String = ""

				// find index for each tile
				for (yy in ypos - 1..ypos + 1) {
					for (xx in xpos - 1..xpos + 1) {
						if (inputImage.containsKey(Pair(xx, yy))) {
							index = index + inputImage.getValue(Pair(xx, yy)).toString()
						} else {
							if (n % 2 == 0) {
								index = index + "1"
							} else {
								index = index + "0"
							}
						}
					}
				}

				// get value out of enhancedment algorithm and put Value in outputImage
				if (enhAlg[index.toInt(2)] == '#') {
					outputImage.put(Pair(x, y), 1)
					numLights = numLights + 1
					if (n == 2) {
						solution1 = numLights
					} else if (n == 50) {
						solution2 = numLights
					}
				} else {
					outputImage.put(Pair(x, y), 0)
				}
			}
		}

		inputImage.clear()
		inputImage.putAll(outputImage)
		outputImage.clear()
	}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_second_star_17"><a class="anchor" href="#_second_star_17"></a><a class="link" href="#_second_star_17">Second Star</a></h5>
<div class="paragraph">
<p>How does it work:<br></p>
</div>
<div class="paragraph">
<p>Just continue after n == 2 of part 1 until n reachd 50, then the counted lights are solution for part 2</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	var outputImage = mutableMapOf&lt;Pair&lt;Int, Int&gt;, Int&gt;()

	for (n in 1..50) {
		// iterate over input
		var numLights = 0
		for (y in 0 - 5 - n..height - 1 + n + 5) {
			for (x in 0 - 5 - n..width - 1 + n + 5) {

				var xpos = x
				var ypos = y
				var index: String = ""

				// find index for each tile
				for (yy in ypos - 1..ypos + 1) {
					for (xx in xpos - 1..xpos + 1) {
						if (inputImage.containsKey(Pair(xx, yy))) {
							index = index + inputImage.getValue(Pair(xx, yy)).toString()
						} else {
							if (n % 2 == 0) {
								index = index + "1"
							} else {
								index = index + "0"
							}
						}
					}
				}

				// get value out of enhancedment algorithm and put Value in outputImage
				if (enhAlg[index.toInt(2)] == '#') {
					outputImage.put(Pair(x, y), 1)
					numLights = numLights + 1
					if (n == 2) {
						solution1 = numLights
					} else if (n == 50) {
						solution2 = numLights
					}
				} else {
					outputImage.put(Pair(x, y), 0)
				}
			}
		}

		inputImage.clear()
		inputImage.putAll(outputImage)
		outputImage.clear()
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end, both solutions are printed out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-kotlin" data-lang="kotlin">	// print solution for part 1
	println("**************************")
	println("--- Day 20: Trench Map ---")
	println("**************************")
	println("Solution for part1")
	println("   $solution1 pixels are lit in the resulting image")
	println()
	// print solution for part 2
	println("**************************")
	println("Solution for part2")
	println("   $solution2 pixels are lit in the resulting image")
	println()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2021 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>