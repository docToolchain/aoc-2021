<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2021: razziel89</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2021/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2021/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2021.netlify.app/","doctoolchain.org/aoc-2021/");
          }
      </script>
<!-- /aoc-2021/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2021//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2021//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2021//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2021//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2021//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2021</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:aoc-2021.netlify.com">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_razziel89">razziel89</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_01_go">Day 01: go</a>
<ul class="sectlevel3">
<li><a href="#_day_01_sonar_sweep">Day 01: Sonar Sweep</a>
<ul class="sectlevel4">
<li><a href="#_oveview">Oveview</a></li>
<li><a href="#_how_to_run">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_go">Day 02: go</a>
<ul class="sectlevel3">
<li><a href="#_day_02_dive">Day 02: Dive</a>
<ul class="sectlevel4">
<li><a href="#_oveview_2">Oveview</a></li>
<li><a href="#_how_to_run_2">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_go">Day 03: go</a>
<ul class="sectlevel3">
<li><a href="#_day_03_binary_diagnostic">Day 03: Binary Diagnostic</a>
<ul class="sectlevel4">
<li><a href="#_oveview_3">Oveview</a></li>
<li><a href="#_how_to_run_3">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_go">Day 04: go</a>
<ul class="sectlevel3">
<li><a href="#_day_04_giant_squid">Day 04: Giant Squid</a>
<ul class="sectlevel4">
<li><a href="#_oveview_4">Oveview</a></li>
<li><a href="#_how_to_run_4">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_go">Day 05: go</a>
<ul class="sectlevel3">
<li><a href="#_day_05_thermal_vents">Day 05: Thermal Vents</a>
<ul class="sectlevel4">
<li><a href="#_oveview_5">Oveview</a></li>
<li><a href="#_how_to_run_5">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_go">Day 06: go</a>
<ul class="sectlevel3">
<li><a href="#_day_06_lanternfish">Day 06: Lanternfish</a>
<ul class="sectlevel4">
<li><a href="#_oveview_6">Oveview</a></li>
<li><a href="#_how_to_run_6">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_go">Day 07: go</a>
<ul class="sectlevel3">
<li><a href="#_day_07_the_treachery_of_whales">Day 07: The Treachery of Whales</a>
<ul class="sectlevel4">
<li><a href="#_oveview_7">Oveview</a></li>
<li><a href="#_how_to_run_7">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_go">Day 08: go</a>
<ul class="sectlevel3">
<li><a href="#_day_08_seven_segment_search">Day 08: Seven Segment Search</a>
<ul class="sectlevel4">
<li><a href="#_oveview_8">Oveview</a></li>
<li><a href="#_how_to_run_8">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_bash">Day 08: bash</a>
<ul class="sectlevel3">
<li><a href="#_day_08_seven_segment_search_2">Day 08: Seven Segment Search</a></li>
</ul>
</li>
<li><a href="#_day_09_go">Day 09: go</a>
<ul class="sectlevel3">
<li><a href="#_day_09_smoke_basin">Day 09: Smoke Basin</a>
<ul class="sectlevel4">
<li><a href="#_oveview_9">Oveview</a></li>
<li><a href="#_how_to_run_9">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_go">Day 10: go</a>
<ul class="sectlevel3">
<li><a href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a>
<ul class="sectlevel4">
<li><a href="#_oveview_10">Oveview</a></li>
<li><a href="#_how_to_run_10">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_go">Day 11: go</a>
<ul class="sectlevel3">
<li><a href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a>
<ul class="sectlevel4">
<li><a href="#_oveview_11">Oveview</a></li>
<li><a href="#_how_to_run_11">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_12_go">Day 12: go</a>
<ul class="sectlevel3">
<li><a href="#_day_12_passage_pathing">Day 12: Passage Pathing</a>
<ul class="sectlevel4">
<li><a href="#_oveview_12">Oveview</a></li>
<li><a href="#_how_to_run_12">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_13_go">Day 13: go</a>
<ul class="sectlevel3">
<li><a href="#_day_13_transparent_origami">Day 13: Transparent Origami</a>
<ul class="sectlevel4">
<li><a href="#_oveview_13">Oveview</a></li>
<li><a href="#_how_to_run_13">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_14_go">Day 14: go</a>
<ul class="sectlevel3">
<li><a href="#_day_14_extended_polymerization">Day 14: Extended Polymerization</a>
<ul class="sectlevel4">
<li><a href="#_oveview_14">Oveview</a></li>
<li><a href="#_how_to_run_14">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_15_go">Day 15: go</a>
<ul class="sectlevel3">
<li><a href="#_go">go</a></li>
</ul>
</li>
<li><a href="#_day_16_go">Day 16: go</a>
<ul class="sectlevel3">
<li><a href="#_go_2">go</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_razziel89"><a class="anchor" href="#_razziel89"></a><a class="link" href="#_razziel89">razziel89</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/10134766?v=4" alt="10134766?v=4"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>razziel89</strong><br>
<span class="icon"><i class="fa fa-github"></i></span>: <a href="https://github.com/razziel89">razziel89</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>Nothing here yet. Update your profile at <a href="https://github.com/docToolchain/aoc-2021/blob/master/profiles/razziel89.adoc">/profiles/razziel89.adoc</a></p>
</div>
<a id="day01" />
</div>
<div class="sect2">
<h3 id="_day_01_go"><a class="anchor" href="#_day_01_go"></a><a class="link" href="#_day_01_go">Day 01: go</a></h3>
<div class="sect3">
<h4 id="_day_01_sonar_sweep"><a class="anchor" href="#_day_01_sonar_sweep"></a><a class="link" href="#_day_01_sonar_sweep">Day 01: Sonar Sweep</a></h4>
<div class="paragraph">
<p>This is my implementation for the sonar sweep puzzle.
It is implemented in Golang.
I will try to start out developing in a modular way, hoping to re-use much of
one implementation for the next one.</p>
</div>
<div class="sect4">
<h5 id="_oveview"><a class="anchor" href="#_oveview"></a><a class="link" href="#_oveview">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
It will likely be split into several modules over the course of this year&#8217;s AOC.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">func main() {
	windowSize := defaultWindowSize
	if windowFromEnv, err := strconv.Atoi(os.Getenv(windowEnvVarName)); err == nil {
		log.Printf("Using window size %d from env var %s.", windowFromEnv, windowEnvVarName)
		windowSize = windowFromEnv
	}
	depths, err := ReadLinesAsInts()
	if err != nil {
		log.Fatalf("cannot read depth values from stdin due to %v", err.Error())
	}
	if len(depths) &lt; windowSize {
		log.Fatalf("cannot process fewer numbers than %d but got %d", windowSize, len(depths))
	}
	depthsWithoutNoise := SlidingWindow(depths, windowSize, Sum)
	increments := CountIncrements(depthsWithoutNoise)
	fmt.Printf("Counted %d increments.\n", increments)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Sum computes the sum of all values in an int slice. This is a possible reduction function for
// SlidingWindow.
func Sum(vals []int) int {
	result := 0
	for _, val := range vals {
		result += val
	}
	return result
}

// SlidingWindow converts an int slice into one that results from applying a reduction function to
// each sliding window of size `size`.
func SlidingWindow(sli []int, size int, reductionFn func([]int) int) []int {
	result := make([]int, 0, len(sli)-size+1)
	for startIdx := range sli[:len(sli)-size+1] {
		window := sli[startIdx : startIdx+size]
		windowSum := reductionFn(window)
		result = append(result, windowSum)
	}
	return result
}

// CountIncrements counts how often an int in an int slice is larger than its predecessor.
func CountIncrements(sli []int) int {
	var increments int
	if len(sli) == 0 {
		return 0
	}
	last := sli[0]
	for _, val := range sli[1:] {
		if val &gt; last {
			increments++
		}
		last = val
	}
	return increments
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.
I will add them as needed to simplify debugging for more complex puzzles.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run"><a class="anchor" href="#_how_to_run"></a><a class="link" href="#_how_to_run">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_go"><a class="anchor" href="#_day_02_go"></a><a class="link" href="#_day_02_go">Day 02: go</a></h3>
<div class="sect3">
<h4 id="_day_02_dive"><a class="anchor" href="#_day_02_dive"></a><a class="link" href="#_day_02_dive">Day 02: Dive</a></h4>
<div class="paragraph">
<p>This is my implementation for the second round of the dive puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_2"><a class="anchor" href="#_oveview_2"></a><a class="link" href="#_oveview_2">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>vec.go</code>, which contains specifications and manipulation
for the submarine&#8217;s movement and positioning.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">func main() {
	movements, err := ReadLinesAsStates()
	if err != nil {
		log.Fatalf("cannot read movement values from stdin due to %v", err.Error())
	}
	pos := State{Disp: 0, Depth: 0, Aim: 0}
	for _, mov := range movements {
		pos = pos.Displace(mov)
	}
	fmt.Printf("Area under total movement is %d\n", pos.Area())
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// TokensInInstruction specifies how many token are needed to describe one movement.
const TokensInInstruction = 2

// StateFromString converts an instructions string to a movement.
func StateFromString(str string) (State, error) {
	splitStr := strings.Fields(str)
	if len(splitStr) != TokensInInstruction {
		return State{}, fmt.Errorf("wrong number %d of tokens in '%s'", len(splitStr), str)
	}
	unit, ok := Units[splitStr[0]]
	if !ok {
		return State{}, fmt.Errorf("cannot understand %s as unit vector name", splitStr[0])
	}
	repeats, err := strconv.Atoi(splitStr[1])
	if err != nil {
		return State{}, fmt.Errorf("cannot convert repeats in %s to int: %s", str, err.Error())
	}
	return unit.Mul(repeats), nil
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// This file contains vector manipulation routines. All of the methods here always return a new
// vector, they never modify the original.

// DepthT describes the depth. To avoid intermingling depth and displacement, they are separate
// types.
type DepthT int

// DispT describes the depth. To avoid intermingling depth and displacement, they are separate
// types.
type DispT int

// AimT describes the aim.
type AimT int

// State describes the subs overall state, i.e. position and aim. It has depth, displacement, and
// aim.
type State struct {
	Depth DepthT
	Disp  DispT
	Aim   AimT
}

// Units contains unit vectors and name assignments.
var Units = map[string]State{
	"up": State{
		Depth: 0,
		Disp:  0,
		Aim:   -1,
	},
	"down": State{
		Depth: 0,
		Disp:  0,
		Aim:   +1,
	},
	"forward": State{
		// The depth change implicitly depends on the current aim.
		Depth: +1,
		Disp:  +1,
		Aim:   0,
	},
}

// Displace Displaces one vector by the distance specified by another. This takes the current aim
// into account. The new aim does not influence the depth change.
func (s State) Displace(delta State) State {
	result := State{
		Depth: s.Depth + delta.Depth*DepthT(s.Aim),
		Disp:  s.Disp + delta.Disp,
		Aim:   s.Aim + delta.Aim,
	}
	return result
}

// Mul multiplies each component of a vector with a number.
func (s State) Mul(factor int) State {
	result := State{
		Depth: DepthT(factor) * s.Depth,
		Disp:  DispT(factor) * s.Disp,
		Aim:   AimT(factor) * s.Aim,
	}
	return result
}

// Inv inverts a vector.
func (s State) Inv() State {
	return s.Mul(-1)
}

// Sub subtracts a vector's data from another one's.
func (s State) Sub(delta State) State {
	return s.Displace(delta.Inv())
}

// Area returns the area spanned by a vector. The aim does not matter for this compuation.
func (s State) Area() int {
	return int(s.Depth) * int(s.Disp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.
I will add them as needed to simplify debugging for more complex puzzles.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_2"><a class="anchor" href="#_how_to_run_2"></a><a class="link" href="#_how_to_run_2">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution.</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_go"><a class="anchor" href="#_day_03_go"></a><a class="link" href="#_day_03_go">Day 03: go</a></h3>
<div class="sect3">
<h4 id="_day_03_binary_diagnostic"><a class="anchor" href="#_day_03_binary_diagnostic"></a><a class="link" href="#_day_03_binary_diagnostic">Day 03: Binary Diagnostic</a></h4>
<div class="paragraph">
<p>This is my implementation for the second round of the binary diagnostic puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_3"><a class="anchor" href="#_oveview_3"></a><a class="link" href="#_oveview_3">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>set.go</code>, which contains specifications of a string set that
also knows how often individual entries have been added to it.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	base = 2
)

func filterForGenerator(sli []string, set CountingSet) []bool {
	filter := set.MostCommon("1")
	return FilterBy(sli, filter)
}

func filterForScrubber(sli []string, set CountingSet) []bool {
	filter := set.LeastCommon("0")
	return FilterBy(sli, filter)
}

// This function fatals if an error is detected.
func mustConvertBinarySliceToInt(sli []string) int {
	str := strings.Join(sli, "")
	return mustConvertBinaryToInt(str)
}

// This function fatals if an error is detected.
func mustConvertBinaryToInt(str string) int {
	val, err := strconv.ParseInt(str, base, 0)
	if err != nil {
		log.Fatal(err.Error())
	}
	return int(val)
}

//nolint: funlen
func main() {
	// Read input.
	binaryNumsAsStrings, err := ReadLines()
	if err != nil {
		log.Fatalf("cannot read binary numbers from stdin due to %v", err.Error())
	}
	if len(binaryNumsAsStrings) == 0 {
		log.Fatal("no input provided")
	}
	counts, err := CountTokens(binaryNumsAsStrings)
	if err != nil {
		log.Fatal(err.Error())
	}

	// First part.
	epsilonSli := make([]string, 0, len(counts))
	gammaSli := make([]string, 0, len(counts))
	// Map the least common and most common operators to the obtained counting sets.
	for _, sli := range counts {
		// Epsilon
		newEpsilonDigit := sli.LeastCommon("0")
		epsilonSli = append(epsilonSli, newEpsilonDigit)
		// Gamma
		newGammaDigit := sli.MostCommon("1")
		gammaSli = append(gammaSli, newGammaDigit)
	}
	epsilon := mustConvertBinarySliceToInt(epsilonSli)
	gamma := mustConvertBinarySliceToInt(gammaSli)
	fmt.Printf("Counts are %v\n", counts)
	fmt.Printf("Gamma is %v and %d\n", gammaSli, gamma)
	fmt.Printf("Epsilon is %v and %d\n", epsilonSli, epsilon)
	fmt.Printf("Product of both numbers is %d\n", epsilon*gamma)

	// Second part. Here comes the fun.
	generatorRatingStr, err := FilterCounts(binaryNumsAsStrings, filterForGenerator)
	if err != nil {
		log.Fatal(err.Error())
	}
	scrubberRatingStr, err := FilterCounts(binaryNumsAsStrings, filterForScrubber)
	if err != nil {
		log.Fatal(err.Error())
	}
	generatorRating := mustConvertBinaryToInt(generatorRatingStr)
	scrubberRating := mustConvertBinaryToInt(scrubberRatingStr)
	fmt.Printf("Generator rating is %d\n", generatorRating)
	fmt.Printf("Scrubber rating is %d\n", scrubberRating)
	fmt.Printf("Product of both ratings is %d\n", generatorRating*scrubberRating)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// CountTokens counts the tokens at each position of each string and returns one CountingSet per
// position. All strings must be of equal length.
func CountTokens(input []string) ([]CountingSet, error) {
	if len(input) == 0 {
		return []CountingSet{}, fmt.Errorf("empty string slice obtained")
	}
	length := len(input[0])
	for idx, str := range input {
		if len(str) != length {
			err := fmt.Errorf("string '%s' of unexpected length at index %d, expected %d got %d",
				str, idx+1, length, len(str),
			)
			return []CountingSet{}, err
		}
	}
	result := make([]CountingSet, length)
	for idx := range result {
		result[idx] = make(CountingSet)
	}
	for _, str := range input {
		for idx, char := range str {
			err := result[idx].Add(string(char))
			if err != nil {
				return []CountingSet{}, err
			}
		}
	}
	return result, nil
}

// Function sliceByIndex returns a slice of length-one strings that have been taken from the given
// index of each slice. An error is returned if a string in the slice is too short. This would be
// very easy in, say, NumPy, but it requires iteration in plain Go.
func sliceByIndex(sli []string, idx int) ([]string, error) {
	reqLength := idx + 1
	result := make([]string, 0, len(sli))
	for _, str := range sli {
		if len(str) &lt; reqLength {
			err := fmt.Errorf(
				"entry '%s' too short, need at least %d but got %d",
				str, reqLength, len(str),
			)
			return []string{}, err
		}
		result = append(result, string(str[idx]))
	}
	return result, nil
}

// FilterFunc is a type needed to filter counts out. Based on values in a counting set, it
// determines which entries of a string slice to keep. For each value to keep, the resulting boolean
// array contains true, false otherwise.
type FilterFunc = func([]string, CountingSet) []bool

// FilterBy contains true in the resulting boolean array for every entry in sli that is equal to
// filter.
func FilterBy(sli []string, filter string) []bool {
	// The initial value of a boolean array is all false. Thus, only set those to true we wish to
	// keep.
	result := make([]bool, len(sli))
	for idx, val := range sli {
		if val == filter {
			result[idx] = true
		}
	}
	return result
}

// FilterCounts filters out inputs that are assigned true by filterFunc until exactly one remains.
// If none remains at the end, an error is returned.
func FilterCounts(inputs []string, filterFunc FilterFunc) (string, error) {
	allGoneErr := fmt.Errorf("everything was filtered out")
	copied := make([]string, len(inputs))
	_ = copy(copied, inputs)
	for idx := 0; len(copied) &gt; 1; idx++ {
		counts, err := CountTokens(copied)
		if err != nil {
			return "", err
		}
		if len(counts) &lt; idx+1 {
			return "", allGoneErr
		}
		sliced, err := sliceByIndex(copied, idx)
		if err != nil {
			return "", err
		}
		filtered := filterFunc(sliced, counts[idx])
		newCopy := make([]string, 0, len(filtered))
		for idx, include := range filtered {
			if include {
				newCopy = append(newCopy, copied[idx])
			}
		}
		copied = newCopy
	}
	if len(copied) == 0 {
		return "", allGoneErr
	}
	return copied[0], nil
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>set.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// CountingSet is a set that also knows how often each element has been added. It does support
// non-empty strings only.
type CountingSet map[string]int

// Add adds an entry to the set. The empty string is not supported!
func (c *CountingSet) Add(entry string) error {
	if len(entry) == 0 {
		return fmt.Errorf("empty string not supported in counting set")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*c)[entry] = (*c)[entry] + 1
	return nil
}

// Count determines how often an entry has been added to the set.
func (c *CountingSet) Count(entry string) int {
	return (*c)[entry]
}

// RemoveAll removes all counts for a specific key.
func (c *CountingSet) RemoveAll(entry string) {
	delete(*c, entry)
}

// MostCommon determines the most common entry in the set. If the set is empty, this returns the
// empty string! A non-empty tie breaker will be returned in case there are multiple most common
// entries. If the tie breaker is empty but there are duplicates, an empty string will be returned.
func (c *CountingSet) MostCommon(tieBreaker string) string {
	return c.filter(
		tieBreaker,
		func(i1, i2 int) bool {
			return i1 &gt; i2
		},
	)
}

// LeastCommon determines the least common entry in the set. If the set is empty, this returns the
// empty string! A non-empty tie breaker will be returned in case there are multiple least common
// entries. If the tie breaker is empty but there are duplicates, an empty string will be returned.
func (c *CountingSet) LeastCommon(tieBreaker string) string {
	return c.filter(
		tieBreaker,
		func(i1, i2 int) bool {
			return i1 &lt; i2
		},
	)
}

type comparisonFunc = func(int, int) bool

func (c *CountingSet) filter(tieBreaker string, cmpFn comparisonFunc) string {
	var result string
	var resultCount int
	foundOne := false
	for entry, count := range *c {
		if !foundOne || cmpFn(count, resultCount) {
			foundOne = true
			result = entry
			resultCount = count
		}
	}
	// Check whether there are any duplicate findings and handle appropriately.
	for entry, count := range *c {
		if count == resultCount &amp;&amp; entry != result {
			return tieBreaker
		}
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_3"><a class="anchor" href="#_how_to_run_3"></a><a class="link" href="#_how_to_run_3">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_go"><a class="anchor" href="#_day_04_go"></a><a class="link" href="#_day_04_go">Day 04: go</a></h3>
<div class="sect3">
<h4 id="_day_04_giant_squid"><a class="anchor" href="#_day_04_giant_squid"></a><a class="link" href="#_day_04_giant_squid">Day 04: Giant Squid</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the giant squid puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_4"><a class="anchor" href="#_oveview_4"></a><a class="link" href="#_oveview_4">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>board.go</code>, which contains specifications of a bingo board.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">func findFirstWinner(picks []int, boards []Board) (Board, error) {
	for _, pick := range picks {
		for boardIdx := range boards {
			board := &amp;boards[boardIdx]
			if board.Mark(pick) &amp;&amp; board.Score() &gt;= 0 {
				return *board, nil
			}
		}
	}
	return Board{}, fmt.Errorf("no winner found")
}

//nolint: funlen
func main() {
	// -1 means no score assigned yet.
	firstWinningScore, lastWinningScore := -1, -1
	// Read input.
	picks, boards, err := ReadLinesAsPicksOrBoards()
	if err != nil {
		log.Fatalf("cannot read in: %s", err.Error())
	}
	// Both parts.
	for len(boards) &gt; 0 {
		winner, err := findFirstWinner(picks, boards)
		if err != nil {
			if len(boards) &gt; 0 {
				log.Fatal(err.Error())
			} else {
				fmt.Println("All done")
				return
			}
		}
		score := winner.Score()
		if firstWinningScore &lt; 0 {
			firstWinningScore = score
		} else {
			lastWinningScore = score
		}
		fmt.Printf("Next winner follows, winning score is %d\n", score)
		fmt.Println(winner.Pretty())
		// Remove all winners, find next winner, and repeat.
		newBoards := make([]Board, 0, len(boards))
		for _, board := range boards {
			if board.Score() &lt; 0 {
				newBoards = append(newBoards, board)
			}
		}
		boards = newBoards
	}
	fmt.Printf(
		"All done, first (last) winning score is %d (%d).\n",
		firstWinningScore, lastWinningScore,
	)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">func strSliceToIntSlice(sli []string) ([]int, error) {
	// I wish Go had a map function...
	result := make([]int, 0, len(sli))
	for _, val := range sli {
		conv, err := strconv.Atoi(val)
		if err != nil {
			return []int{}, err
		}
		result = append(result, conv)
	}
	return result, nil
}

const pickSep = ","

// ReadLinesAsPicksOrBoards reads all lines from stdin as picks or boards.
func ReadLinesAsPicksOrBoards() ([]int, []Board, error) {
	var picks []int
	var boards []Board
	var board Board
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return picks, boards, nil
		}
		if err != nil {
			return []int{}, []Board{}, err
		}
		line = strings.TrimSpace(line)
		if strings.Contains(line, pickSep) {
			// This is a line with picks.
			fields := strings.Split(line, pickSep)
			newPicks, err := strSliceToIntSlice(fields)
			if err != nil {
				return []int{}, []Board{}, err
			}
			picks = append(picks, newPicks...)
		} else {
			// This is a line with boards.
			row, err := strSliceToIntSlice(strings.Fields(line))
			if err != nil {
				return []int{}, []Board{}, err
			}
			err = board.AddRow(row)
			if err != nil {
				return []int{}, []Board{}, err
			}
		}
		if board.IsComplete() {
			boards = append(boards, board)
			board = Board{}
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>board.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Code in this file likely performs quite a few unnecessary copy operations on data. Performance
// doesn't matter much here, though.

// Field is a field of a bingo board.
type Field struct {
	val    int
	marked bool
}

// Board is a bingo board.
type Board struct {
	fields [][]Field
	last   int
}

// Convert an int slice into a field slice, initialising all fields as unmarked.
func fieldsFromInts(ints []int) []Field {
	fields := make([]Field, 0, len(ints))
	for _, val := range ints {
		newField := Field{
			val:    val,
			marked: false,
		}
		fields = append(fields, newField)
	}
	return fields
}

// Determine whether a set of fields is a winning set, i.e. whether all fields in the set (actually
// a slice) are marked.
func winningSet(fields []Field) bool {
	for _, f := range fields {
		if !f.marked {
			return false
		}
	}
	return true
}

// IsComplete determines whether a board has as many rows as cols. Such a board is complete since
// bingo boards are square.
func (b Board) IsComplete() bool {
	if len(b.fields) == 0 {
		return false
	}
	// A square board is considered complete.
	return len(b.fields) == len(b.fields[0])
}

// AddRow adds a row to a board.
func (b *Board) AddRow(input []int) error {
	if len(input) == 0 {
		// Ignore empty lines as a convenience feature.
		return nil
	}
	if len(b.fields) &gt; 0 &amp;&amp; len(input) != len(b.fields[0]) {
		return fmt.Errorf("cannot process row of length %d, require %d", len(input), len(b.fields))
	}
	fields := fieldsFromInts(input)
	b.fields = append(b.fields, fields)
	return nil
}

// Row gets the row with the specified index. If the index is out of range, an empty slice is
// returned.
func (b Board) Row(idx int) []Field {
	if idx &lt; 0 || idx+1 &gt; len(b.fields) {
		return []Field{}
	}
	// This is easy.
	result := make([]Field, len(b.fields))
	_ = copy(result, b.fields[idx])
	return result
}

// Col gets the column with the specified index. If the index is out of range, an empty slice is
// returned.
func (b Board) Col(idx int) []Field {
	if idx &lt; 0 || idx+1 &gt; len(b.fields) {
		return []Field{}
	}
	// This is less easy.
	result := make([]Field, 0, len(b.fields))
	for _, row := range b.fields {
		result = append(result, row[idx])
	}
	return result
}

// Mark marks a number and returns whether the board had the number. All occurrences are marked.
func (b *Board) Mark(num int) bool {
	found := false
	for rowIdx := range b.fields {
		for fieldIdx := range b.fields {
			field := &amp;b.fields[rowIdx][fieldIdx]
			if field.val == num {
				field.marked = true
				found = true
			}
		}
	}
	if found {
		b.last = num
	}
	return found
}

// Sum sums up all numbers. The value of `marked` determines whether marked or unmarked unes are
// summed up.
func (b Board) Sum(marked bool) int {
	sum := 0
	for _, row := range b.fields {
		for _, field := range row {
			if field.marked == marked {
				sum += field.val
			}
		}
	}
	return sum
}

// Score determines whether this is a winning board by returning the score. A non-winning board has
// -1 score. That way, we can distinguish winning with a zero from non-winning boards.
func (b Board) Score() int {
	for idx := 0; idx &lt; len(b.fields); idx++ {
		if winningSet(b.Row(idx)) || winningSet(b.Col(idx)) {
			score := b.last * b.Sum(false)
			return score
		}
	}
	return -1
}

// Pretty makes a pretty string representation for this board. A marked field is followed by the
// letter "X". An unmarked field is represented by its number alone followed by a space.
func (b Board) Pretty() string {
	// Hard-code formatting helper strings.
	pre := "&gt; "
	post := " &lt;"
	sep := " | "
	marker := "X"
	clear := " "
	formatter := "%-4s"
	// Actually build the representation.
	result := ""
	for _, row := range b.fields {
		result += pre
		for colIdx, field := range row {
			fieldRep := fmt.Sprintf("%d", field.val)
			if field.marked {
				fieldRep += marker
			} else {
				fieldRep += clear
			}
			fieldRep = fmt.Sprintf(formatter, fieldRep)
			if colIdx &gt; 0 {
				result += sep
			}
			result += fieldRep
		}
		result += post + "\n"
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_4"><a class="anchor" href="#_how_to_run_4"></a><a class="link" href="#_how_to_run_4">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution.</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_go"><a class="anchor" href="#_day_05_go"></a><a class="link" href="#_day_05_go">Day 05: go</a></h3>
<div class="sect3">
<h4 id="_day_05_thermal_vents"><a class="anchor" href="#_day_05_thermal_vents"></a><a class="link" href="#_day_05_thermal_vents">Day 05: Thermal Vents</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the thermal vents puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_5"><a class="anchor" href="#_oveview_5"></a><a class="link" href="#_oveview_5">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>grid.go</code>, which contains specifications of a grid and other
geometrical functionality.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	dangerThreshold = 2
)

func filterDanger(num int) bool {
	return num &gt;= dangerThreshold
}

//nolint: funlen
func main() {
	grid := make(Grid)
	lines, err := ReadLinesAsLines()
	if err != nil {
		log.Fatal(err.Error())
	}
	for _, line := range lines {
		points, err := line.Points()
		if err != nil {
			log.Fatal(err.Error())
		}
		for _, point := range points {
			grid.Mark(point)
		}
	}
	danger := grid.FilterCounts(filterDanger)
	fmt.Printf("There are %d dangerous spots.\n", len(danger))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// ReadLinesAsLines reads all lines from stdin as Line structs.
func ReadLinesAsLines() ([]Line, error) {
	var result []Line
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return []Line{}, err
		}
		line = strings.TrimSpace(line)
		parsed, err := LineFromStr(line)
		if err != nil {
			return []Line{}, err
		}
		result = append(result, parsed)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grid.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Vec is a 2D vector. Most of it has been taken from a previous solution.
type Vec struct {
	x, y int
}

// VecFromStr converts a sring into a vector.
func VecFromStr(str string) (Vec, error) {
	fields := trimStrings(strings.Split(str, vecSep))
	if len(fields) != tokensPerPoint {
		return Vec{}, fmt.Errorf("cannot parse %v as vector, wrong number of fields", str)
	}
	ints, err := strSliceToIntSlice(fields)
	if err != nil {
		return Vec{}, fmt.Errorf("cannot parse %s as vector, %s", str, err.Error())
	}
	result := Vec{
		x: ints[0],
		y: ints[1],
	}
	return result, nil
}

// Add adds one vector to another one.
func (v Vec) Add(delta Vec) Vec {
	result := Vec{
		x: v.x + delta.x,
		y: v.y + delta.y,
	}
	return result
}

// Mul multiplies each component of a vector with a number.
func (v Vec) Mul(factor int) Vec {
	result := Vec{
		x: v.x * factor,
		y: v.y * factor,
	}
	return result
}

// Inv inverts a vector.
func (v Vec) Inv() Vec {
	return v.Mul(-1)
}

// Sub subtracts a vector'v data from another one'v.
func (v Vec) Sub(delta Vec) Vec {
	return v.Add(delta.Inv())
}

func abs(num int) int {
	if num &lt; 0 {
		return -num
	}
	return num
}

func max(i1, i2 int) int {
	if i1 &gt; i2 {
		return i1
	}
	return i2
}

// Normalize returns a unit vector with the same direction as the original vector. For now, this
// does not support diagonals.
func (v Vec) Normalize() (Vec, error) {
	if partSelect == "1" {
		if v.x != 0 &amp;&amp; v.y != 0 {
			return Vec{}, fmt.Errorf("cannot normalize %v", v)
		}
	} else {
		// Default to part 2.
		if v.x != 0 &amp;&amp; v.y != 0 &amp;&amp; abs(v.x) != abs(v.y) {
			return Vec{}, fmt.Errorf("cannot normalize %v", v)
		}
	}
	length := max(abs(v.x), abs(v.y))
	norm := Vec{
		x: v.x / length,
		y: v.y / length,
	}
	return norm, nil
}

// Line is a line in 2D with a start and an end.
type Line struct {
	start, end Vec
}

// LineFromStr converts a sring into a line.
func LineFromStr(str string) (Line, error) {
	fields := trimStrings(strings.Split(str, lineSep))
	if len(fields) != tokensPerLine {
		return Line{}, fmt.Errorf("cannot parse %v as line, wrong number of fields", str)
	}
	start, err := VecFromStr(fields[0])
	if err != nil {
		return Line{}, fmt.Errorf("cannot parse %v as line, %v", str, err.Error())
	}
	end, err := VecFromStr(fields[1])
	if err != nil {
		return Line{}, fmt.Errorf("cannot parse %v as line, %v", str, err.Error())
	}
	result := Line{
		start: start,
		end:   end,
	}
	return result, nil
}

// Points determines all points on this line.
func (l Line) Points() ([]Vec, error) {
	result := []Vec{}
	direction, err := l.end.Sub(l.start).Normalize()
	if err != nil {
		// We ignore lines whose direction we cannot determine.
		return []Vec{}, nil
	}
	pos := l.start
	for pos != l.end {
		result = append(result, pos)
		pos = pos.Add(direction)
	}
	result = append(result, pos)
	return result, nil
}

// Grid is a lazily evaluated grid that supports marking points on it. Most of it has been taken
// from a previous solution.
type Grid map[Vec]int

// Mark marks a point on the grid once.
func (g *Grid) Mark(entry Vec) {
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*g)[entry] = (*g)[entry] + 1
}

// Count determines how often a point has been marked.
func (g *Grid) Count(entry Vec) int {
	return (*g)[entry]
}

// RemoveAll removes all markings for a specific point.
func (g *Grid) RemoveAll(entry Vec) {
	delete(*g, entry)
}

// FilterFn is a type that can be used for FilterCounts to filter counts that fulfil a predicate.
type FilterFn = func(int) bool

// FilterCounts allow to filter points based counts using a FilterFn.
func (g *Grid) FilterCounts(filterFn FilterFn) []Vec {
	result := []Vec{}
	for point, count := range *g {
		if filterFn(count) {
			result = append(result, point)
		}
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_5"><a class="anchor" href="#_how_to_run_5"></a><a class="link" href="#_how_to_run_5">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for part 2.
You can run the solution for part 1 using <code>cat input.dat | PART=1 go run .</code> or
in general by setting the environment variable <code>PART</code> to <code>1</code>.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_go"><a class="anchor" href="#_day_06_go"></a><a class="link" href="#_day_06_go">Day 06: go</a></h3>
<div class="sect3">
<h4 id="_day_06_lanternfish"><a class="anchor" href="#_day_06_lanternfish"></a><a class="link" href="#_day_06_lanternfish">Day 06: Lanternfish</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the lanternfish puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_6"><a class="anchor" href="#_oveview_6"></a><a class="link" href="#_oveview_6">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where some helper functions are.
There is also a <code>population.go</code>, which contains specifications of a population
of breeding lifeforms.
This solution also fully re-uses the counting set implementation of day 3 in
<code>set.go</code>.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	initialDaysToBreed = 9
	daysToBreed        = 7
)

var (
	partChoice = os.Getenv("PART")
)

//nolint: funlen
func main() {
	var days int
	if partChoice == "1" {
		days = 80
	} else {
		days = 256
	}
	sets, err := ReadLinesAsSets()
	if err != nil {
		log.Fatal(err.Error())
	}
	if len(sets) != 1 {
		log.Fatal("exactly 1 population supported")
	}
	population, err := NewPopulation(daysToBreed, initialDaysToBreed)
	if err != nil {
		log.Fatal(err.Error())
	}
	population.PopulateFromSet(sets[0])
	population.Age(days)
	fmt.Printf("There are %d fish after %d days.\n", population.Size(), days)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// ReadLinesAsSets reads all lines from stdin as counting sets.
func ReadLinesAsSets() ([]CountingSet, error) {
	var result []CountingSet
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return []CountingSet{}, err
		}
		fields := trimStrings(strings.Split(line, setSep))
		set := CountingSet{}
		for _, field := range fields {
			err := set.Add(field)
			if err != nil {
				return []CountingSet{}, err
			}
		}
		result = append(result, set)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>population.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Population tracks the time left until breeding of life forms and counts how many there are per
// such time.
type Population struct {
	pop            []int
	adultDuration  int
	infantDuration int
}

// NewPopulation initialises a new population with times for adults and infants until they breed.
func NewPopulation(adultDuration, infantDuration int) (Population, error) {
	if adultDuration &gt; infantDuration {
		return Population{}, fmt.Errorf("infants must breed slower than adults")
	}
	return Population{
		pop:            make([]int, infantDuration),
		adultDuration:  adultDuration,
		infantDuration: infantDuration,
	}, nil
}

// PopulateFromSet populates a population from a counting set. This ignores entries in the set
// larger than the maximum supported time to breed.
func (p *Population) PopulateFromSet(set CountingSet) {
	for idx := 0; idx &lt; p.infantDuration; idx++ {
		p.pop[idx] = set.Count(fmt.Sprint(idx))
	}
}

// Age ages a population by the given number of days, breeding appropriately.
func (p *Population) Age(days int) {
	for dayCount := 0; dayCount &lt; days; dayCount++ {
		// This new population is auto-initialised with all zeroes.
		newPop := make([]int, len(p.pop))
		// Handle all non-special cases. Simply decrease time to breed by one.
		for breedTime := 0; breedTime &lt; p.infantDuration-1; breedTime++ {
			newPop[breedTime] = p.pop[breedTime+1]
		}
		// Handle special case of those ready to breed.
		newPop[p.infantDuration-1] += p.pop[0]
		newPop[p.adultDuration-1] += p.pop[0]
		// Overwrite the data about the current population.
		_ = copy(p.pop, newPop)
	}
}

// Size determines the total size of the population.
func (p Population) Size() int {
	sum := 0
	for _, val := range p.pop {
		sum += val
	}
	return sum
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>set.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// This file contains the exact same counting set as used for day 3.

// CountingSet is a set that also knows how often each element has been added. It does support
// non-empty strings only.
type CountingSet map[string]int

// Add adds an entry to the set. The empty string is not supported!
func (c *CountingSet) Add(entry string) error {
	if len(entry) == 0 {
		return fmt.Errorf("empty string not supported in counting set")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*c)[entry] = (*c)[entry] + 1
	return nil
}

// Count determines how often an entry has been added to the set.
func (c *CountingSet) Count(entry string) int {
	return (*c)[entry]
}

// RemoveAll removes all counts for a specific key.
func (c *CountingSet) RemoveAll(entry string) {
	delete(*c, entry)
}

// MostCommon determines the most common entry in the set. If the set is empty, this returns the
// empty string! A non-empty tie breaker will be returned in case there are multiple most common
// entries. If the tie breaker is empty but there are duplicates, an empty string will be returned.
func (c *CountingSet) MostCommon(tieBreaker string) string {
	return c.filter(
		tieBreaker,
		func(i1, i2 int) bool {
			return i1 &gt; i2
		},
	)
}

// LeastCommon determines the least common entry in the set. If the set is empty, this returns the
// empty string! A non-empty tie breaker will be returned in case there are multiple least common
// entries. If the tie breaker is empty but there are duplicates, an empty string will be returned.
func (c *CountingSet) LeastCommon(tieBreaker string) string {
	return c.filter(
		tieBreaker,
		func(i1, i2 int) bool {
			return i1 &lt; i2
		},
	)
}

type comparisonFunc = func(int, int) bool

func (c *CountingSet) filter(tieBreaker string, cmpFn comparisonFunc) string {
	var result string
	var resultCount int
	foundOne := false
	for entry, count := range *c {
		if !foundOne || cmpFn(count, resultCount) {
			foundOne = true
			result = entry
			resultCount = count
		}
	}
	// Check whether there are any duplicate findings and handle appropriately.
	for entry, count := range *c {
		if count == resultCount &amp;&amp; entry != result {
			return tieBreaker
		}
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_6"><a class="anchor" href="#_how_to_run_6"></a><a class="link" href="#_how_to_run_6">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for part 2.
You can run the solution for part 1 using <code>cat input.dat | PART=1 go run .</code> or
in general by setting the environment variable <code>PART</code> to <code>1</code>.</p>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_go"><a class="anchor" href="#_day_07_go"></a><a class="link" href="#_day_07_go">Day 07: go</a></h3>
<div class="sect3">
<h4 id="_day_07_the_treachery_of_whales"><a class="anchor" href="#_day_07_the_treachery_of_whales"></a><a class="link" href="#_day_07_the_treachery_of_whales">Day 07: The Treachery of Whales</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the whales puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_7"><a class="anchor" href="#_oveview_7"></a><a class="link" href="#_oveview_7">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where some helper functions are.
This solution also re-uses the counting set implementation of day 3 in
<code>set.go</code> but using integers instead of string tokens this time.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// For each entry in the set, compute the cost based on some cost function. The target will be every
// possible number between the smallest and largest entry in the set. Multiples of set entries are
// accounted for. The lowest cost and associated target are returned.
func overallCost(set CountingSet, costFn func(int, int) int) (int, int) {
	bestCost := 0
	bestPos := 0
	found := false
	for checkPos := set.Min(); checkPos &lt;= set.Max(); checkPos++ {
		checkCost := 0
		for _, startPos := range set.Keys() {
			additionalCost := costFn(startPos, checkPos) * set.Count(startPos)
			checkCost += additionalCost
		}
		if !found || checkCost &lt; bestCost {
			bestPos = checkPos
			bestCost = checkCost
			found = true
		}
	}
	return bestCost, bestPos
}

//nolint: funlen
func main() {
	sets, err := ReadLinesAsSets()
	if err != nil {
		log.Fatal(err.Error())
	}
	if len(sets) != 1 {
		log.Fatal("exactly 1 input set supported")
	}
	set := sets[0]
	// Part 1.
	fuelConsumptionFnPart1 := func(start, end int) int {
		return abs(start - end)
	}
	bestCost, bestPos := overallCost(set, fuelConsumptionFnPart1)
	fmt.Printf("Best position is %d with cost %d\n", bestPos, bestCost)
	// Part 2. Same code, different cost formula.
	fuelConsumptionFnPart2 := func(start, end int) int {
		diff := abs(start - end)
		// This is the sum of the first diff natural numbers. This also nicely works for diff==0.
		return (diff * (diff + 1)) / 2 //nolint: gomnd
	}
	bestCost, bestPos = overallCost(set, fuelConsumptionFnPart2)
	fmt.Printf("Best position is %d with cost %d\n", bestPos, bestCost)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// ReadLinesAsSets reads all lines from stdin as counting sets.
func ReadLinesAsSets() ([]CountingSet, error) {
	var result []CountingSet
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return []CountingSet{}, err
		}
		fields := trimStrings(strings.Split(line, setSep))
		set := CountingSet{}
		for _, field := range fields {
			err := set.Add(field)
			if err != nil {
				return []CountingSet{}, err
			}
		}
		result = append(result, set)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>set.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// This file contains the counting set as used for day 3 but with ints instead of strings and with
// some unneeded functionality removed.

// CountingSet is a set that also knows how often each element has been added. It does support
// non-empty strings only.
type CountingSet map[int]int

// Add adds an entry to the set.
func (c *CountingSet) Add(entry string) error {
	conv, err := strconv.Atoi(entry)
	if err != nil {
		return err
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*c)[conv] = (*c)[conv] + 1
	return nil
}

// Min returns the smallest key.
func (c *CountingSet) Min() int {
	var result int
	found := false
	for key := range *c {
		if !found || key &lt; result {
			result = key
			found = true
		}
	}
	return result
}

// Max returns the largest key.
func (c *CountingSet) Max() int {
	var result int
	found := false
	for key := range *c {
		if !found || key &gt; result {
			result = key
			found = true
		}
	}
	return result
}

// Keys returns all keys of the set.
func (c *CountingSet) Keys() []int {
	result := make([]int, 0, len(*c))
	for key := range *c {
		result = append(result, key)
	}
	return result
}

// Count determines how often an entry has been added to the set.
func (c *CountingSet) Count(entry int) int {
	return (*c)[entry]
}

// RemoveAll removes all counts for a specific key.
func (c *CountingSet) RemoveAll(entry int) {
	delete(*c, entry)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_7"><a class="anchor" href="#_how_to_run_7"></a><a class="link" href="#_how_to_run_7">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for both parts.
The solution for part 1 will be output first, followed by that for part 2.</p>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_go"><a class="anchor" href="#_day_08_go"></a><a class="link" href="#_day_08_go">Day 08: go</a></h3>
<div class="sect3">
<h4 id="_day_08_seven_segment_search"><a class="anchor" href="#_day_08_seven_segment_search"></a><a class="link" href="#_day_08_seven_segment_search">Day 08: Seven Segment Search</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the seven segment puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_8"><a class="anchor" href="#_oveview_8"></a><a class="link" href="#_oveview_8">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where some helper functions are.
There is also a solution in bash in the appropriate directory.
Part 1 has been solved based on the solution of part 2.
This implementation brute-forces the solution by generating all possible
mappings and checking each one for validity.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go"></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Pow computes an integer power of an integer base.
func Pow(base, exponent int) int {
	result := 1
	for exp := 0; exp &lt; exponent; exp++ {
		result *= base
	}
	return result
}

// ReadLinesAsInputsAndOutputs reads all lines from stdin, splitting tokens, and determining how
// many outputs there are. If not all lines have the same number of outputs, an error is returned.
func ReadLinesAsInputsAndOutputs() ([][]string, int, error) {
	var result [][]string
	var numOutputs int
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, numOutputs, nil
		}
		if err != nil {
			return [][]string{}, 0, err
		}
		line = strings.TrimSpace(line)
		separated := trimStrings(strings.Split(line, inputOutputSep))
		if len(separated) != expectedSplits+1 {
			err := fmt.Errorf("cannot split into inputs and outputs")
			return [][]string{}, 0, err
		}
		if len(result) == 0 {
			numOutputs = len(strings.Fields(separated[1]))
		} else if len(strings.Fields(separated[1])) != numOutputs {
			err := fmt.Errorf("unexpected number of outputs in %s, wanted %d", line, numOutputs)
			return [][]string{}, 0, err
		}
		localResult := []string{}
		localResult = append(localResult, strings.Fields(separated[0])...)
		localResult = append(localResult, strings.Fields(separated[1])...)
		result = append(result, localResult)
	}
}

// AllPermutations returns all possible permutations of a string via a channel. It uses Heap's
// algorithm. See https://en.wikipedia.org/wiki/Heap%27s_algorithm for details.
func AllPermutations(str string) &lt;-chan string {
	channel := make(chan string)

	sli := strings.Split(str, "")

	var generate func([]string, int)
	generate = func(sli []string, permLen int) {
		if permLen == 1 {
			// This is a solution, emit it.
			emittedStr := strings.Join(sli, "")
			channel &lt;- emittedStr
		} else {
			for idx := 0; idx &lt; permLen; idx++ {
				generate(sli, permLen-1)
				if permLen%2 == 1 {
					sli[idx], sli[permLen-1] = sli[permLen-1], sli[idx]
				} else {
					sli[0], sli[permLen-1] = sli[permLen-1], sli[0]
				}
			}
		}
		// This is the outer-most call to generate. Make sure to close the channel in the end.
		if permLen == len(sli) {
			close(channel)
		}
	}
	go generate(sli, len(sli))

	return channel
}

// SortString sorts a string character-wise. This is particularly useful to determine whether two
// strings contain the same characters.
func SortString(str string) string {
	split := strings.Split(str, "")
	sort.Strings(split)
	combined := strings.Join(split, "")
	return combined
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_8"><a class="anchor" href="#_how_to_run_8"></a><a class="link" href="#_how_to_run_8">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for both parts.
The solution for part 1 will be output second, preceded by that for part 2.</p>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_bash"><a class="anchor" href="#_day_08_bash"></a><a class="link" href="#_day_08_bash">Day 08: bash</a></h3>
<div class="sect3">
<h4 id="_day_08_seven_segment_search_2"><a class="anchor" href="#_day_08_seven_segment_search_2"></a><a class="link" href="#_day_08_seven_segment_search_2">Day 08: Seven Segment Search</a></h4>
<div class="paragraph">
<p>This is my solution for part 1.
There is a solution for both parts in go in the respective location.</p>
</div>
<div class="paragraph">
<p><code>solution_part1.sh</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-bash" data-lang="bash">main() {
    echo "SAMPLE"
    sample | solve
    echo "ACTUAL"
    actual | solve
}

solve() {
    # The grep line filters out numbers that light 5 or 6 segments of the
    # display.
    awk -F"|" '{print $2}' | \
        tr "[a-z]" "A" | \
        tr '[:space:]' '\n' | \
        grep -vE "^(AAAAA|AAAAAA)$" | \
        sed '/^$/d' | \
        wc -l
}

sample() {
    cat &lt;&lt; EOF
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce
EOF
}

actual() {
    cat &lt;&lt; EOF
cg fadegbc ecfadb acdbeg abgfe dcegfb gcad bceag debca bgc | ceafbd gfedcb cabedf dbace
bgeacd ea dfcab fcdgbae ecbgf gbcadf defa cae dcaefb fabce | ea fdae daecgb cea
fb gafbec dcabe ecfdag fagdcb afcdb cbf gdfb agfdc acfgdbe | acdgfb gdcfa bceda bf
fd bcafe afed acbfde fcbde fcbgae fgabdc edbgfca cgebd dfb | dbf becgd bfd efcdb
deacg egfdbac agefd gbedc gebfca ac gadefb ace fadc fcdgae | gabfde cbdgfae ca eca
cfaedb gedfa fbegd dgca ga dfcae agf dfagceb gdfcae ecbgaf | gaecfb cdag gfa gaf
ceg gfdcab dfacge edgf fecagb ecdba ge gceda fcbaged cgdaf | gdaecf gceda fbacge dcagf
caged egbdf edabfg fbad fagde gefbcd fceabg afg fa cfdagbe | bfdge degca fbda af
dac egdacf fcedbg dabcg gdfcb dbaeg ac cfdaebg cafb afdbcg | decagf ebdag bfdgce fdbgec
dbaec edfac bdgae dbcegaf bc cba aecdbf cebf gbacfd facdge | efbc cab ecabfdg cab
gfce acf fecda egfda gbcfda fc gcefda dbcea afdbge dbceagf | bfedgac bfegda fcgdab fecg
edfgb ebf be gdcafe degaf agfbced deba bdafge dgcbf cbeagf | efb dbcgf dgabef be
ebgfd bfcg gf fcgbde dfbagec gefcda fadbce gef febdc edbga | gf dgbefc gfe bedfac
gabfec dcfage febg gcaeb gcf agbcf gf cbafd cabged cebfagd | egbf fg gcdbea dfbac
fgcedb fagbe aecgbd gbcaf bef fade fagdecb aebdg ef feadbg | abdge abfdge abcgf gabedc
dgebfc cebfa dbf acfbdg edbafgc dgfe decbf cdgeb eadbgc df | bgdcefa caebf fbd adfbgc
febgd fgaced bfedacg bfdgae fdcgbe fabed fcbea gdba ad dae | dae agbd gbfdea aegcfd
abdgf adcf bfdeg fa gfecdba fab debcag bcgda bcafdg fecgba | edbfg gcfdeab bgfda dfebg
ecdba bc dcfeba eacgdf cbegfad dbcf begda fcdae cebgaf cab | abc bc ecfdab cab
bc fabcged bcafg debfcg gdfac fgbea acfged bcg cdba dgfabc | baefg fbcag begcfad dabc
egfadb ce fgce bagdc gdafce edabcf gefad febdgca aec aedcg | aefbdg ec ceadg gecad
daegf gebf acdbf be faedbg dbe eabdf fdabgec aebdgc cdefag | be gfdeac bdfac gdbace
bafgc efac gae ecgdba ebgfa ea degbf afebcg fbacdg afedgbc | acfe age dbfecag bafgc
gfb bgacfd efcbd bdfeac bg efgcb gcbfed gcafe begd bfdgaec | cbgef gcfea fbcdae faedgbc
efdbc abd afcbegd dfcba fbedga ceafgd cgab ba agdcbf cdfga | dcafg cabdf ab bcga
fde fgadc fgceb eadcbfg gebd agfcbe ed fgbdce cbeadf egfdc | bdgcfae fde edgb gbde
abdcg gaebfc cfadebg cdfbg cegbf ebcgdf dbf fd cdfe fedagb | dgbca cgfeadb gdfaeb beagdf
fedbc gdeacfb cfbgae ebacdg gafc ca bgdfae geabf eafcb acb | bafge aefcgb cfbae defbc
fdega cefabd fce bfdegac afecbg fecad cfadb debc ec dfagcb | dcbaf gebfcda fce fegad
fab gaedb cagbdf fbce fecgad dcfeba dacfe fb fbgaecd faedb | dbecfa gefcdab bfa efbad
bcega gbacfe aecgdbf gae cabgd ebafc edgcfa ge facebd gefb | baecf efacdb ebagdcf fgeb
fgea acf af edbgca defbc fegbacd bagcfe ecbaf gdcabf gaceb | aebfc abgfec aegf dcfgab
ecfgb cfd dbcgefa fcdbe debaf cdgefa cd cfgdbe acfgbe bcdg | bcgd fdbea dcfgbe fcd
gdfaec fdcabe eb acbgd cbe bfae facbdeg cebda bgfced cfade | be dface eabf cbeda
efbagd ebf fdceba gfdae dfgabec dbgef bf fabg gbcde dgecaf | dgbef gfdeba afgdeb gdefb
gcadbef fgadc cbd cb bcgf bcfad dgfcba edafb gfdeca ebdgac | bc fdgcae ecadgf bdcega
defbg dgbaec gbe eg dabfg fgdaeb badfgc cadgbfe egaf debfc | gbfde fgebd gedbf egfa
caf gcdabe bfag fa edfbgac becafd cbega edcgf afceg faecbg | bafg abgfec ecfbda fbag
egfcba dafgcbe cefga cdbgae acfgde bgcfe ebfdc bg fagb bcg | fcebg dfegabc dgecba defacg
bgcdefa bcfged bf cadbgf edbcf fdb cebgd dfcea gbef gedbac | bf dfecb fb dgceb
bdegc decabgf agbfce bdcfg eagd gebadc dfeacb deb ed ebgca | dgcabe de dgabec bed
eabdf gedbaf afcbedg afcdg bgd gbae gadfb cefdbg bfdcea bg | acdgf dbafg geba gbd
egabdfc dg efdcab bdcef dgecf cfgea dfg cfedbg bagdfc gbde | fadbgc gcfea ebdg gd
fcge cf ecbfad acfedgb agdef fcgda aefbdg afc cagdb cdafeg | cfa gcadf dagfce acf
cbadge gdec efagb ce ecb bagecfd gbcad gabec dfacbe cgbfad | acfgdb gcdba cegbad fecdabg
cegbaf aedcg acgbed fadbe afbcdge gf fge gdeaf dcgf cegdaf | ebadf fagde cdgf baedf
ebdgf dcgbfe cfdabe afdg agbefd ad daebg cbadefg ceabg ade | bagce bfged cbfged gedab
adbf decbgf dbc agcdbf cdeabgf dcagb eacgbf abfgc cgaed bd | cbd dbcgfe abdcg cdaeg
bgcaf fgbae edbcgfa cdfba cbdagf cg cga fgdc edacgb bfcdae | dfabce bdaefc dbfca dgceab
gbe gedc fdgcab bdgaefc eg cageb ebgadf acbfe beagdc dgacb | gedc gbe bcgea gadcbf
dcega abgecf cgeab ab gfedbc adfbgc bcgef bafe dcafebg abc | gabdcf acb ab ab
dfgebc cdgef bc efagb bfceg fgedac cbf gcdb egbacfd cfdaeb | dbaefc agdefc ecgdbaf fecdga
febacg efgba ebfdg aefcb ag gba gacfbed fagc edbafc agbedc | gab ag dgfbe ecdgab
cabf fegacd bf ecabgdf gfb bdefag cbdge dfcbg agdfc gbfcda | dgcfba gfb eadfbg fcedag
dc fcd aecgfd cgfda baefgd cead fgacbed cfbdge eadgf fgabc | fedcga eagcfd gcfda gfdea
fgbaed aebdgcf edabg fdba faecdg fgaed gcbed ab cgebfa gab | edbcg becdg ab edbga
agdcb edfbgc edbca ae aeb aefdgcb eacf facedb agbefd ebdfc | adcbegf fcea acedgbf dcgebf
ecf dgfeb egac dacfeg abcdef ec gfebdac cdgbaf cdegf fcdga | dcabfg efc ec fgdecab
dcega def cfgde aegfcb deabfcg fd defgba egbdfc bfcd cbfeg | bagdecf df fed dcbf
gecbf bcdfaeg cdfga fgdcbe gcfbae eafb fagcb bga daebcg ab | acgfd bfaegc gdafc feagcb
edfbg df dcfbae edf bcegf egfbca acgfbde aegdb dcgf efdgbc | gbcfea beadg dfe cdfbae
gdbfca acebgd cabdf gebaf becdgaf ed fedc bdefa eda ebcfda | bcfdag fcdaeb fcdab ed
eafdgc gbdc efadb cd abfceg daebc dce afegcdb gbace becgda | dgcefa dabce gceba bgefac
bdaf cbgfd fag fgabc fa fcbegd gedfac gcaeb fgdacb eafbdcg | af gebdfc bgdfc fa
bdafec fdag gbfce dgc dfgbca dacbge cfabd fgdbc dg faedgcb | gcdabe cgaefdb gd gdfcaeb
ebdcfga afedcb aegdcf fbeg cbdag fg adfgbe ebafd bdfga afg | adcgef fadcgbe gf edbfag
dgeacbf gdaf bagecd dcefa caedfg dac gcebfa fgace dfbce da | cfegda ad da abcgde
bfadecg ba gab bafecg ecab dfgca cgfba bdcfge fecgb fdabge | ba ebac aebc fabcg
eadcg efd cdbf cfdea cbedaf egdafb cfbaeg fd aebfc adecgfb | aebcf fed abedcf aedfcb
gdb cbdaf cdge cdaebg efgdba egcab gd afebcg gdbca gaedcbf | dgbca begca cbgaef gceba
bdfgac fgadb adbgc fgca cfgdbe adbfe fg dgbace bfg dgabecf | dbafe gacf gdacb fadgb
gedbfa cdg aecgd edfgca fbdcage cd fgdabc fedc dafge cgbea | gafde bgdeaf dc defga
fdceg edfcb gd febgcd dgfb gcd aefcg cafebdg bafdce debgca | gd cfedb defcg cfadegb
adbfe bgcfda gefda gcaed dagbfce dbeagc gaf gf gfdeac cgfe | gfec ebgdac eabdf gcef
fc cdf bcfdeg dfgaeb fcgdea gafc bdeca fcbedag faged dacfe | adfebg ebcda fdega agfc
deagcf ebagfd bgafdec cd cabeg bcedaf dec cfdg gadce adfeg | ebgac cagde dc faedgb
dcgab ac fabegc dcaf acg fadbcg fbgacde cfdgb cbgfde debag | dagbc daegb edbga cag
fgcead edbcg cfaed dcgef dfbgcea gf badcfg fdcbae gfd fgae | dfbagc dfcge gf dfeac
begcf cbf aebf fdgacb gdebac ceabg egabfc gdcfe ebgfacd fb | debcga bgaedc fdabcg abgce
efgbcd febdga bc fbegd befcd dgafebc ebc fgbc dgabce caefd | fbcg ecafd cdbfe cgbf
eafg badgec ecgab gdcfb fca fa cgabef fcbag fbeacd cegfbda | fa cabdge acgbfe cdbega
gdfae fdagbc fecgab eg fadec abgdef abgdcfe dbge eag fgadb | dbafcg befdag ecfdagb aebdfg
aegbcf bfgecad acgfbd dabceg aefbd gcfd bgd gcbfa dg dagfb | cdgf gd dfbga bdafe
bcgdf be gcdeb egadc bagecd ebd cabe gdcfeab badfge egcafd | agbdfe be ecab ecbgd
edbafc fbdgce befgc cge ebdgac eg bdcfe egfd caedgbf bcafg | gabfc eg ceg cdbef
cbadf af afc baef cfbdg dcegfba ebdac dabgec acbdfe afecdg | cdbaef decba bdcaf dbcae
ea eac cbgaed cdbaf adge dgfeacb bdaec ecbgfa dgbce gdbfec | cdfba bcdge ae cabgde
bgecfa abegcfd fgcad fgdcae aedc dfc fbdga cd defgcb cegaf | gbafec egdafc aced acbefg
becfdg abgcdf abgec dafceg gcdbf bfgadec af fac abdf fcgba | fac abgcf afbcdge fgdbc
cbe ec caefgdb cbgeaf ecbdag bcadfg cdae cbgad defbg egdcb | dace ecda aced ebgdf
aecfbg cegdfab fdace ecd cd gadc cgdaef efgca gdfebc badfe | cfdea cd eacfg aecgfbd
bafgdec gcd gacdf gbcaf cd cgfeab dgbeac bcfd abcgfd fdage | bfcd dc cbfd dc
gadfec gfadbce gceba abcdf gd bdeg cebgda cdg afbecg bgdac | dgbe afgdce egabcd gedb
fc defc cdeab bdcgae acebf caf cgefbad efdbca gdfacb bfgea | adfgcb cbead efbcad dcagbe
fecab adfgbe ecad ca adbfec cab cdfegba gcadbf gbfec eadfb | bgdacf dgeabf ca cgbfe
gbaefd cafged feac cegdb eafdbgc ea agfcd dgace bagdfc ead | ea gedcb ea acgde
cbaedf dfbcga cbagd cbfadeg fdbeag bgfad cdgbe ca acb gacf | fabgde fgac acb fcag
efgc fg agbdcf bdfce bacdgef dgfbe gdfceb fbg edfbac eadbg | dgfeb cadgbf egcf dcfbge
bdgea gbcf facegb acdfbeg ebgaf dabecf bf gfeac aegcfd fba | fb gabfe cbfg bgafe
fedcgab fceab cgab egbdfa cgaebf cefdag fca fcebd ac begfa | afc adgfec bfgea bgeacf
bfda gbcadef bgecd dafegb daefg aecdfg bgdfe acbfeg bf ebf | dfabge bf dbaf bcfaeg
bacdfge aegdf ebgdf fcaeg edcgfa fbecga ceda adf fabdgc ad | dbgef fagce edafcg bdgfcae
abdef gaedcf afdgeb becadgf edabc bcdeg bafcde acfb ca cda | dfgbea cda dca adc
efgd fcgbea gbadcef dcabe fe aebdfg fdabgc abfed feb agdfb | egfd fedg fdgeabc eafdb
dcabegf gedac ecgfd cea gfcebd agdbe ac gcfa fbeacd gdecaf | fegdac gedab dgaec bfdeca
bacdgf dgce ec cafdeb fcega eca cdafg ebagf degfca bdfcega | cae fgdabc decgafb cfagdb
gefac egabcfd gfc baecgd eabcgf dafec gf cbage acgfbd egbf | abcgfe bceadgf feacg egbf
gbcaf dcaefb gdec adfeg acefdbg fbdage cdfag acefdg cd dca | gecd cgbfa cafgd dc
fbadge bdcg acb caebfd bgead gbcdea caebg dbgcaef gfeca cb | acdegb gabde gbcae abc
bcd agdce edbagf gfdecb cbfa bc debafc aedfb beacdgf cbead | ebcfgad dfgceb gdaefb bfca
bag ab ebca dabecg agcde dbfagce efgcad gbcdaf egdab egfbd | gabed gaecbd ab eagfcd
gbcadf cdabg bd dbg afgbedc fdgca gacbe adcfge cfbd gedabf | gdb dfgca gfabcd dacgb
cfeabd cabgf gadfeb gbadc dcbgae dgec bdage gbfcade cd dcb | dceg bedcfa edgacb dc
bcdfg gdfeab abecdgf edg gefca ecadgf fedcg deca ed gcbefa | bdacfge fecgbda gbcafe fedcg
acbgfd bdgcf dcfga fbd dfbcgea fb dbgec eafbcd fbga efagcd | gfdca bdcfg dbf afgced
dafecb acedg bc dgafce gbeac fgceabd bce gbefa gdbc dbceag | agfcdeb fagdce afgbe dfecga
fgadce db fbadg deagcfb abd aegbf gcdbfa fgdac gbaedc bdfc | daegcf faegb bd dba
bdga fbagc ceadbf ecgdfba bfgce fga cbfagd ga cfdab gecdaf | fcdaeb ag cegabfd ga
fce fcdg adfgeb cegadf bafdce fecga fc becga dafebcg agfde | efbagcd afged fedgba efcga
cegdba fb bcdeg fecb gdeaf acgfdb fdb fgdbe cbdafeg gecbdf | afedg bf dfegb fbgecad
eg feadcb dgec egf afedc eabgfc gaedf bdgaf acdgbfe egafdc | eagfbc adecf egdc afdge
bg dagfe edfcabg dbgcae fgaedb fbag fdcage dgb bfegd cbdef | dbgef dgfbe bg efbgd
dabgfc acefbd cegad cbeda bac adbef cb bcfe fbgdea cafbegd | fadceb ebfdga ebcad bac
gfbca decbfa ecadbg cga gc cfdg bfcadg bfeadgc cfabd efgba | ebdfca cfagb degacb abdfc
gcbead fadbge befc bgfceda dbcea cbefda bfa gfacd bf facbd | abf cedba fba dgefcab
baedc feag begafc fcagdb eg bagcefd baceg gce bcgdfe cfabg | cgabf egaf ge fage
ecab ce bfcdg fabgce efdcag cgfeb gbaedf dfegbca cef baegf | cefdga gdecfab cfbgd bcaegf
beacfg fg efg ebfcd dbfgcae fbga bgcea cefgad cgbfe ceagbd | bdcafeg baecfdg fecbd gef
cebdfg ba abf bdgfaec aebcfg gfcdb dbga afdcb gcbadf fecad | gbad bgdfcae gfdcb baf
gceaf ebf eadb abdcf adfebc fdbceg cgafdb efcab cefdgab be | ebf dbfcag efb feabc
fgbcda bceag dfabge fbdceg fced bgfdc fabgdce fe gfe cgbef | abgedf cfde efgbc gfabcd
deagcf bdfacg fcbad dca gfdbc ecgbadf febcdg dbafe bcga ac | afdgcb cbga dgafce adegcfb
dbceg bcg gfbeca cgfbaed egfcbd ebgfd gcfd cg bdaegf decab | cg dgfc cbeda dfgeb
cfbed bdae dfcgb ed efbca cde fcbdae gbcfae fbdgaec aefdgc | dfgace becafg cagebf fcdebag
ed dfce dae bedca gfaedb befdac bacgd eabgcf bfcae agdfbec | bcaed edacb cdaeb ed
dagcb cbge daefbc bgadfce bc cfgad abdefg gbdea cab cabegd | badgc ebfcgda bdcfgae abcgd
ac fgdca gfbdca bcgdafe cefdg cgbeda cda gaefdb fbac dgfba | fdegba egadbf ca bfca
fedgc dbcaf ceb adefgc ebdg acgbef cbefdg be befcd dcfaegb | dfecb gbcdef eb fgceab
aefcd fcgaeb eacdgfb fbcg aebdgc gdbeaf agfbe agc cgaef cg | cga gac dabcfeg fbdgcea
af bdeag gfbdace fga bcaedg cdegf feab eafdg gfedab dagcfb | fgacdb faedg ecbdafg fcedg
dgafc adfcebg fagec dacfeg fgd fd gbdac defc fdaegb gafbce | cdagb df fcaebg dfce
bacfdg dgc cg bcaed adcgb cafdeg bgcf dgfab bgfead cbfaged | bdfega dgfeab fdgba agbdc
agfebd cb bafecg efbga edgac gfedcb cedfagb afbc gcb acgeb | bc cgb bc cbg
fgdae edfbca bgdf gceaf eabfdg aebfd gad defbgca gdceab dg | eacgf agecbd gd gcabed
befadcg gdfa afdeb aebfg fg bcfead gadfbe gfe cgeab gfbdce | adebcf dcgfbea deabf abgec
cb cbg gbaedc efbga bcafgd caefdbg efcdga eacgd bcde gbcea | edagc cebd aefbg bdce
cdaebfg edcbg cgedba acbeg fbdgc edg fagebc cdea ed abedfg | ed gcbdefa cgabdef baecgf
eafbg acebgdf dagcb eadc ecg ce cfbgda cegba dgbace bfedgc | edac ce bagcd gfeba
egafcd gdfaceb acegf cgda deg dgfbea gd cdfge feabcg cedfb | fadcegb egd caedgbf febdc
feag eg aebfc efcadb bge cdbgf fgbcead bdegac ebcfg aefbcg | ge adcegb fceagb ecfba
beac bdgea ebagdc bdgafc bcagd age bcgdeaf ae dfaecg defbg | egdacb eag dbcage ecgadbf
ca agdbec abc dbgfca gbfecd cbfgd acgf fbdae fdacb ceafbgd | dgfbca abcdf ac cfgbda
bgadf cdgbefa bagef bfe agfdce cebg ecbadf gbecaf eb egcaf | ebdcgaf cebg faegb fgbae
bfgcea fdgeca cae gbeca abcf cfebagd ca fgdbae cebgd faebg | gfeba ca fedgca gcabe
cage dfgaebc ae gfbed ebgaf decabf afbcg bfacdg aef cbaegf | debagcf bfgca agce bgeaf
bcegdf cgdafb abfd abgcfe fdg gfdac gefbcda dgeac afcgb fd | gdbcfe cafdbge gaecbf dgf
cgdbe decba bfdgcea debfa cfdbae gafedb ac fbca agfdec cea | dgecb dacbe edagfb gfdbea
gacdef bfeda afecd gfbae bdcega bafgcde dab dfceba bcfd db | db eacdgb aedbfcg fcgbdea
abdgcf dafec faedb cf bcfgeda gefbad cabfde cfbe afc aegdc | bdfega afgdecb fgdcba gedafb
aedcb fce bedfc cfbged gefb bgfeacd edgacf ef gcfdb dgfabc | gedfca fabcdg adfcge cfe
dbfagec dabec eda fdcbea ed agdbc gfbcea cbefa efdb gfdeca | ecfgdba ade fcagebd dea
dafbe adfbcg bfeac cbe bagfecd cfge egcdab cgabf ce gfceab | bcagef afgcb fcgabd gcdabf
agc ag gbaecf cagbf fgdcaeb bdgfc cefab ecfagd bega aedfcb | ebcafg fbace cag eacfdbg
ea gfbda eacd bfced eagfbc aeb cbfged befda bgafced dacfeb | gfbad aeb fdabg cedfbg
gcbadf gbead afcbde gad beadf daefgb aecgb dg efagdcb gedf | dgef fegabd afebd dg
dbc fdcge dabeg aceb cgdeb afedbg cdgeba bdagcfe bc gcdbaf | gcadbe dcb abcedg edbgc
bfcd ebfgd cgf egcab bfdcge adfgec gbefad fcbegad gfebc cf | fcdaeg dbegacf dbcf cf
bcfedga df dfa gcaedb fagcbd adecbf ecgaf dgfb gcdaf bdcag | gecaf df gfbdeca df
acf cdfe dcbegaf feabd ecbgfa dbacg aebgfd bfdeac dcfba fc | gfedba fc efdc dfbaecg
ecf bgaecd ecdgfb adgfe egcfa fcbedga bagec gacebf cafb fc | cfgaebd aecbg ecgab dgbeca
beagc aegbdc fcdeb fcgbe gf geaf acgbfd fcg fecgdba fbgeca | bgfadc baedcg gfc gebacf
gedf caebfd fcgea bdcgae age acefd fdcagbe gacfb gcefda eg | bedcaf dgeabc acgfe aeg
gceabfd cdgba cgfdae cfdagb begd ceabg ceafb ge gae gabdce | fcgaed dgfcae acegb ebgd
deg cegdbf dbceg bdgafe baegdfc bcadg de agbecf gfbec ecfd | fdce ed de gedabf
afgced gb dbg gbec badcfg abged baedf eadcg cafgedb gdbeca | fgeadc bg gbd beadg
ad bdegca cgabd bedfgac gda cead bfcaeg gaecb cdbfg edgabf | dfbagec eacgfbd cgedba ad
bacd afgecd ba eadbcf fdgeb bgacef feagcdb bfdae deacf eba | abe fdebg abe dgafec
cdafe dab febdga fcbd fceadb bd fecdag agceb abdcfeg bacde | dab cbdafge dfaec dagefb
ecbgad cbe bdef dfegcb dgbcf agcfe fgebc eb fdgbca ebgadcf | bfdgec be be fcgea
cdg dabfc edbfac gd fegac dfacg gfdb deabcfg dbacge bcadgf | bdcfa efgca cgd aedgcb
adcfe afd deagcf faebc ebfcagd efdg cbeagd gabfcd fd cedga | daf dfcae fd egdabc
dgfc cabfe bcg abegdf gdafb cg afbecgd fcagbd aedgcb bfgac | agefbdc gdfacb cg cafdbg
fbadge bfgca agf dacbfge bdcafe bfeac aegc ga fabgce dfgcb | fdebga fgbcd baefgc geac
abe ebcfga dgabc gfcbe fcadbeg gafe ea gcabe fdgbce aecfbd | gadbc ebcag ecgbf gabefc
gd ebacfd afedcgb cdeabg cabgd gad aecbd ecdg gdbfae bacgf | egdacb agfdeb cbafg gda
ec dgfae gfdcba ced dagebc dcafbe cadfb efacd edgfabc cefb | abdfgce befc edc debgca
ec cfed gbafe gfecdba cfdgae cae gfdac gacbde fdcagb ecfag | dcafeg ce fdbaecg gaefb
acge fgebd fcbeg agfcbe ce bcfga cbe eabgfcd gcdafb edfbca | gbafcd abcgf agbcdf ce
eafgcb bface dcgebfa dbface dc ecadbg acfd fdebg dcefb bdc | dacf bcfega cafbe dc
cdbgae befcg bgade fgbeacd gbdfae fbdacg fd dfg aedf bfgde | daefgbc edfa abegd bfadcg
dcage bcae agdfcb efbagd bdafceg gfecd dae dbecga dgcba ae | cdgea aed afbcgd aed
fbedcag agfe cbeafd efgbc gacbd agefbc af cagbf cedbfg afc | gfaebc dagcb febcg ecgfdab
abecgdf cagbd efbdc ebfg fg gdfcb aecdgf dbgcfe cbafde gdf | decfb gfd fbcgd fdg
ecbafd ba bafdeg fgdba dba fgebd cbefgd bgae dcgfa daegcbf | adb bfadg cbfead ab
egbdc acbfged gae cdaeg ga agbefd acgf decaf cdaegf eafdcb | agcf ga daegcfb cedbg
bafce adcfeg caegfb cefga fb fab bdcagfe dabgef bgcf ebdac | gface bcaef fab fcabe
gcedab facgbd efadg edacg bdafecg fedgb fda af aefc gafcde | dgecfa ebdgac fa bdfeg
gdba gedfb egfbad fegadc ecgfba dfbec gd cbedfga abefg fdg | fcadge gdbef fegbac agbef
fbdec fdbceag feacb fbcgd dcbfge dec efgadc dcbafg ed dbge | cabgdf ceafb afgdec de
cbgaed fbagc cbfd bdaegf bdcag egdbfac afgce bcfadg baf bf | fb baf edgafb cbgda
EOF
}

main</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simply run the script to solve.</p>
</div>
<a id="day09" />
</div>
</div>
<div class="sect2">
<h3 id="_day_09_go"><a class="anchor" href="#_day_09_go"></a><a class="link" href="#_day_09_go">Day 09: go</a></h3>
<div class="sect3">
<h4 id="_day_09_smoke_basin"><a class="anchor" href="#_day_09_smoke_basin"></a><a class="link" href="#_day_09_smoke_basin">Day 09: Smoke Basin</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the smoke basin puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_9"><a class="anchor" href="#_oveview_9"></a><a class="link" href="#_oveview_9">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>grid.go</code>, which contains specifications of a grid and other
geometrical functionality.
This solution reuses quite a bit of the day 5 solution.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	noMoreBasinHeight = 9
	numLargestBasins  = 3
)

//nolint: funlen
func main() {
	grid, err := ReadLinesAsGrid()
	if err != nil {
		log.Fatal(err.Error())
	}
	minima := []Vec{}
	risk := 0
	for point := range grid.Points() {
		if grid.IsLocalMin(point) {
			risk += 1 + grid.Count(point)
			minima = append(minima, point)
		}
	}
	// minima = []Vec{Vec{x: 0, y: 1}}
	fmt.Printf("There is %d risk.\n", risk)
	sizes := []int{}
	for _, min := range minima {
		basin, err := grid.Basin(min, noMoreBasinHeight-1)
		if err != nil {
			log.Fatal(err.Error())
		}
		sizes = append(sizes, len(basin))
	}
	// Multiply the sizes of the three largest basins.
	sort.Ints(sizes)
	sizeMult := 1
	for _, size := range sizes[len(sizes)-numLargestBasins:] {
		sizeMult *= size
	}
	fmt.Printf("Multiplied basin size is %d.\n", sizeMult)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// ReadLinesAsGrid reads all lines from stdin as a grid. That is, each point on the grid has a
// height and a location.
func ReadLinesAsGrid() (Grid, error) {
	lineIdx := 0
	result := make(Grid)
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return Grid{}, err
		}
		line = strings.TrimSpace(line)
		ints, err := strSliceToIntSlice(strings.Split(line, ""))
		if err != nil {
			return Grid{}, err
		}
		for rowIdx, val := range ints {
			// This is lazy but I wanted to re-use old code.
			point, err := VecFromStr(fmt.Sprintf("%d%s%d", lineIdx, vecSep, rowIdx))
			if err != nil {
				return Grid{}, err
			}
			err = result.Mark(point, val)
			if err != nil {
				return Grid{}, err
			}
		}
		if err != nil {
			return Grid{}, err
		}
		lineIdx++
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grid.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Vec is a 2D vector. Most of it has been taken from a previous solution.
type Vec struct {
	x, y int
}

var (
	unitX     = Vec{x: 1}
	unitY     = Vec{y: 1}
	unitDisps = []Vec{unitX, unitY, unitX.Inv(), unitY.Inv()}
)

// VecFromStr converts a sring into a vector.
func VecFromStr(str string) (Vec, error) {
	fields := trimStrings(strings.Split(str, vecSep))
	if len(fields) != tokensPerPoint {
		return Vec{}, fmt.Errorf("cannot parse %v as vector, wrong number of fields", str)
	}
	ints, err := strSliceToIntSlice(fields)
	if err != nil {
		return Vec{}, fmt.Errorf("cannot parse %s as vector, %s", str, err.Error())
	}
	result := Vec{
		x: ints[0],
		y: ints[1],
	}
	return result, nil
}

// Add adds one vector to another one.
func (v Vec) Add(delta Vec) Vec {
	result := Vec{
		x: v.x + delta.x,
		y: v.y + delta.y,
	}
	return result
}

// Mul multiplies each component of a vector with a number.
func (v Vec) Mul(factor int) Vec {
	result := Vec{
		x: v.x * factor,
		y: v.y * factor,
	}
	return result
}

// Inv inverts a vector.
func (v Vec) Inv() Vec {
	return v.Mul(-1)
}

// Sub subtracts a vector'v data from another one'v.
func (v Vec) Sub(delta Vec) Vec {
	return v.Add(delta.Inv())
}

// Grid is a lazily evaluated grid that supports marking points on it. Most of it has been taken
// from a previous solution.
type Grid map[Vec]int

// Mark marks a point on the grid n times. Don't accept numbers &lt;0.
func (g *Grid) Mark(entry Vec, n int) error {
	if n &lt; 0 {
		return fmt.Errorf("can only mark non-negative times")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*g)[entry] = (*g)[entry] + n
	return nil
}

// Count determines how often a point has been marked.
func (g *Grid) Count(entry Vec) int {
	return (*g)[entry]
}

// Has determines whether a point is on the grid.
func (g *Grid) Has(entry Vec) bool {
	_, ok := (*g)[entry]
	return ok
}

// RemoveAll removes all markings for a specific point.
func (g *Grid) RemoveAll(entry Vec) {
	delete(*g, entry)
}

// IsLocalMin determines whether a point is a local minimum.
func (g *Grid) IsLocalMin(entry Vec) bool {
	for neigh := range pointEnv(entry) {
		if !g.Has(neigh) {
			continue
		}
		if g.Count(entry) &gt;= g.Count(neigh) {
			return false
		}
	}
	return true
}

// Points returns an iterator over all points on the grid.
func (g *Grid) Points() &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for point := range *g {
			channel &lt;- point
		}
		close(channel)
	}()
	return channel
}

// Check whether a slice has a specific entry.
func sliceHasEntry(sli []Vec, entry Vec) bool {
	for _, val := range sli {
		if entry == val {
			return true
		}
	}
	return false
}

// Obtain an iterator over a point's environment.
func pointEnv(point Vec) &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for _, disp := range unitDisps {
			displaced := point.Add(disp)
			channel &lt;- displaced
		}
		close(channel)
	}()
	return channel
}

// Basin returns a "grid" that contains the basin associated with the given entry. The value of max
// will be the maximum value permitted for a point in a basin.
func (g *Grid) Basin(entry Vec, max int) (Grid, error) {
	if !g.IsLocalMin(entry) {
		err := fmt.Errorf("can only start basin generation from local minimum")
		return Grid{}, err
	}
	result := Grid{}
	for checkEnv := []Vec{entry}; len(checkEnv) != 0; {
		newEnv := []Vec{}
		// Add each entry of checkEnv to the basin if it is lower than or equal to all of its
		// surrounding points that are not yet in the basin.
		for _, checkVec := range checkEnv {
			keepThis := true
			for displaced := range pointEnv(checkVec) {
				// Non-existent points count as ultra-high walls.
				if !g.Has(displaced) {
					continue
				}
				// If the to-be-checked point itself does not exist, it cannot be added. Neither can
				// it be added if it is too large.
				if !g.Has(checkVec) || g.Count(checkVec) &gt; max {
					keepThis = false
				}
				// We use &gt; here since we assume lava can also flow horizontally instead of just
				// downward all the time.
				if !result.Has(displaced) &amp;&amp; g.Count(checkVec) &gt; g.Count(displaced) {
					keepThis = false
				}
			}
			if keepThis &amp;&amp; !result.Has(checkVec) {
				err := result.Mark(checkVec, g.Count(checkVec))
				if err != nil {
					return Grid{}, err
				}
				// Add a point's entire surrounding to be checked for the same basin next time.
				for displaced := range pointEnv(checkVec) {
					if !sliceHasEntry(newEnv, displaced) {
						newEnv = append(newEnv, displaced)
					}
				}
			}
		}
		checkEnv = newEnv
	}
	return result, nil
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_9"><a class="anchor" href="#_how_to_run_9"></a><a class="link" href="#_how_to_run_9">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for part 2.
You can run the solution for part 1 using <code>cat input.dat | PART=1 go run .</code> or
in general by setting the environment variable <code>PART</code> to <code>1</code>.</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_go"><a class="anchor" href="#_day_10_go"></a><a class="link" href="#_day_10_go">Day 10: go</a></h3>
<div class="sect3">
<h4 id="_day_10_syntax_scoring"><a class="anchor" href="#_day_10_syntax_scoring"></a><a class="link" href="#_day_10_syntax_scoring">Day 10: Syntax Scoring</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the syntax scoring puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_10"><a class="anchor" href="#_oveview_10"></a><a class="link" href="#_oveview_10">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>stack.go</code>, which contains specifications of a FIFO.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">var openerCloser = map[string]string{
	"(": ")",
	"[": "]",
	"{": "}",
	"&lt;": "&gt;",
}

//nolint:gomnd
var delimScorePart1 = map[string]int{
	")": 3,
	"]": 57,
	"}": 1197,
	"&gt;": 25137,
}

//nolint:gomnd
const (
	multScorePart2 = 5
)

//nolint:gomnd
var delimScorePart2 = map[string]int{
	")": 1,
	"]": 2,
	"}": 3,
	"&gt;": 4,
}

// Check the syntax. Return whether the syntax was OK, the sequence of expected closing delimiters,
// and the first offending character.
func checkSyntax(line string) (bool, Stack, string) {
	stack := Stack{}
	for _, char := range strings.Split(line, "") {
		if closer, isOpener := openerCloser[char]; isOpener {
			// We found a new opener. Add the corresponding closer to the stack.
			stack.Push(closer)
		} else {
			// We did not find an opener. Check whether the closer we found is the expected one.
			expectedCloser, ok := stack.Pop()
			if !ok {
				// The stack was empty. An empty offender means the line had more closing delimiters
				// than opening ones.
				return false, stack, ""
			}
			if expectedCloser != char {
				// We did not find the closer we expected. The current char is the offender.
				return false, stack, char
			}
		}
	}
	return true, stack, ""
}

//nolint: funlen
func main() {
	lines, err := ReadLines()
	if err != nil {
		log.Fatal(err.Error())
	}
	remainingLines := []string{}
	// Part 1.
	scorePart1 := 0
	for _, line := range lines {
		ok, _, offender := checkSyntax(line)
		// The second condition means we currently only check corrupted lines but not such ones that
		// are incomplete.
		if !ok &amp;&amp; offender != "" {
			newScore, found := delimScorePart1[offender]
			if !found {
				log.Fatalf("cannot find score for offender %s", offender)
			}
			scorePart1 += newScore
		} else {
			// Keep all lines that are not corrupted.
			remainingLines = append(remainingLines, line)
		}
	}
	fmt.Printf("Score is %d points.\n", scorePart1)
	// Part 1.
	scoresPart2 := []int{}
	for _, line := range remainingLines {
		lineScore := 0
		ok, remainder, _ := checkSyntax(line)
		if !ok {
			// We wanted to filter out all corrupted lines already. Thus, finding one here is a bug.
			log.Fatalf("found corrupted line '%s' but we have filtered them all", line)
		}
		// Iterate over all the remaining characters.
		for char, nonEmpty := remainder.Pop(); nonEmpty; char, nonEmpty = remainder.Pop() {
			lineScore *= multScorePart2
			newScore, found := delimScorePart2[char]
			if !found {
				log.Fatalf("cannot find score for character %s", char)
			}
			lineScore += newScore
		}
		scoresPart2 = append(scoresPart2, lineScore)
	}
	// Pick the middle one.
	sort.Ints(scoresPart2)
	if len(scoresPart2)%2 != 1 {
		log.Fatal("we were promised an odd number of scores but found an even one")
	}
	// Integer division FTW.
	scorePart2 := scoresPart2[len(scoresPart2)/2]
	fmt.Printf("Score is %d points.\n", scorePart2)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stack.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Stack is a FIFO.
type Stack []string

// Push puts a value on the stack.
func (s *Stack) Push(val string) {
	*s = append(*s, val)
}

// Pop removes the topmost value and returns it. Also returns whether the stack was non-empty.
func (s *Stack) Pop() (string, bool) {
	if len(*s) == 0 {
		return "", false
	}
	val := (*s)[len(*s)-1]
	*s = (*s)[0 : len(*s)-1 : len(*s)-1]
	return val, true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_10"><a class="anchor" href="#_how_to_run_10"></a><a class="link" href="#_how_to_run_10">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution.</p>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_go"><a class="anchor" href="#_day_11_go"></a><a class="link" href="#_day_11_go">Day 11: go</a></h3>
<div class="sect3">
<h4 id="_day_11_dumbo_octopus"><a class="anchor" href="#_day_11_dumbo_octopus"></a><a class="link" href="#_day_11_dumbo_octopus">Day 11: Dumbo Octopus</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the dumbo octopus puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_11"><a class="anchor" href="#_oveview_11"></a><a class="link" href="#_oveview_11">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>grid.go</code>, which contains specifications of a grid and other
geometrical functionality.
This solution reuses quite a bit of the day 9 solution, which was based on the
day 5 solution.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	flashThreshold   = 9
	generationsPart1 = 100
	// We set a max number of generations to prevent an endless loop.
	maxGenerationsPart2 = 1000
)

// SolutionOutput is the output of `solve`'s channel.
type SolutionOutput struct {
	value int
	err   error
}

func solve(grid Grid, threshold int) &lt;-chan SolutionOutput {
	channel := make(chan SolutionOutput)

	go func() {
		for {
			flashesThisGen := 0
			if err := grid.MarkAll(1); err != nil {
				channel &lt;- SolutionOutput{0, err}
				close(channel)
				return
			}
			addUsBack := []Vec{}
			for o := grid.FilterThreshold(threshold); len(o) &gt; 0; o = grid.FilterThreshold(threshold) {
				// If we found any that will flash, handle them.
				// First, count their flashes.
				flashesThisGen += len(o)
				// Then, remove them from the grid. They cannot flash again this time. But remember to
				// add them back later.
				for _, p := range o {
					grid.RemoveAll(p)
					addUsBack = append(addUsBack, p)
				}
				// Then, their flashes will increase the energy levels of their environment. Propagate
				// that. Only points that are still on the grid will have their energy levels changed.
				for _, p := range o {
					if err := grid.MarkExistingEnv(1, p, pointEnv); err != nil {
						channel &lt;- SolutionOutput{0, err}
						close(channel)
						return
					}
				}
				// Rinse repeat until no more points exceed the threshold.
			}
			// Add those points back that were removed. Their initial energy level will be zero.
			for _, addBack := range addUsBack {
				if err := grid.Mark(addBack, 0); err != nil {
					channel &lt;- SolutionOutput{0, err}
					close(channel)
					return
				}
			}
			channel &lt;- SolutionOutput{flashesThisGen, nil}
		}
	}()

	return channel
}

//nolint: funlen
func main() {
	grid, err := ReadLinesAsGrid()
	if err != nil {
		log.Fatal(err.Error())
	}
	numOctopodes := len(grid)
	flashes := 0
	solutionGenerator := solve(grid, flashThreshold)
	for gen := 1; gen &lt;= generationsPart1; gen++ {
		sol := &lt;-solutionGenerator
		if err := sol.err; err != nil {
			log.Fatal(err.Error())
		}
		flashes += sol.value
	}
	fmt.Printf("The octopodes flashed %d times in %d generations.\n", flashes, generationsPart1)
	for gen := generationsPart1; gen &lt;= maxGenerationsPart2; gen++ {
		sol := &lt;-solutionGenerator
		if err := sol.err; err != nil {
			log.Fatal(err.Error())
		}
		if sol.value == numOctopodes {
			fmt.Printf(
				"The octopodes all flashed together the 1st time the %d'th generation.\n", gen,
			)
			return
		}
	}
	log.Fatal("the octopodes never flashed all together")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// ReadLinesAsGrid reads all lines from stdin as a grid. That is, each point on the grid has a
// value and a location.
func ReadLinesAsGrid() (Grid, error) {
	lineIdx := 0
	result := make(Grid)
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return Grid{}, err
		}
		line = strings.TrimSpace(line)
		ints, err := strSliceToIntSlice(strings.Split(line, ""))
		if err != nil {
			return Grid{}, err
		}
		for rowIdx, val := range ints {
			// This is lazy but I wanted to re-use old code.
			point, err := VecFromStr(fmt.Sprintf("%d%s%d", lineIdx, vecSep, rowIdx))
			if err != nil {
				return Grid{}, err
			}
			err = result.Mark(point, val)
			if err != nil {
				return Grid{}, err
			}
		}
		if err != nil {
			return Grid{}, err
		}
		lineIdx++
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grid.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Vec is a 2D vector. Most of it has been taken from a previous solution.
type Vec struct {
	x, y int
}

var (
	unitX         = Vec{x: 1}
	unitY         = Vec{y: 1}
	pointEnvDisps = []Vec{
		// x==1
		unitX.Add(unitY),
		unitX,
		unitX.Sub(unitY),
		// x==0
		unitY,
		unitY.Inv(),
		// x==-1
		unitX.Inv().Add(unitY),
		unitX.Inv(),
		unitX.Inv().Sub(unitY),
	}
)

// Obtain an iterator over a point's environment.
func pointEnv(point Vec) &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for _, disp := range pointEnvDisps {
			displaced := point.Add(disp)
			channel &lt;- displaced
		}
		close(channel)
	}()
	return channel
}

// VecFromStr converts a sring into a vector.
func VecFromStr(str string) (Vec, error) {
	fields := trimStrings(strings.Split(str, vecSep))
	if len(fields) != tokensPerPoint {
		return Vec{}, fmt.Errorf("cannot parse %v as vector, wrong number of fields", str)
	}
	ints, err := strSliceToIntSlice(fields)
	if err != nil {
		return Vec{}, fmt.Errorf("cannot parse %s as vector, %s", str, err.Error())
	}
	result := Vec{
		x: ints[0],
		y: ints[1],
	}
	return result, nil
}

// Add adds one vector to another one.
func (v Vec) Add(delta Vec) Vec {
	result := Vec{
		x: v.x + delta.x,
		y: v.y + delta.y,
	}
	return result
}

// Mul multiplies each component of a vector with a number.
func (v Vec) Mul(factor int) Vec {
	result := Vec{
		x: v.x * factor,
		y: v.y * factor,
	}
	return result
}

// Inv inverts a vector.
func (v Vec) Inv() Vec {
	return v.Mul(-1)
}

// Sub subtracts a vector'v data from another one'v.
func (v Vec) Sub(delta Vec) Vec {
	return v.Add(delta.Inv())
}

// Grid is a lazily evaluated grid that supports marking points on it. Most of it has been taken
// from a previous solution.
type Grid map[Vec]int

// Mark marks a point on the grid n times. Don't accept numbers &lt;0.
func (g *Grid) Mark(entry Vec, n int) error {
	if n &lt; 0 {
		return fmt.Errorf("can only mark non-negative times")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*g)[entry] = (*g)[entry] + n
	return nil
}

// Count determines how often a point has been marked.
func (g *Grid) Count(entry Vec) int {
	return (*g)[entry]
}

// Has determines whether a point is on the grid.
func (g *Grid) Has(entry Vec) bool {
	_, ok := (*g)[entry]
	return ok
}

// RemoveAll removes all markings for a specific point.
func (g *Grid) RemoveAll(entry Vec) {
	delete(*g, entry)
}

// FilterThreshold returns all points whose value exceeds a threshold.
func (g *Grid) FilterThreshold(threshold int) []Vec {
	result := []Vec{}
	for point := range g.Points() {
		if g.Count(point) &gt; threshold {
			result = append(result, point)
		}
	}
	return result
}

// MarkAll maks all points in the grid with the same value.
func (g *Grid) MarkAll(val int) error {
	for p := range g.Points() {
		if err := g.Mark(p, val); err != nil {
			return err
		}
	}
	return nil
}

// EnvFn is a function type used to determine a point's environment.
type EnvFn = func(point Vec) &lt;-chan Vec

// MarkExistingEnv marks all points by the specified value in the environment of a given point. The
// environment is defined by envFn. Only points that actually exist will be marked.
func (g *Grid) MarkExistingEnv(val int, point Vec, envFn EnvFn) error {
	for neigh := range envFn(point) {
		if !g.Has(neigh) {
			continue
		}
		if err := g.Mark(neigh, val); err != nil {
			return err
		}
	}
	return nil
}

// Points returns an iterator over all points on the grid.
func (g *Grid) Points() &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for point := range *g {
			channel &lt;- point
		}
		close(channel)
	}()
	return channel
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_11"><a class="anchor" href="#_how_to_run_11"></a><a class="link" href="#_how_to_run_11">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for both parts.</p>
</div>
<a id="day12" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_12_go"><a class="anchor" href="#_day_12_go"></a><a class="link" href="#_day_12_go">Day 12: go</a></h3>
<div class="sect3">
<h4 id="_day_12_passage_pathing"><a class="anchor" href="#_day_12_passage_pathing"></a><a class="link" href="#_day_12_passage_pathing">Day 12: Passage Pathing</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the passage pathing puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_12"><a class="anchor" href="#_oveview_12"></a><a class="link" href="#_oveview_12">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where some helper functions are.
This solution also re-uses the counting set implementation of day 3 in
<code>set.go</code> but using integers instead of string tokens this time.
It also contains a <code>stack.go</code> and a <code>node.go</code> that implement a stack and a node
with connections, respectively.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	startNode = "start"
	endNode   = "end"
)

// func printStack(stack *Stack) {
// 	for _, node := range *stack {
// 		nodeStr := nodeToStr(node.Node)
// 		fmt.Printf("%s -&gt; %d\n", nodeStr, *node.ConnectionCount)
// 	}
// }

func atOrOverLimit(node *Node, curr int) bool {
	if node.Limit == 0 {
		// This is a node we may visit any number of times.
		return false
	}
	return curr &gt;= node.Limit
}

// A validityFn checks whether the currently-attempted solution is stil a valid one.
type validityFn = func(*CountingSet) bool

//nolint:funlen
func findConnections(nodes []*Node, start, end string, checkFn validityFn) (&lt;-chan []*Node, error) {
	channel := make(chan []*Node)
	startNode := FindNode(nodes, startNode)
	endNode := FindNode(nodes, endNode)
	if startNode == nil || endNode == nil {
		close(channel)
		return channel, fmt.Errorf("start or end not defined")
	}
	stack := Stack{}
	stack.Push(startNode, 0)
	set := CountingSet{}
	_ = set.Add(startNode)

	go func() {
		for {
			topNode := stack.Peek().Node
			progress := stack.Peek().ConnectionCount

			if !checkFn(&amp;set) {
				// This is no longer a valid solution. Don't continue to explore solutions based on
				// it. Make sure to skip it by setting the progress counter to its maximum.
				*progress = len(topNode.Connections)
			}

			if *progress &lt; len(topNode.Connections) {
				// We have not yet tried out all connections. Try out the next one.
				// Get the next in line and check if we have not yet exceeded its visitation limit.
				var nextTop *Node
				for idx, checkNext := range topNode.Connections[*progress:] {
					if !atOrOverLimit(checkNext, set.Count(checkNext)) {
						*progress += idx
						nextTop = checkNext
						break
					}
				}
				if nextTop == nil {
					// We've not found any available connections. Thus, trigger the removal of the
					// topmost node and continue with the one beneath it. This is done by stating
					// that we've tried out all possible connections from this one.
					*progress = len(topNode.Connections)
				}
				if nextTop == endNode {
					// We have found a connection! Yeah! Emit it.
					stack.Push(nextTop, 0)
					channel &lt;- stack.ToList()
					// fmt.Println("EMIT")
					_, _ = stack.Pop()
					// Make sure we don't check this connection again.
					*progress++
					// Make sure we never traverse the end node.
					continue
				}
				if nextTop != nil {
					// We know the next top node. Add it.
					stack.Push(nextTop, 0)
					_ = set.Add(nextTop)
				}
			}
			if *progress &gt;= len(topNode.Connections) {
				// We have exceeded what we can achieve with this topmost node. Remove the top-most
				// one and continue from the one underneath.
				oldTop, nonEmpty := stack.Pop()
				set.Remove(oldTop.Node)
				if nonEmpty {
					// If the stack is not empty, make sure we check the next connection for the new
					// top node.
					// fmt.Println("Removing", nodeToStr(oldTop.Node))
					// If we ever remove the start node, we have reached the end.
					if oldTop.Node == startNode {
						close(channel)
						return
					}
					newTop := stack.Peek()
					*newTop.ConnectionCount++
				}
			}
		}
	}()

	return channel, nil
}

// Filter for part 1. Only count connections that don't visit any small cave more than once.
func filterPart1(set *CountingSet) bool {
	threshold := 1
	filterFn := func(node *Node, curr int) bool {
		if strings.ToUpper(node.ID) == node.ID {
			// This is a node we may visit any number of times. Thus, don't filter it out.
			return false
		}
		return curr &gt; threshold
	}
	// If we didn't filter out anything, that means the input describes a connection that does not
	// visit any small cave more than once.
	return set.FilterCount(filterFn) == 0
}

// Filter for part 2. Only count connections that don't visit more than one small cave more than
// once.
func filterPart2(set *CountingSet) bool {
	threshold := 1
	filterFn := func(node *Node, curr int) bool {
		if strings.ToUpper(node.ID) == node.ID {
			// This is a node we may visit any number of times. Thus, don't filter it out.
			return false
		}
		return curr &gt; threshold
	}
	// If we didn't filter out more than one entry, that means the input describes a connection that
	// does not visit more than one small cave more than twice.
	return set.FilterCount(filterFn) &lt;= 1
}

func setFromList(nodes []*Node) (CountingSet, error) {
	set := CountingSet{}
	for _, node := range nodes {
		if err := set.Add(node); err != nil {
			return CountingSet{}, err
		}
	}
	return set, nil
}

//nolint: funlen
func main() {
	nodes, err := ReadLinesAsNodes()
	if err != nil {
		log.Fatal(err.Error())
	}
	fmt.Printf("Nodes: %s\n", NodesToStr(nodes))
	iterator, err := findConnections(nodes, startNode, endNode, filterPart2)
	if err != nil {
		log.Fatal(err)
	}
	pathCountPart1 := 0
	pathCountPart2 := 0
	for con := range iterator {
		set, err := setFromList(con)
		if err != nil {
			log.Fatal("internal error while filtering")
		}
		if filterPart1(&amp;set) {
			pathCountPart1++
		}
		// We have already filtered for part 2's validity function.
		pathCountPart2++
	}
	fmt.Printf("there are %d paths for part 1\n", pathCountPart1)
	fmt.Printf("there are %d paths for part 2\n", pathCountPart2)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// FindNode finds a node based on its ID in a list of them.
func FindNode(nodes []*Node, id string) *Node {
	for _, checkNode := range nodes {
		if checkNode.ID == id {
			return checkNode
		}
	}
	return nil
}

// ReadLinesAsNodes reads all lines from stdin as nodes. Note that each line refers to more than one
// node.
func ReadLinesAsNodes() ([]*Node, error) {
	var result []*Node
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return []*Node{}, err
		}
		fields := trimStrings(strings.Split(line, connectionSep))
		// Try to find an existing node of the names. If none is found, create one.
		for _, field := range fields {
			if node := FindNode(result, field); node == nil {
				// No node found, add a new one.
				// A limit of zero means no limit in visiting.
				limit := 0
				if strings.ToLower(field) == field {
					// Lower case node name, we cannot visit it more than once.
					// But for part 2, we may visit at most one small cave twice. Thus, we consider
					// small caves as though they can be visited twice and filter out later.
					limit = 2
				}
				// The start and end nodes must never be visited more than once.
				if field == "start" || field == "end" {
					limit = 1
				}
				newNode := &amp;Node{
					ID:          field,
					Limit:       limit,
					Connections: []*Node{},
				}
				result = append(result, newNode)
			}
		}
		// For each node in this line, add links to all other nodes mentioned in it. Note that
		// FindNode will not be able to return nil here as we already added all nodes mentioned in
		// this line.
		for _, startField := range fields {
			startNode := FindNode(result, startField)
			for _, endField := range fields {
				if endField == startField {
					continue
				}
				endNode := FindNode(result, endField)
				// Luckily, AddConnection will not do anything if the node is already known.
				startNode.AddConnection(endNode)
				endNode.AddConnection(startNode)
			}
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>set.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// CountingSet is a set that also knows how often each element has been added. It does support
// non-empty strings only.
type CountingSet map[*Node]int

// Add adds an entry to the set. The empty *Node is not supported!
func (c *CountingSet) Add(entry *Node) error {
	if entry == nil {
		return fmt.Errorf("empty *Node not supported in counting set")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*c)[entry] = (*c)[entry] + 1
	return nil
}

// Count determines how often an entry has been added to the set.
func (c *CountingSet) Count(entry *Node) int {
	return (*c)[entry]
}

// Remove removes one count for a specific key.
func (c *CountingSet) Remove(entry *Node) {
	if (*c)[entry] == 0 || (*c)[entry] == 1 {
		// Trying to remove an entry we don't have or one that has just one count left results in
		// that entry no longer being present.
		c.RemoveAll(entry)
		return
	}
	(*c)[entry] = (*c)[entry] - 1
}

// RemoveAll removes all counts for a specific key.
func (c *CountingSet) RemoveAll(entry *Node) {
	delete(*c, entry)
}

// FilterFn is a function that can be used to filter entries.
type FilterFn = func(*Node, int) bool

// Filter filters ebtries based on a predicate. That predicate, a FilterFn, gets the entry checked
// and its count in the data set.
func (c *CountingSet) Filter(predicate FilterFn) []*Node {
	result := []*Node{}
	for entry, count := range *c {
		if predicate(entry, count) {
			result = append(result, entry)
		}
	}
	return result
}

// FilterCount counts how many points would be filtered out by a FilterFn.
func (c *CountingSet) FilterCount(predicate FilterFn) int {
	result := 0
	for entry, count := range *c {
		if predicate(entry, count) {
			result++
		}
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stack.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// StackedNode tracks nodes on the stack as well as how many of its connections have not yet been
// visited.
type StackedNode struct {
	Node            *Node
	ConnectionCount *int
}

// Stack is a FIFO.
type Stack []StackedNode

// Push puts a value on the stack.
func (s *Stack) Push(node *Node, connectionCount int) {
	stackedNode := StackedNode{
		Node:            node,
		ConnectionCount: &amp;connectionCount,
	}
	*s = append(*s, stackedNode)
}

// Pop removes the topmost value and returns it. Also returns whether the stack was non-empty.
func (s *Stack) Pop() (*StackedNode, bool) {
	if len(*s) == 0 {
		return &amp;StackedNode{}, false
	}
	val := &amp;(*s)[len(*s)-1]
	*s = (*s)[0 : len(*s)-1 : len(*s)-1]
	return val, true
}

// Peek returns the top-most entry.
func (s *Stack) Peek() *StackedNode {
	if len(*s) == 0 {
		return &amp;StackedNode{}
	}
	return &amp;(*s)[len(*s)-1]
}

// ToList gets the nodes stacked in the stack in the order they were stacked in (FIFO).
func (s *Stack) ToList() []*Node {
	result := []*Node{}
	for _, stackedNode := range *s {
		result = append(result, stackedNode.Node)
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>node.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Node is a node in a tree.
type Node struct {
	ID          string
	Limit       int
	Connections []*Node
}

// AddConnection adds a connection to a node, but only if that connection does not yet exist. If it
// does, nothing is done.
func (n *Node) AddConnection(connection *Node) {
	for _, con := range n.Connections {
		if con == connection {
			return
		}
	}
	n.Connections = append(n.Connections, connection)
}

// NodeToStr provides a string representation for a node.
func NodeToStr(node *Node) string {
	connectionIDs := []string{}
	for _, con := range node.Connections {
		connectionIDs = append(connectionIDs, con.ID)
	}
	connections := strings.Join(connectionIDs, ",")
	str := fmt.Sprintf("{N: %s, L: %d, C: %s}", node.ID, node.Limit, connections)
	return str
}

// NodesToStr provides a string representation for multiple nodes.
func NodesToStr(nodes []*Node) string {
	str := ""
	for _, node := range nodes {
		str += NodeToStr(node) + "\n"
	}
	return str
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_12"><a class="anchor" href="#_how_to_run_12"></a><a class="link" href="#_how_to_run_12">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution for both parts.
The solution for part 1 will be output first, followed by that for part 2.</p>
</div>
<a id="day13" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_13_go"><a class="anchor" href="#_day_13_go"></a><a class="link" href="#_day_13_go">Day 13: go</a></h3>
<div class="sect3">
<h4 id="_day_13_transparent_origami"><a class="anchor" href="#_day_13_transparent_origami"></a><a class="link" href="#_day_13_transparent_origami">Day 13: Transparent Origami</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the transparent origami puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_13"><a class="anchor" href="#_oveview_13"></a><a class="link" href="#_oveview_13">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>grid.go</code>, which contains specifications of a grid and other
geometrical functionality.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">func foldPoint(point Vec, ins Instruction) Vec {
	// Assume the point is unaffected.
	newPoint := point
	if ins.Dir == "x" &amp;&amp; point.x &gt; ins.Val {
		// Affected by fold.
		newPoint = Vec{
			x: ins.Val - (point.x - ins.Val),
			y: point.y,
		}
	} else if ins.Dir == "y" &amp;&amp; point.y &gt; ins.Val {
		// Affected by fold.
		newPoint = Vec{
			x: point.x,
			y: ins.Val - (point.y - ins.Val),
		}
	} else if !strings.Contains("xy", ins.Dir) {
		// Cannot reach here, so fatalling is OK if we do.
		log.Fatal("internal error while folding")
	}
	return newPoint
}

func fold(grid Grid, ins Instruction) (Grid, error) {
	result := Grid{}
	if !strings.Contains("xy", ins.Dir) {
		return Grid{}, fmt.Errorf("internal error")
	}
	// Check that no point is on the fold line.
	for p := range grid.Points() {
		if (ins.Dir == "x" &amp;&amp; p.x == ins.Val) || (ins.Dir == "y" &amp;&amp; p.y == ins.Val) {
			return Grid{}, fmt.Errorf("point on fold line")
		}
	}
	// Fold the points.
	for p := range grid.Points() {
		newPoint := foldPoint(p, ins)
		err := result.Mark(newPoint, 1)
		if err != nil {
			return Grid{}, err
		}
	}
	return result, nil
}

//nolint: funlen
func main() {
	prettyPrint := os.Getenv(prettyPrintEnvVar) == "1"
	grid, ins, err := ReadLinesAsGridAndInstructions()
	if err != nil {
		log.Fatal(err.Error())
	}
	if prettyPrint {
		fmt.Println(grid.Pretty(1))
	}
	for _, instruct := range ins {
		folded, err := fold(grid, instruct)
		if err != nil {
			log.Fatal(err.Error())
		}
		fmt.Printf("There are %d marked points.\n", len(folded))
		if prettyPrint {
			fmt.Println(folded.Pretty(1))
		}
		// err = folded.ReduceMarked(1)
		// if err != nil {
		// 	log.Fatal(err.Error())
		// }
		grid = folded
	}
	fmt.Println()
	// We need this in the end even though generating it might take long.
	fmt.Println(grid.Pretty(1)) //nolint:gomnd
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	defaultGridVal    = 1
	instructionSep    = "fold along "
	instructionFields = 2
	lineSep           = "="
)

// Instruction describes a folding instruction.
type Instruction struct {
	Val int
	Dir string
}

func instructionFromString(str string) (Instruction, error) {
	fields := strings.Split(str, lineSep)
	if len(fields) != instructionFields {
		return Instruction{}, fmt.Errorf("cannot convert %s to instruction, fields", str)
	}
	var result Instruction
	val, err := strconv.Atoi(fields[1])
	if err != nil {
		return Instruction{}, err
	}
	result = Instruction{
		Val: val,
		Dir: fields[0],
	}
	if !strings.Contains("xy", fields[0]) {
		return Instruction{}, fmt.Errorf("cannot convert %s to instruction, coord", str)
	}
	return result, nil
}

// ReadLinesAsGridAndInstructions reads all lines from stdin as a grid and instructions.
func ReadLinesAsGridAndInstructions() (Grid, []Instruction, error) {
	result := make(Grid)
	instructions := []Instruction{}
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, instructions, nil
		}
		if err != nil {
			return Grid{}, []Instruction{}, err
		}
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			// Ignore empty lines.
			continue
		}
		//nolint:nestif
		if strings.Contains(line, instructionSep) {
			// Line with instruction.
			fields := strings.Split(line, instructionSep)
			if len(fields) != instructionFields {
				err := fmt.Errorf("cannot extract instruction from %s", line)
				return Grid{}, []Instruction{}, err
			}
			ins, err := instructionFromString(fields[1])
			if err != nil {
				return Grid{}, []Instruction{}, err
			}
			instructions = append(instructions, ins)
		} else {
			// Line with grid point.
			vec, err := VecFromStr(line)
			if err != nil {
				return Grid{}, []Instruction{}, err
			}
			err = result.Mark(vec, defaultGridVal)
			if err != nil {
				return Grid{}, []Instruction{}, err
			}
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grid.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Vec is a 2D vector. Most of it has been taken from a previous solution.
type Vec struct {
	x, y int
}

// VecFromStr converts a sring into a vector.
func VecFromStr(str string) (Vec, error) {
	fields := trimStrings(strings.Split(str, vecSep))
	if len(fields) != tokensPerPoint {
		return Vec{}, fmt.Errorf("cannot parse %v as vector, wrong number of fields", str)
	}
	ints, err := strSliceToIntSlice(fields)
	if err != nil {
		return Vec{}, fmt.Errorf("cannot parse %s as vector, %s", str, err.Error())
	}
	result := Vec{
		x: ints[0],
		y: ints[1],
	}
	return result, nil
}

// Add adds one vector to another one.
func (v Vec) Add(delta Vec) Vec {
	result := Vec{
		x: v.x + delta.x,
		y: v.y + delta.y,
	}
	return result
}

// Mul multiplies each component of a vector with a number.
func (v Vec) Mul(factor int) Vec {
	result := Vec{
		x: v.x * factor,
		y: v.y * factor,
	}
	return result
}

// Inv inverts a vector.
func (v Vec) Inv() Vec {
	return v.Mul(-1)
}

// Sub subtracts a vector'v data from another one'v.
func (v Vec) Sub(delta Vec) Vec {
	return v.Add(delta.Inv())
}

// Grid is a lazily evaluated grid that supports marking points on it. Most of it has been taken
// from a previous solution.
type Grid map[Vec]int

// Mark marks a point on the grid n times. Don't accept numbers &lt;0.
func (g *Grid) Mark(entry Vec, n int) error {
	if n &lt; 0 {
		return fmt.Errorf("can only mark non-negative times")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*g)[entry] = (*g)[entry] + n
	return nil
}

// Count determines how often a point has been marked.
func (g *Grid) Count(entry Vec) int {
	return (*g)[entry]
}

// Has determines whether a point is on the grid.
func (g *Grid) Has(entry Vec) bool {
	_, ok := (*g)[entry]
	return ok
}

// RemoveAll removes all markings for a specific point.
func (g *Grid) RemoveAll(entry Vec) {
	delete(*g, entry)
}

// Points returns an iterator over all points on the grid.
func (g *Grid) Points() &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for point := range *g {
			channel &lt;- point
		}
		close(channel)
	}()
	return channel
}

// ReduceMarked sets the marking value of all points that are marked to the given value.
func (g *Grid) ReduceMarked(val int) error {
	if val &lt; 0 {
		return fmt.Errorf("can only mark non-negative times")
	}
	for p := range g.Points() {
		(*g)[p] = val
	}
	return nil
}

func (g *Grid) topLeft() (int, int) {
	foundX, foundY := false, false
	minX, minY := 0, 0
	for p := range g.Points() {
		if !foundX || p.x &lt; minX {
			minX = p.x
			foundX = true
		}
		if !foundY || p.y &lt; minY {
			minY = p.y
			foundY = true
		}
	}
	return minX, minY
}

func (g *Grid) bottomRight() (int, int) {
	foundX, foundY := false, false
	maxX, maxY := 0, 0
	for p := range g.Points() {
		if !foundX || p.x &gt; maxX {
			maxX = p.x
			foundX = true
		}
		if !foundY || p.y &gt; maxY {
			maxY = p.y
			foundY = true
		}
	}
	return maxX, maxY
}

// Pretty creates a pretty string representation of this grid.
func (g *Grid) Pretty(digits int) string {
	result := ""
	empty := " "
	maxVal := 10
	for count := 1; count &lt; digits; count++ {
		empty += " "
		maxVal *= 10
	}
	formatStr := fmt.Sprintf("%%-%dd", digits)
	minX, minY := g.topLeft()
	maxX, maxY := g.bottomRight()
	for y := minY; y &lt;= maxY; y++ {
		for x := minX; x &lt;= maxX; x++ {
			val := g.Count(Vec{x: x, y: y})
			if val &gt; 0 {
				result += fmt.Sprintf(formatStr, val)
				if val &gt;= maxVal {
					// Return the string up to the offending point so that the caller sees what the
					// offending number was. This is a hack at best but good enough for me right
					// now.
					return result + "\nINCOMPLETE"
				}
			} else {
				result += empty
			}
		}
		result += "\n"
	}
	return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_13"><a class="anchor" href="#_how_to_run_13"></a><a class="link" href="#_how_to_run_13">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run the solution.</p>
</div>
<a id="day14" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_14_go"><a class="anchor" href="#_day_14_go"></a><a class="link" href="#_day_14_go">Day 14: go</a></h3>
<div class="sect3">
<h4 id="_day_14_extended_polymerization"><a class="anchor" href="#_day_14_extended_polymerization"></a><a class="link" href="#_day_14_extended_polymerization">Day 14: Extended Polymerization</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the extended polymerisation
puzzle.</p>
</div>
<div class="sect4">
<h5 id="_oveview_14"><a class="anchor" href="#_oveview_14"></a><a class="link" href="#_oveview_14">Oveview</a></h5>
<div class="paragraph">
<p>This solution contains a <code>solution.go</code>, which defines the main executable.
There is also a <code>utils.go</code>, which is currently where all helper functions that
might be re-used later on reside.
There is also a <code>rep.go</code>, which contains specifications of a replacement
specification.</p>
</div>
<div class="paragraph">
<p>There are two implementations here.
The first uses goroutines and achieves some degree of parallelisation this way.
It&#8217;s by no means great, though.
For example, you cannot solve part 2 with it, it&#8217;s just now efficient enough.
The second solution does not suffer from such exponential scaling.
Thus, it can be used to solve both parts quickly.</p>
</div>
<div class="paragraph">
<p><code>solution.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">const (
	// We make the buffer large to achieve some degree of parallelism with goroutines.
	buffer      = 100000
	roundsPart1 = 10
	roundsPart2 = 40
)

func makeMap(replacements []Replacement) map[Match]rune {
	result := map[Match]rune{}
	for _, rep := range replacements {
		result[rep.Match] = rep.Insert
	}
	return result
}

func replace(input &lt;-chan rune, output chan&lt;- rune, replacements map[Match]rune, idx int) {
	myReps := map[Match]rune{}
	// Copy the map so that each goroutine has its own.
	for key, val := range replacements {
		myReps[key] = val
	}
	lastRune := &lt;-input
	for char := range input {
		output &lt;- lastRune
		if match, ok := myReps[Match{Left: lastRune, Right: char}]; ok {
			output &lt;- match
		}
		lastRune = char
	}
	output &lt;- lastRune
	close(output)
	fmt.Printf("Closing stage %d.\n", idx)
}

func feed(input string, channel chan&lt;- rune) {
	for _, char := range input {
		channel &lt;- char
	}
	close(channel)
	fmt.Println("Closing feeder.")
}

func count(input &lt;-chan rune) map[rune]int {
	result := map[rune]int{}
	for char := range input {
		result[char]++
	}
	return result
}

func max(input map[rune]int) int {
	found := false
	var max int
	for _, val := range input {
		if !found || val &gt; max {
			found = true
			max = val
		}
	}
	return max
}

func min(input map[rune]int) int {
	found := false
	var min int
	for _, val := range input {
		if !found || val &lt; min {
			found = true
			min = val
		}
	}
	return min
}

// Run the polymerization riddle for a given number of rounds. Note how we never construct the full
// string in memory.
func runRounds(input string, reps map[Match]rune, rounds int) map[rune]int {
	// Construct pipeline.
	inChannel := make(chan rune, buffer)
	var outChannel chan rune
	// Run pipeline.
	go feed(input, inChannel)
	for roundIdx := 0; roundIdx &lt; rounds; roundIdx++ {
		outChannel = make(chan rune, buffer)
		go replace(inChannel, outChannel, reps, roundIdx)
		inChannel = outChannel
	}
	counts := count(outChannel)
	return counts
}

// Split a string into pairs of characters. Each pair knows whether it's in the middle or at an
// edge. If it's at an edge, it also knows which one.
func stringToMatches(str string) []Match {
	result := []Match{}
	if len(str) == 0 {
		// This is an error case that will never happen. Thus, don't catch it.
		return []Match{}
	}
	split := strings.Split(str, "")
	lastChar := rune(split[0][0])
	for idx, c := range split[1:] {
		char := rune(c[0])
		var leftEdge, rightEdge bool
		if idx == 0 {
			leftEdge = true
		}
		if idx == len(split)-2 {
			rightEdge = true
		}
		match := Match{Left: lastChar, Right: char, LeftEdge: leftEdge, RightEdge: rightEdge}
		lastChar = char
		result = append(result, match)
	}
	return result
}

// Perform one pair split according to the rules. That is, a pair is converted into two pairs by
// inserting a letter in between. This also takes care of propagating the information of which
// matches are at the edges.
func translateMatch(match Match, reps *map[Match]rune) []Match {
	// make sure to strip away the edge information. Otherwise, matches at the edges will never be
	// found.
	matchWithoutEdge := Match{Right: match.Right, Left: match.Left}
	if insert, foundMatch := (*reps)[matchWithoutEdge]; foundMatch {
		leftMatch := Match{
			Left:      match.Left,
			Right:     insert,
			LeftEdge:  match.LeftEdge,
			RightEdge: false,
		}
		rightMatch := Match{
			Left:      insert,
			Right:     match.Right,
			LeftEdge:  false,
			RightEdge: match.RightEdge,
		}
		return []Match{leftMatch, rightMatch}
	}
	// No match found, return the original one.
	return []Match{match}
}

// Run the polymerization riddle for a given number of rounds, but do it differently. This approach
// does not scale exponentially with the number of rounds.
func runRoundsDifferently(input string, reps map[Match]rune, rounds int) map[rune]int {
	matches := stringToMatches(input)
	// We treat all identical matches the same way.
	matchCounts := map[Match]int{}
	for _, match := range matches {
		matchCounts[match]++
	}
	// Run!
	for round := 0; round &lt; rounds; round++ {
		newMatchCounts := map[Match]int{}
		for match, count := range matchCounts {
			newMatches := translateMatch(match, &amp;reps)
			for _, newM := range newMatches {
				newMatchCounts[newM] += count
			}
		}
		matchCounts = newMatchCounts
	}
	foundLeftEdge := false
	foundRightEdge := false
	// Count characters! Each char is in two pairs apart from the ones at the edges.
	result := map[rune]int{}
	// First, count all characters in all pairs. This will be twice the number we want.
	for match, count := range matchCounts {
		// Count each character in a pair for each pair that has it.
		result[match.Right] += count
		result[match.Left] += count
		// Handle edge cases (pun very much intended).
		if (match.LeftEdge || match.RightEdge) &amp;&amp; count != 1 {
			// Error case, should never happen, so fatalling is OK if it does.
			log.Fatal("more than one character at the left edge")
		}
		// Also add one for each character at an edge. This makes sure we also counted them twice.
		if match.LeftEdge {
			if foundLeftEdge {
				log.Fatal("there can only be one left edge")
			}
			result[match.Left]++
		}
		if match.RightEdge {
			if foundRightEdge {
				log.Fatal("there can only be one right edge")
			}
			result[match.Right]++
		}
	}
	// Then, divide all counts by two.
	for char, count := range result {
		if count%2 != 0 {
			// Error case, should never happen, so fatalling is OK if it does.
			log.Fatalf("cannot divide odd number %d by 2 for %c", count, char)
		}
		result[char] /= 2
	}
	return result
}

//nolint: funlen
func main() {
	input, replacements, err := ReadLinesAsReplacementsOrInput()
	if err != nil {
		log.Fatal(err.Error())
	}
	reps := makeMap(replacements)
	counts := runRounds(input, reps, roundsPart1)
	fmt.Printf(
		"Part 1: max: %d, min: %d, diff: %d\n",
		max(counts), min(counts), max(counts)-min(counts),
	)
	// Part 2 cannot be solved this way, it just takes too long. Thus, solve it differently.
	counts = runRoundsDifferently(input, reps, roundsPart1)
	fmt.Printf(
		"Part 1 differently: max: %d, min: %d, diff: %d\n",
		max(counts), min(counts), max(counts)-min(counts),
	)
	counts = runRoundsDifferently(input, reps, roundsPart2)
	fmt.Printf(
		"Part 2 differently: max: %d, min: %d, diff: %d\n",
		max(counts), min(counts), max(counts)-min(counts),
	)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utils.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// ReadLinesAsReplacementsOrInput reads all lines from stdin as replacement instructions or input.
func ReadLinesAsReplacementsOrInput() (string, []Replacement, error) {
	var result []Replacement
	var input string
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return input, result, nil
		}
		if err != nil {
			return "", []Replacement{}, err
		}
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			// Skip empty lines.
			continue
		}
		if strings.Contains(line, repSep) {
			// A line with a replacement.
			parsed, err := RepFromString(line)
			if err != nil {
				return "", []Replacement{}, err
			}
			result = append(result, parsed)
		} else {
			// A line with the input string.
			if len(input) != 0 {
				err := fmt.Errorf("already processed input")
				return "", []Replacement{}, err
			}
			input = line
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>rep.go</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-go" data-lang="go">// Match described one match of two characters.
type Match struct {
	Left      rune
	Right     rune
	LeftEdge  bool
	RightEdge bool
}

func b2s(b bool) rune {
	if b {
		return '1'
	}
	return '0'
}

// ToString provides a nice string representation for a match.
func (m Match) ToString() string {
	return fmt.Sprintf(
		"{%c%c [%c|%c]}",
		m.Left, m.Right, b2s(m.LeftEdge), b2s(m.RightEdge),
	)
}

// Replacement describes one replacement instruction by insertion.
type Replacement struct {
	Match  Match
	Insert rune
}

// RepFromString converts a sring into a replacement instruction.
func RepFromString(str string) (Replacement, error) {
	fields := trimStrings(strings.Split(str, repSep))
	if len(fields) != tokensPerRep {
		err := fmt.Errorf("cannot parse %v as rep, wrong number of fields", str)
		return Replacement{}, err
	}
	if len(fields[0]) != tokensPerRep {
		err := fmt.Errorf("cannot parse %v as rep, wrong number of characters", str)
		return Replacement{}, err
	}
	if len(fields[1]) != 1 {
		err := fmt.Errorf("cannot parse %v as rep, wrong number of insertions", str)
		return Replacement{}, err
	}
	match := Match{
		Left:  rune(fields[0][0]),
		Right: rune(fields[0][1]),
	}
	rep := Replacement{
		Match:  match,
		Insert: rune(fields[1][0]),
	}
	return rep, nil
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_14"><a class="anchor" href="#_how_to_run_14"></a><a class="link" href="#_how_to_run_14">How to run</a></h5>
<div class="paragraph">
<p>Assuming the required input is in a file <code>input.dat</code>, you only need to execute
<code>cat input.dat | go run .</code> to run both solutions.</p>
</div>
<a id="day15" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_15_go"><a class="anchor" href="#_day_15_go"></a><a class="link" href="#_day_15_go">Day 15: go</a></h3>
<div class="paragraph">
<p><span class="small">this documentation is autogenerated. Add a <code>README.adoc</code> to your solution to take over the control of this :-)</span></p>
</div>
<div class="sect3">
<h4 id="_go"><a class="anchor" href="#_go"></a><a class="link" href="#_go">go</a></h4>
<div class="listingblock">
<div class="title">solution.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>// Package main is the main executable for razziel89's solution for this day's advent.
package main

import (
	"fmt"
	"log"

	"github.com/razziel89/astar"
)

// tag::solution[]

const (
	numNeigh = 4
	replicas = 5
)

func gridToNodes(grid Grid) (map[*astar.Node]struct{}, *astar.Node, *astar.Node, error) {
	result := map[*astar.Node]struct{}{}
	var start, end *astar.Node
	// Remember which node belonged to which location.
	convertedNodes := map[Vec]*astar.Node{}

	startX, startY := grid.TopLeft()
	endX, endY := grid.BottomRight()
	startVec := Vec{startX, startY}
	endVec := Vec{endX, endY}

	// Process the nodes themselves.
	for vec, cost := range grid {
		if _, ok := convertedNodes[vec]; ok {
			err := fmt.Errorf("node already present")
			return result, start, end, err
		}

		node, err := astar.NewNode(fmt.Sprint(vec), cost, numNeigh, nil)
		if err != nil {
			return result, start, end, err
		}

		convertedNodes[vec] = node
		result[node] = struct{}{}

		if vec == startVec {
			start = node
		}
		if vec == endVec {
			end = node
		}
	}
	if start == nil || end == nil {
		err := fmt.Errorf("cannot find start or end node")
		return result, start, end, err
	}
	// Add pairwise connections. This might take a while.
	for vec := range grid {
		node, ok := convertedNodes[vec]
		if !ok {
			err := fmt.Errorf("node not found")
			return result, start, end, err
		}
		for neigh := range pointEnv(vec) {
			if !grid.Has(neigh) {
				// Ignore nodes outside the grid.
				continue
			}
			neighNode, ok := convertedNodes[neigh]
			if !ok {
				err := fmt.Errorf("node not found")
				return result, start, end, err
			}
			// If a connection already exists, this is a no-op.
			node.AddConnection(neighNode)
			neighNode.AddConnection(node)
		}
	}
	return result, start, end, nil
}

//nolint: funlen
func main() {
	grid, err := ReadLinesAsGrid()
	if err != nil {
		log.Fatal(err.Error())
	}
	// Part 1.
	nodes, startNode, endNode, err := gridToNodes(grid)
	if err != nil {
		log.Fatal(err.Error())
	}

	fastAlgorithm(nodes, startNode, endNode)

	startX, startY := grid.TopLeft()
	endX, endY := grid.BottomRight()

	// Part 2.
	// Replicate grid. Then, run the fast algorithm
	largeGrid := Grid{}
	for p := range grid {
		for xRep := 0; xRep &lt; replicas; xRep++ {
			for yRep := 0; yRep &lt; replicas; yRep++ {
				newPoint := Vec{
					x: p.x + xRep*(endX-startX+1),
					y: p.y + yRep*(endY-startY+1),
				}
				newMarking := (grid.Count(p)-1+xRep+yRep)%9 + 1 //nolint:gomnd
				if largeGrid.Has(newPoint) {
					// Sanity check, we should never add a node twice.
					log.Fatal("node already there")
				}
				_ = largeGrid.Mark(newPoint, newMarking)
			}
		}
	}

	nodes, startNode, endNode, err = gridToNodes(largeGrid)
	if err != nil {
		log.Fatal(err.Error())
	}

	fastAlgorithm(nodes, startNode, endNode)
}

// end::solution[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">.gitignore</div>
<div class="content">
<pre class="prettyprint highlight"><code># Files containing actual data from the puzzles.
*.dat</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">utils.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

var reader = bufio.NewReader(os.Stdin)

// Function readLine reads one line from stdin via a global reader instance.
func readLine() (string, error) {
	return reader.ReadString('\n')
}

func trimStrings(sli []string) []string {
	result := make([]string, 0, len(sli))
	for _, val := range sli {
		result = append(result, strings.TrimSpace(val))
	}
	return result
}

func strSliceToIntSlice(sli []string) ([]int, error) {
	// I wish Go had a map function...
	result := make([]int, 0, len(sli))
	for _, val := range sli {
		conv, err := strconv.Atoi(val)
		if err != nil {
			return []int{}, err
		}
		result = append(result, conv)
	}
	return result, nil
}

// tag::utils[]

// ReadLinesAsGrid reads all lines from stdin as a grid. That is, each point on the grid has a
// value and a location.
func ReadLinesAsGrid() (Grid, error) {
	lineIdx := 0
	result := make(Grid)
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return Grid{}, err
		}
		line = strings.TrimSpace(line)
		ints, err := strSliceToIntSlice(strings.Split(line, ""))
		if err != nil {
			return Grid{}, err
		}
		for rowIdx, val := range ints {
			// This is lazy but I wanted to re-use old code.
			point, err := VecFromStr(fmt.Sprintf("%d%s%d", lineIdx, vecSep, rowIdx))
			if err != nil {
				return Grid{}, err
			}
			err = result.Mark(point, val)
			if err != nil {
				return Grid{}, err
			}
		}
		if err != nil {
			return Grid{}, err
		}
		lineIdx++
	}
}

// end::utils[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">go.sum</div>
<div class="content">
<pre class="prettyprint highlight"><code>github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/razziel89/astar v0.0.0-20211216165901-32e7316c1456 h1:KFEDStDiIgOxy2hQXtgDi9eTcJMu/BeExJf5UioTlTw=
github.com/razziel89/astar v0.0.0-20211216165901-32e7316c1456/go.mod h1:yyTuzRpZUgKNQ+Vfj68UMna8OJlMVfjyBTVI/y7R20s=
github.com/razziel89/astar v0.0.0-20211216204430-5ed9c880d163 h1:giMvq9wSL19Q3ANFD3sjD+XbWmYF9mPHkbaFqw+WmE0=
github.com/razziel89/astar v0.0.0-20211216204430-5ed9c880d163/go.mod h1:yyTuzRpZUgKNQ+Vfj68UMna8OJlMVfjyBTVI/y7R20s=
github.com/razziel89/astar v0.0.0-20211216205435-24506c207ceb h1:Fs7v2NdvjiXv1JR+2sqnFwS/Nsazsx8yUw4QBwDxIi4=
github.com/razziel89/astar v0.0.0-20211216205435-24506c207ceb/go.mod h1:yyTuzRpZUgKNQ+Vfj68UMna8OJlMVfjyBTVI/y7R20s=
github.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">node.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

import (
	"fmt"
	"strings"
)

// tag::node[]

// Node is a node in a tree.
type Node struct {
	ID          string
	Limit       int
	Value       int
	Connections []*Node
}

// AddConnection adds a connection to a node, but only if that connection does not yet exist. If it
// does, nothing is done.
func (n *Node) AddConnection(connection *Node) {
	for _, con := range n.Connections {
		if con == connection {
			return
		}
	}
	n.Connections = append(n.Connections, connection)
}

// ToStr provides a string representation for a node.
func (n *Node) ToStr() string {
	connectionIDs := []string{}
	for _, con := range n.Connections {
		connectionIDs = append(connectionIDs, con.ID)
	}
	connections := strings.Join(connectionIDs, ",")
	str := fmt.Sprintf("{N: %s, L: %d, C: %d, N: %s}", n.ID, n.Limit, n.Value, connections)
	return str
}

// end::node[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">go.mod</div>
<div class="content">
<pre class="prettyprint highlight"><code>module main

go 1.16

require github.com/razziel89/astar v0.0.0-20211216205435-24506c207ceb</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">grid.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

import (
	"fmt"
	"strings"
)

const (
	vecSep         = ","
	tokensPerPoint = 2
)

// tag::grid[]

// Vec is a 2D vector. Most of it has been taken from a previous solution.
type Vec struct {
	x, y int
}

var (
	unitX         = Vec{x: 1}
	unitY         = Vec{y: 1}
	pointEnvDisps = []Vec{
		unitX,
		unitY,
		unitY.Inv(),
		unitX.Inv(),
	}
)

// Obtain an iterator over a point's environment.
func pointEnv(point Vec) &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for _, disp := range pointEnvDisps {
			displaced := point.Add(disp)
			channel &lt;- displaced
		}
		close(channel)
	}()
	return channel
}

// VecFromStr converts a sring into a vector.
func VecFromStr(str string) (Vec, error) {
	fields := trimStrings(strings.Split(str, vecSep))
	if len(fields) != tokensPerPoint {
		return Vec{}, fmt.Errorf("cannot parse %v as vector, wrong number of fields", str)
	}
	ints, err := strSliceToIntSlice(fields)
	if err != nil {
		return Vec{}, fmt.Errorf("cannot parse %s as vector, %s", str, err.Error())
	}
	result := Vec{
		x: ints[0],
		y: ints[1],
	}
	return result, nil
}

// Add adds one vector to another one.
func (v Vec) Add(delta Vec) Vec {
	result := Vec{
		x: v.x + delta.x,
		y: v.y + delta.y,
	}
	return result
}

// Mul multiplies each component of a vector with a number.
func (v Vec) Mul(factor int) Vec {
	result := Vec{
		x: v.x * factor,
		y: v.y * factor,
	}
	return result
}

// Inv inverts a vector.
func (v Vec) Inv() Vec {
	return v.Mul(-1)
}

// Sub subtracts a vector'v data from another one'v.
func (v Vec) Sub(delta Vec) Vec {
	return v.Add(delta.Inv())
}

// Grid is a lazily evaluated grid that supports marking points on it. Most of it has been taken
// from a previous solution.
type Grid map[Vec]int

// Mark marks a point on the grid n times. Don't accept numbers &lt;0.
func (g *Grid) Mark(entry Vec, n int) error {
	if n &lt; 0 {
		return fmt.Errorf("can only mark non-negative times")
	}
	// We don't have to handle non-existing values here since Go returns the zero value (0 for
	// integers) for such entries.
	(*g)[entry] = (*g)[entry] + n
	return nil
}

// Count determines how often a point has been marked.
func (g *Grid) Count(entry Vec) int {
	return (*g)[entry]
}

// Has determines whether a point is on the grid.
func (g *Grid) Has(entry Vec) bool {
	_, ok := (*g)[entry]
	return ok
}

// RemoveAll removes all markings for a specific point.
func (g *Grid) RemoveAll(entry Vec) {
	delete(*g, entry)
}

// FilterThreshold returns all points whose value exceeds a threshold.
func (g *Grid) FilterThreshold(threshold int) []Vec {
	result := []Vec{}
	for point := range g.Points() {
		if g.Count(point) &gt; threshold {
			result = append(result, point)
		}
	}
	return result
}

// MarkAll maks all points in the grid with the same value.
func (g *Grid) MarkAll(val int) error {
	for p := range g.Points() {
		if err := g.Mark(p, val); err != nil {
			return err
		}
	}
	return nil
}

// EnvFn is a function type used to determine a point's environment.
type EnvFn = func(point Vec) &lt;-chan Vec

// MarkExistingEnv marks all points by the specified value in the environment of a given point. The
// environment is defined by envFn. Only points that actually exist will be marked.
func (g *Grid) MarkExistingEnv(val int, point Vec, envFn EnvFn) error {
	for neigh := range envFn(point) {
		if !g.Has(neigh) {
			continue
		}
		if err := g.Mark(neigh, val); err != nil {
			return err
		}
	}
	return nil
}

// Points returns an iterator over all points on the grid.
func (g *Grid) Points() &lt;-chan Vec {
	channel := make(chan Vec)
	go func() {
		for point := range *g {
			channel &lt;- point
		}
		close(channel)
	}()
	return channel
}

// TopLeft returns the coordinates of the top left node.
func (g *Grid) TopLeft() (int, int) {
	foundX, foundY := false, false
	minX, minY := 0, 0
	for p := range g.Points() {
		if !foundX || p.x &lt; minX {
			minX = p.x
			foundX = true
		}
		if !foundY || p.y &lt; minY {
			minY = p.y
			foundY = true
		}
	}
	return minX, minY
}

// BottomRight returns the coordinates of the bottom right node.
func (g *Grid) BottomRight() (int, int) {
	foundX, foundY := false, false
	maxX, maxY := 0, 0
	for p := range g.Points() {
		if !foundX || p.x &gt; maxX {
			maxX = p.x
			foundX = true
		}
		if !foundY || p.y &gt; maxY {
			maxY = p.y
			foundY = true
		}
	}
	return maxX, maxY
}

// Pretty creates a pretty string representation of this grid.
func (g *Grid) Pretty(digits int) string {
	result := ""
	empty := " "
	maxVal := 10
	for count := 1; count &lt; digits; count++ {
		empty += " "
		maxVal *= 10
	}
	formatStr := fmt.Sprintf("%%-%dd", digits)
	minX, minY := g.TopLeft()
	maxX, maxY := g.BottomRight()
	for x := minX; x &lt;= maxX; x++ {
		for y := minY; y &lt;= maxY; y++ {
			val := g.Count(Vec{x: x, y: y})
			if val &gt; 0 {
				result += fmt.Sprintf(formatStr, val)
				if val &gt;= maxVal {
					// Return the string up to the offending point so that the caller sees what the
					// offending number was. This is a hack at best but good enough for me right
					// now.
					return result + "\nINCOMPLETE"
				}
			} else {
				result += empty
			}
		}
		result += "\n"
	}
	return result
}

// end::grid[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">fast.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

// This is an implementation using an A* algorithm implemented by me.

import (
	"fmt"
	"log"

	"github.com/razziel89/astar"
)

func nameToCoords(name string) (int, int) {
	var endX, endY int
	// Extract end coordinates from the name.
	count, err := fmt.Sscanf(name, "{%d %d}", &amp;endX, &amp;endY)
	if err != nil {
		log.Fatal(err.Error())
	}
	if count != 2 { //nolint:gomnd
		log.Fatal("parsing error")
	}
	return endX, endY
}

func fastAlgorithm(nodes map[*astar.Node]struct{}, start, end *astar.Node) {
	// Build heuristic that measures distance to end node.
	heuristic := astar.ConstantHeuristic{}
	endX, endY := nameToCoords(end.ID)
	for node := range nodes {
		x, y := nameToCoords(node.ID)
		// The estimate assumes a cost of 1 for the most direct connection.
		estimate := (x - endX) + (y - endY)
		err := heuristic.AddNode(node, estimate)
		if err != nil {
			log.Fatal(err.Error())
		}
	}
	// Plot path.
	path, err := astar.FindPath(nodes, start, end, heuristic.Heuristic(0))
	if err != nil {
		log.Fatal(err.Error())
	}
	// Compute cost.
	cost := 0
	for _, node := range path[1:] {
		fmt.Println(node.ToString())
		cost += node.Cost
	}
	fmt.Println("Cost is", cost)
}</code></pre>
</div>
</div>
<a id="day16" />
</div>
</div>
<div class="sect2">
<h3 id="_day_16_go"><a class="anchor" href="#_day_16_go"></a><a class="link" href="#_day_16_go">Day 16: go</a></h3>
<div class="paragraph">
<p><span class="small">this documentation is autogenerated. Add a <code>README.adoc</code> to your solution to take over the control of this :-)</span></p>
</div>
<div class="sect3">
<h4 id="_go_2"><a class="anchor" href="#_go_2"></a><a class="link" href="#_go_2">go</a></h4>
<div class="listingblock">
<div class="title">operator.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

const (
	// Numerical values, there are a lot of them this time.
	totalLengthModeBits      = 15
	totalNumPackagesModeBits = 11
)

// Operator is an actual implementation of the package interface, operator value.
type Operator struct {
	version     int
	typeInfo    int
	subPackages []Package
}

// Version provides the version number.
func (p *Operator) Version() int {
	return p.version
}

// Type provides the type information.
func (p *Operator) Type() int {
	return p.typeInfo
}

// SubPackages provides a list of sub-packages.
func (p *Operator) SubPackages() []Package {
	result := make([]Package, 0, len(p.subPackages))
	//nolint:gosimple
	for _, pkg := range p.subPackages {
		result = append(result, pkg)
	}
	return result
}

// Value determines the value of this package.
//nolint:funlen
func (p *Operator) Value() int {
	//nolint:gomnd
	switch p.Type() {
	case 0:
		// Packets with type ID 0 are sum packets - their value is the sum of the values of their
		// sub-packets. If they only have a single sub-packet, their value is the value of the
		// sub-packet.
		result := 0
		for _, pkg := range p.SubPackages() {
			result += pkg.Value()
		}
		return result
	case 1:
		// Packets with type ID 1 are product packets - their value is the result of multiplying
		// together the values of their sub-packets. If they only have a single sub-packet, their
		// value is the value of the sub-packet.
		//
		// Treat packages without sub-packages as having no value. This should not happen for prduct
		// packages.
		if len(p.subPackages) == 0 {
			return 0
		}
		result := 1
		for _, pkg := range p.subPackages {
			result *= pkg.Value()
		}
		return result
	case 2:
		// Packets with type ID 2 are minimum packets - their value is the minimum of the values of
		// their sub-packets.
		result := 0
		found := false
		for _, pkg := range p.subPackages {
			val := pkg.Value()
			if !found || val &lt; result {
				result = val
				found = true
			}
		}
		return result
	case 3:
		// Packets with type ID 3 are maximum packets - their value is the maximum of the values of
		// their sub-packets.
		result := 0
		found := false
		for _, pkg := range p.subPackages {
			val := pkg.Value()
			if !found || val &gt; result {
				result = val
				found = true
			}
		}
		return result
	case 5:
		// Packets with type ID 5 are greater than packets - their value is 1 if the value of the
		// first sub-packet is greater than the value of the second sub-packet; otherwise, their
		// value is 0.  These packets always have exactly two sub-packets.
		result := 0
		if len(p.subPackages) == 2 &amp;&amp; p.subPackages[0].Value() &gt; p.subPackages[1].Value() {
			result = 1
		}
		return result
	case 6:
		// Packets with type ID 6 are less than packets - their value is 1 if the value of the first
		// sub-packet is less than the value of the second sub-packet; otherwise, their value is 0.
		// These packets always have exactly two sub-packets.
		result := 0
		if len(p.subPackages) == 2 &amp;&amp; p.subPackages[0].Value() &lt; p.subPackages[1].Value() {
			result = 1
		}
		return result
	case 7:
		// Packets with type ID 7 are equal to packets - their value is 1 if the value of the first
		// sub-packet is equal to the value of the second sub-packet; otherwise, their value is 0.
		// These packets always have exactly two sub-packets.
		result := 0
		if len(p.subPackages) == 2 &amp;&amp; p.subPackages[0].Value() == p.subPackages[1].Value() {
			result = 1
		}
		return result
	default:
		// Should never happen.
		return 0
	}
}

// NewOperator creates a new literal package. Version and type information have to be provided.
func NewOperator(version, typeInfo int, stream *BitStream) Operator {
	subPackages := []Package{}
	modeBit := stream.Next(1)
	if !modeBit[0] {
		// Total length mode.
		totalLength := BitsToInt(stream.Next(totalLengthModeBits))
		shortStream := stream.LimitedStream(totalLength)
		for !shortStream.Done() {
			// No padding in between according to the task.
			pkg := FromBitStream(&amp;shortStream)
			subPackages = append(subPackages, pkg)
		}
	} else {
		// Number of packages mode.
		numPkgs := BitsToInt(stream.Next(totalNumPackagesModeBits))
		for count := 0; count &lt; numPkgs; count++ {
			// No padding in between according to the task.
			pkg := FromBitStream(stream)
			subPackages = append(subPackages, pkg)
		}
	}
	return Operator{
		version:     version,
		typeInfo:    typeInfo,
		subPackages: subPackages,
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">solution.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>// Package main is the main executable for razziel89's solution for this day's advent.
package main

import (
	"fmt"
	"log"
)

// tag::solution[]

//nolint: funlen
func main() {
	lines, err := ReadLinesAsLines()
	if err != nil {
		log.Fatal(err.Error())
	}
	if len(lines) != 1 {
		log.Fatal("wrong number of lines")
	}

	parsed, err := Parse(lines[0])
	if err != nil {
		log.Fatal(err.Error())
	}

	// Declare here to allow recursion.
	var addVersionsUp func([]Package) int

	addVersionsUp = func(packages []Package) int {
		result := 0
		for _, pkg := range packages {
			result += pkg.Version()
			result += addVersionsUp(pkg.SubPackages())
		}
		return result
	}

	totalVersion := addVersionsUp(parsed)

	fmt.Println("Sum of all version numbers is", totalVersion)

	if len(parsed) != 1 {
		log.Fatal("we were promised exactly one package")
	}
	fmt.Println("Value of outermost package is", parsed[0].Value())
}

// end::solution[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">.gitignore</div>
<div class="content">
<pre class="prettyprint highlight"><code># Files containing actual data from the puzzles.
*.dat</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">utils.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

import (
	"bufio"
	"io"
	"os"
	"strings"
)

var reader = bufio.NewReader(os.Stdin)

// Function readLine reads one line from stdin via a global reader instance.
func readLine() (string, error) {
	return reader.ReadString('\n')
}

// tag::utils[]

// ReadLinesAsLines reads in some lines.
func ReadLinesAsLines() ([]string, error) {
	result := []string{}
	for {
		line, err := readLine()
		if err == io.EOF {
			// Success case, no more input to read.
			return result, nil
		}
		if err != nil {
			return []string{}, err
		}
		line = strings.TrimSpace(line)
		result = append(result, line)
	}
}

// end::utils[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">go.sum</div>
<div class="content">
<pre class="prettyprint highlight"><code></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">package.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

const (
	// Numerical values, there are a lot of them this time.
	versionBits  = 3
	typeInfoBits = 3
	// Type information.
	literalType = 4
)

// Package describes a package.
type Package interface {
	Version() int
	Type() int
	SubPackages() []Package
	Value() int
}

// FromBitStream obtains a package from a bit stream. No padding on the stream is done.
func FromBitStream(stream *BitStream) Package {
	version := BitsToInt(stream.Next(versionBits))
	typeInfo := BitsToInt(stream.Next(typeInfoBits))
	var pkg Package
	if typeInfo == literalType {
		lit := NewLiteral(version, typeInfo, stream)
		pkg = &amp;lit
	} else {
		op := NewOperator(version, typeInfo, stream)
		pkg = &amp;op
	}
	return pkg
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">go.mod</div>
<div class="content">
<pre class="prettyprint highlight"><code>module main

go 1.16</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">literal.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

const (
	// Numerical values, there are a lot of them this time.
	bitsPerLiteralSet = 4
)

// Literal is an actual implementation of the package interface, literal value.
type Literal struct {
	version  int
	typeInfo int
	value    int
	// subPackages []*Literal
}

// Version provides the version number.
func (p *Literal) Version() int {
	return p.version
}

// Type provides the type information.
func (p *Literal) Type() int {
	return p.typeInfo
}

// Value provides the value information.
func (p *Literal) Value() int {
	return p.value
}

// SubPackages provides a list of sub-packages.
func (p *Literal) SubPackages() []Package {
	// Literal packages have no sub-packages. To implement the interface, we return an empty slice
	// here.
	return []Package{}
}

// NewLiteral creates a new literal package. Version and type information have to be provided.
func NewLiteral(version, typeInfo int, stream *BitStream) Literal {
	bits := []bool{}
	for notLastGroup := stream.Next(1); notLastGroup[0]; notLastGroup = stream.Next(1) {
		bits = append(bits, stream.Next(bitsPerLiteralSet)...)
	}
	bits = append(bits, stream.Next(bitsPerLiteralSet)...)
	num := BitsToInt(bits)
	return Literal{
		version:  version,
		typeInfo: typeInfo,
		value:    num,
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">parser.go</div>
<div class="content">
<pre class="prettyprint highlight"><code>package main

import (
	"fmt"
	"log"
	"strconv"
	"strings"
)

const (
	hexBase    = 16
	binarybase = 2
	padding    = 4
)

func hexToBinary(char rune) ([]bool, error) {
	num, err := strconv.ParseInt(string(char), hexBase, 0)
	if err != nil {
		return []bool{}, err
	}
	binaryString := strconv.FormatInt(num, binarybase)
	for len(binaryString) &lt; padding {
		binaryString = "0" + binaryString
	}
	result := make([]bool, 0, len(binaryString))
	for _, char := range binaryString {
		result = append(result, char == '1')
	}
	return result, nil
}

// BitStream provides a stream of bits based on hex code. I am using boolean values here to
// represent bits.
type BitStream struct {
	bin  []bool
	pad  int
	read int
}

// Next provides the next num bits.
func (s *BitStream) Next(num int) []bool {
	if s.read+num &gt; len(s.bin) {
		log.Fatalf("trying to read too much, remaining %s, reading %d", s.ToString(true), num)
	}
	if num &lt;= 0 {
		return []bool{}
	}
	result := s.bin[s.read : s.read+num : s.read+num]
	s.read += num
	s.pad = (s.pad + num) % padding
	return result
}

// Done determines whether any characters are left. If only zeroes are left, we also exit.
func (s *BitStream) Done() bool {
	if s.read &gt;= len(s.bin) {
		return true
	}
	for _, bit := range s.bin[s.read:] {
		if bit {
			return false
		}
	}
	return true
}

// Pad reads up to the next multiple of since one hexadecimal digit is four binary digits.
func (s *BitStream) Pad() {
	if s.pad &gt; 0 {
		_ = s.Next(padding - s.pad)
	}
}

// AddHex adds a hex string.
func (s *BitStream) AddHex(hex string) error {
	if len(s.bin) == 0 {
		s.bin = make([]bool, 0, len(hex))
	} else {
		newBin := make([]bool, 0, len(s.bin)+len(hex))
		_ = copy(newBin, s.bin)
		s.bin = newBin
	}
	hex = strings.ToUpper(hex)
	for _, char := range hex {
		binarySequence, err := hexToBinary(char)
		if err != nil {
			return fmt.Errorf("error in hex to binary conversion: %s", err.Error())
		}
		s.bin = append(s.bin, binarySequence...)
	}
	return nil
}

// ToString converts to a binary string. Specify whether you want truncated (true) or full (false)
func (s *BitStream) ToString(truncated bool) string {
	result := ""
	start := 0
	if truncated {
		start = s.read
	}
	for _, val := range s.bin[start:] {
		if val {
			result += "1"
		} else {
			result += "0"
		}
	}
	fmtStr := fmt.Sprintf("%%%ds", len(s.bin))
	return fmt.Sprintf(fmtStr, result)
}

// LimitedStream creates a limited bit stream based on the next limit bits of this one.
func (s *BitStream) LimitedStream(limit int) BitStream {
	stream := BitStream{
		bin:  s.Next(limit),
		pad:  0,
		read: 0,
	}
	return stream
}

// BitsToInt converts a stream of bits into an integer.
func BitsToInt(bits []bool) int {
	result := 0
	for _, bit := range bits {
		result *= 2
		if bit {
			result++
		}
	}
	return result
}

// Parse parses a string into packages and sub-packages.
func Parse(input string) ([]Package, error) {
	result := []Package{}

	stream := BitStream{}
	if err := stream.AddHex(input); err != nil {
		return []Package{}, err
	}

	for !stream.Done() {
		pkg := FromBitStream(&amp;stream)
		result = append(result, pkg)
		stream.Pad()
	}

	return result, nil
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2021 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>